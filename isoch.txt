=== src/Isoch/core/AudioClockPLL.cpp ===
#include "Isoch/core/AudioClockPLL.hpp"
#include <mach/mach_time.h>
#include <time.h> // For clock_gettime_nsec_np if needed elsewhere
#include <cmath>  // For fabs
#include <algorithm> // for std::clamp

// Define nanoseconds per second for clarity
constexpr double NANOS_PER_SECOND = 1e9;
// Define FireWire cycle timer frequency
constexpr double FW_CYCLE_TIMER_HZ = 24576000.0;

namespace FWA {
namespace Isoch {

// Constructor
AudioClockPLL::AudioClockPLL(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)),
      targetSampleRate_(44100.0) // Default
{
    initializeHostClockInfo();
    resetState();
    if (logger_) logger_->debug("AudioClockPLL created.");
}

// Destructor
AudioClockPLL::~AudioClockPLL() {
     if (logger_) logger_->debug("AudioClockPLL destroyed.");
}

// --- Configuration ---
void AudioClockPLL::setSampleRate(double rate) {
    if (rate > 0) {
        targetSampleRate_ = rate;
        if (logger_) logger_->info("PLL Target Sample Rate set to: {:.2f} Hz", targetSampleRate_);
        // Optionally reset PLL state when rate changes?
        // resetState();
    } else {
        if (logger_) logger_->error("PLL Invalid sample rate specified: {}", rate);
    }
}

void AudioClockPLL::setPllGains(double kp, double ki) {
    pllProportionalGain_ = kp;
    pllIntegralGain_ = ki;
    if (logger_) logger_->info("PLL Gains set: Kp={}, Ki={}", kp, ki);
    // Optionally set accumulator limits based on gains
    // integralMax_ = ...; integralMin_ = ...;
}

// --- Control ---
void AudioClockPLL::initializeHostClockInfo() {
    mach_timebase_info(&timebaseInfo_);
    if (timebaseInfo_.denom == 0) { // Avoid division by zero
         if (logger_) logger_->error("PLL: Invalid timebase denominator!");
         // Set defaults
         hostTicksPerSecond_ = 1000000000; // Assume 1 tick = 1 ns as fallback
    } else {
        hostTicksPerSecond_ = static_cast<uint64_t>(NANOS_PER_SECOND *
            (static_cast<double>(timebaseInfo_.denom) / static_cast<double>(timebaseInfo_.numer)));
    }
    if (logger_) logger_->debug("PLL Host Clock Info: Rate ~{} ticks/sec, {}/{} ns ratio",
                                hostTicksPerSecond_, timebaseInfo_.numer, timebaseInfo_.denom);
}

void AudioClockPLL::resetState() {
    initialized_ = false;
    initialHostTimeAbs_ = 0;
    initialFwTimestamp_ = 0;
    lastHostTimeAbs_ = 0;
    lastFwTimestamp_ = 0;
    lastSYT_ = 0xFFFF;
    lastSYT_FWTimestamp_ = 0;
    lastSYT_AbsSampleIndex_ = 0;
    lastSYT_HostTimeAbs_ = 0;
    lastPacketEndAbsSampleIndex_ = 0;
    currentRatio_ = 1.0;
    phaseErrorAccumulator_ = 0.0;
    frequencyAdjustment_ = 0.0;
    if (logger_) logger_->info("PLL state reset.");
}

void AudioClockPLL::initialize(uint64_t initialHostTimeAbs, uint32_t initialFwTimestamp) {
    resetState();
    if (logger_) logger_->info("PLL Initializing: HostTimeAbs={}, FWTimestamp={:#0x}", initialHostTimeAbs, initialFwTimestamp);
    initialHostTimeAbs_ = initialHostTimeAbs;
    initialFwTimestamp_ = initialFwTimestamp;
    lastHostTimeAbs_ = initialHostTimeAbs;
    lastFwTimestamp_ = initialFwTimestamp;
    lastPacketEndAbsSampleIndex_ = 0;
    lastSYT_HostTimeAbs_ = initialHostTimeAbs; // Initialize SYT anchor host time
    initialized_ = true;
}

// Called separately after initialize() when the first valid SYT arrives
void AudioClockPLL::updateInitialSYT(uint16_t firstSyt, uint32_t firstSytFwTimestamp, uint64_t firstSytAbsSampleIndex) {
    if (!initialized_) {
        if (logger_) logger_->warn("PLL: updateInitialSYT called before initialize!");
        return;
    }
    if (lastSYT_ == 0xFFFF) { // Only update if we haven't captured one yet
        lastSYT_ = firstSyt;
        lastSYT_FWTimestamp_ = firstSytFwTimestamp;
        lastSYT_AbsSampleIndex_ = firstSytAbsSampleIndex;
        lastSYT_HostTimeAbs_ = mach_absolute_time(); // Host time when this SYT is processed
        if (logger_) logger_->info("PLL Initial SYT Captured: SYT={}, FW_TS={:#0x}, AbsSampleIdx={}, HostAbs={}",
                                  lastSYT_, lastSYT_FWTimestamp_, lastSYT_AbsSampleIndex_, lastSYT_HostTimeAbs_);
    }
}

void AudioClockPLL::update(const PacketTimingInfo& timing, uint64_t currentHostTimeAbs) {
    if (!initialized_) {
        // Initialization now happens externally via synchronizeAndInitializePLL
        // or by calling initialize directly if the first packet has a valid FW TS.
        // We still might receive an update call before the *first SYT* has been processed.
        if (timing.fwTimestamp != 0) {
            // If initialize wasn't called yet, do it now.
            initialize(currentHostTimeAbs, timing.fwTimestamp);
            if (timing.syt != 0xFFFF) {
                // If this first packet also has SYT, anchor it.
                updateInitialSYT(timing.syt, timing.fwTimestamp, timing.firstAbsSampleIndex);
            }
        } else {
            if (logger_) logger_->warn("PLL Update: Still waiting for valid FW Timestamp to initialize.");
            return; // Can't do anything without initial sync
        }
    }

    // Only update if host time has advanced
    if (currentHostTimeAbs <= lastHostTimeAbs_ || timing.numSamplesInPacket == 0) {
        lastPacketEndAbsSampleIndex_ = timing.firstAbsSampleIndex + timing.numSamplesInPacket;
        return;
    }

    // --- PLL Update Logic using SYT ---
    if (timing.syt != 0xFFFF && lastSYT_ != 0xFFFF && timing.syt != lastSYT_) {
        // We have two consecutive valid SYTs
        uint64_t samplesSinceLastSYT = timing.firstAbsSampleIndex - lastSYT_AbsSampleIndex_;
        if (timing.firstAbsSampleIndex < lastSYT_AbsSampleIndex_) { /* Handle wrap */ samplesSinceLastSYT = 0; }

        if (samplesSinceLastSYT > 0 && targetSampleRate_ > 0) {
            double expectedFwTicksForSamples = (static_cast<double>(samplesSinceLastSYT) / targetSampleRate_)
                                               * fwClock_NominalRateHz_;

            int32_t fwTicksBetweenSYTs = static_cast<int32_t>(timing.fwTimestamp - lastSYT_FWTimestamp_);
            const int32_t oneSecondTicks = static_cast<int32_t>(fwClock_NominalRateHz_);
            const int32_t halfSecondTicks = oneSecondTicks / 2;
            if (fwTicksBetweenSYTs < -halfSecondTicks) { fwTicksBetweenSYTs += oneSecondTicks; }
            else if (fwTicksBetweenSYTs > halfSecondTicks) { fwTicksBetweenSYTs -= oneSecondTicks; }

            double phaseErrorTicks = static_cast<double>(fwTicksBetweenSYTs) - expectedFwTicksForSamples;

            // Update PI Controller
            phaseErrorAccumulator_ += phaseErrorTicks * pllIntegralGain_;
            phaseErrorAccumulator_ = std::clamp(phaseErrorAccumulator_, integralMin_, integralMax_); // Clamp integral term

            double frequencyAdjustment = (phaseErrorTicks * pllProportionalGain_) + phaseErrorAccumulator_;

            // Update the ratio: Ratio = NominalRate / AdjustedRate = 1.0 / (1.0 + adjustment)
            // Or simpler: directly adjust ratio based on relative freq adjustment
            // We define currentRatio_ as DeviceRate/HostRate.
            // If device is fast, phaseError is positive, we want to *increase* ratio estimate.
            // If device is slow, phaseError is negative, we want to *decrease* ratio estimate.
            // Let's adjust ratio directly proportional to freq adjustment.
            // Adjustment represents fractional deviation from nominal FW ticks per host tick equivalent.
            // Need to relate phaseErrorTicks to host time elapsed.
            uint64_t hostTicksElapsedSinceSYT = currentHostTimeAbs - lastSYT_HostTimeAbs_;
            double hostSecondsElapsed = static_cast<double>(absolute_to_nanoseconds(hostTicksElapsedSinceSYT)) / NANOS_PER_SECOND;

            if (hostSecondsElapsed > 1e-9) { // Avoid division by zero
                // Freq Error (Hz deviation) = Phase Error (ticks) / Time Elapsed (s) / (Ticks/Sec)
                double freqErrorHz = (phaseErrorTicks / hostSecondsElapsed) / fwClock_NominalRateHz_;
                // Adjust ratio: ratio' = ratio * (1 + Kp*error + Ki*integral)
                // Simpler: Adjust the ratio based on the normalized frequency adjustment
                double adjustmentFactor = freqErrorHz * pllProportionalGain_ + phaseErrorAccumulator_ * pllIntegralGain_; // Simplified gain application

                double newRatio = currentRatio_ * (1.0 + adjustmentFactor); // Adjust multiplicatively

                // Clamp and smooth the ratio
                newRatio = std::clamp(newRatio, 0.999, 1.001); // +/- 1000 ppm clamp
                double alpha = 0.1; // Smoothing factor
                currentRatio_ = alpha * newRatio + (1.0 - alpha) * currentRatio_;

                if (logger_ && logger_->should_log(spdlog::level::debug)) {
                    logger_->debug("PLL SYT Update: Samples={}, FW Tick Delta={}, Expected Delta={:.1f}, PhaseError={:.1f}, FreqErrHz={:.4f}, NewRatio={:.8f}",
                                  samplesSinceLastSYT, fwTicksBetweenSYTs, expectedFwTicksForSamples, phaseErrorTicks, freqErrorHz, currentRatio_);
                }
            }

            // Update anchor points
            lastSYT_ = timing.syt;
            lastSYT_FWTimestamp_ = timing.fwTimestamp;
            lastSYT_AbsSampleIndex_ = timing.firstAbsSampleIndex;
            lastSYT_HostTimeAbs_ = currentHostTimeAbs; // Anchor to current host time

        } // else log trace (no samples or rate 0)
    } // else log trace (no valid consecutive SYT)

    // Update general state
    lastFwTimestamp_ = timing.fwTimestamp;
    lastHostTimeAbs_ = currentHostTimeAbs;
    lastPacketEndAbsSampleIndex_ = timing.firstAbsSampleIndex + timing.numSamplesInPacket;
}

uint64_t AudioClockPLL::getPresentationTimeNs(uint64_t absoluteSampleIndex) {
    if (!initialized_) {
        if (logger_) logger_->warn("PLL getPresentationTimeNs called before initialization!");
        return clock_gettime_nsec_np(CLOCK_UPTIME_RAW) + 5000000; // Return future time
    }

    // Use the last SYT arrival as the most reliable anchor point
    uint64_t anchorHostTimeAbs = lastSYT_HostTimeAbs_;
    uint64_t anchorAbsSampleIndex = lastSYT_AbsSampleIndex_;

    if (lastSYT_ == 0xFFFF || lastSYT_HostTimeAbs_ == 0) { // Fallback to initial if no SYT seen yet or anchor invalid
        anchorHostTimeAbs = initialHostTimeAbs_;
        anchorAbsSampleIndex = 0;
    }

    uint64_t samplesSinceAnchor = 0;
    if (absoluteSampleIndex >= anchorAbsSampleIndex) {
        samplesSinceAnchor = absoluteSampleIndex - anchorAbsSampleIndex;
    } else {
        if (logger_) logger_->warn("getPresentationTimeNs: Target sample index {} is before anchor {}", absoluteSampleIndex, anchorAbsSampleIndex);
        // Return anchor time? Or time slightly after?
        return absolute_to_nanoseconds(anchorHostTimeAbs);
    }

    // Calculate expected host ticks delta based on target rate and CURRENT ratio
    if (targetSampleRate_ <= 0) {
        if (logger_) logger_->error("PLL: Invalid targetSampleRate_ ({})", targetSampleRate_);
        return absolute_to_nanoseconds(anchorHostTimeAbs); // Cannot predict
    }
    // Host Ticks = Samples * (HostTicks/Sec) / (Samples/Sec * Ratio)
    // Ratio = DeviceRate / HostRate => Host Ticks = Samples * HostTicksPerSec / (DeviceRate) = Samples * HostTicksPerSample / Ratio
    double hostTicksPerSec = static_cast<double>(NANOS_PER_SECOND * timebaseInfo_.denom) / timebaseInfo_.numer;
    double hostTicksPerSample_Nominal = hostTicksPerSec / targetSampleRate_;

    // Adjust expected host ticks based on the current clock ratio estimate
    // If currentRatio_ > 1 (device faster), we need *fewer* host ticks per device sample.
    // If currentRatio_ < 1 (device slower), we need *more* host ticks per device sample.
    double estimatedHostTickDelta = static_cast<double>(samplesSinceAnchor) * hostTicksPerSample_Nominal / currentRatio_;

    uint64_t estimatedHostTimeAbs = anchorHostTimeAbs + static_cast<uint64_t>(estimatedHostTickDelta);

    uint64_t estimatedHostTimeNano = absolute_to_nanoseconds(estimatedHostTimeAbs);

    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        uint64_t anchorHostNano = absolute_to_nanoseconds(anchorHostTimeAbs);
        logger_->trace("GetPresTime: AbsIdx={}, SamplesSinceAnchor={}, AnchorHostNano={}, DeltaTicks={:.0f}, Ratio={:.8f}, ResultHostAbs={}, ResultHostNano={}",
                      absoluteSampleIndex, samplesSinceAnchor, anchorHostNano, estimatedHostTickDelta, currentRatio_, estimatedHostTimeAbs, estimatedHostTimeNano);
    }

    return estimatedHostTimeNano;
}

// Helper: Convert absolute time to nanoseconds
uint64_t AudioClockPLL::absolute_to_nanoseconds(uint64_t mach_time) const {
    if (timebaseInfo_.denom == 0) return 0;
    // Use floating point for potentially better precision with large numbers
    long double conversion_factor = static_cast<long double>(timebaseInfo_.numer) / timebaseInfo_.denom;
    return static_cast<uint64_t>(mach_time * conversion_factor);
}

// Helper: Convert nanoseconds to absolute time
uint64_t AudioClockPLL::nanoseconds_to_absolute(uint64_t nano_time) const {
    if (timebaseInfo_.numer == 0) return 0;
    long double conversion_factor = static_cast<long double>(timebaseInfo_.denom) / timebaseInfo_.numer;
    return static_cast<uint64_t>(nano_time * conversion_factor);
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/AmdtpReceiver.cpp ===
#include "Isoch/core/AmdtpReceiver.hpp"
// Include the needed headers
#include "Isoch/core/IsochDCLManager.hpp"
#include "Isoch/core/IsochPortChannelManager.hpp"
#include "Isoch/core/IsochBufferManager.hpp"
#include "Isoch/core/IsochTransportManager.hpp"
#include "Isoch/core/IsochPacketProcessor.hpp"
#include "Isoch/core/IsochMonitoringManager.hpp"
#include "Isoch/core/AudioClockPLL.hpp"     // Include the new AudioClockPLL header
#include "Isoch/utils/RingBuffer.hpp"       // Include RingBuffer header
#include <spdlog/spdlog.h>
#include <mach/mach.h>
#include <mach/thread_policy.h>
#include <mach/mach_time.h>                // For mach_absolute_time
#include <time.h>                          // For clock_gettime_nsec_np
#include <unistd.h>
// to_hex for spdlog
#include <spdlog/fmt/bin_to_hex.h>

#include "Isoch/utils/RingBuffer.hpp"

namespace FWA {
namespace Isoch {

// Helper (can be moved to utils)
static inline uint64_t absolute_to_nanoseconds(uint64_t mach_time) {
    mach_timebase_info_data_t timebase_info;
    mach_timebase_info(&timebase_info);
    if (timebase_info.denom == 0) return 0;
    long double conversion_factor = static_cast<long double>(timebase_info.numer) / timebase_info.denom;
    return static_cast<uint64_t>(mach_time * conversion_factor);
}
// --- End Helper ---

std::shared_ptr<AmdtpReceiver> AmdtpReceiver::create(const ReceiverConfig& config) {
    if (!config.logger) {
        // Use default logger if none provided
        auto defaultLogger = spdlog::default_logger();
        ReceiverConfig updatedConfig = config;
        updatedConfig.logger = defaultLogger;
        return std::shared_ptr<AmdtpReceiver>(new AmdtpReceiver(updatedConfig));
    }
    
    return std::shared_ptr<AmdtpReceiver>(new AmdtpReceiver(config));
}

AmdtpReceiver::AmdtpReceiver(const ReceiverConfig& config)
    : config_(config)
    , logger_(config.logger) {
    
    if (logger_) {
        logger_->info("AmdtpReceiver created with numGroups={}, packetsPerGroup={}, packetDataSize={}",
                     config_.numGroups, config_.packetsPerGroup, config_.packetDataSize);
    }
}

AmdtpReceiver::~AmdtpReceiver() {
    // Stop receiver if still running
    if (running_) {
        stopReceive();
    }
    
    // Clean up resources
    cleanup();
    
    if (logger_) {
        logger_->info("AmdtpReceiver destroyed");
    }
}

void AmdtpReceiver::cleanup() noexcept {
    // Release components in reverse order of creation
    monitoringManager_.reset();
    packetProcessor_.reset();
    transportManager_.reset();
    dclManager_.reset();
    portChannelManager_.reset();
    bufferManager_.reset();

    // Reset placeholder components
    pll_.reset();
    appRingBuffer_.reset();

    // Clear callback data store
    callbackDataStore_.clear();

    initialized_ = false;
    running_ = false;

    if (logger_) {
        logger_->debug("AmdtpReceiver::cleanup: Resources released");
    }
}

std::expected<void, IOKitError> AmdtpReceiver::initialize(IOFireWireLibNubRef interface) {
    if (initialized_) {
        if (logger_) {
            logger_->error("AmdtpReceiver::initialize: Already initialized");
        }
        return std::unexpected(IOKitError::Busy);
    }
    
    if (!interface) {
        if (logger_) {
            logger_->error("AmdtpReceiver::initialize: Interface is null");
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // Set up RunLoop
    runLoopRef_ = CFRunLoopGetCurrent();
    
    if (logger_) {
        logger_->info("AmdtpReceiver::initialize: Using RunLoop={:p}", (void*)runLoopRef_);
    }
    
    // Set up components
    auto result = setupComponents(interface);
    if (!result) {
        cleanup();
        return std::unexpected(result.error());
    }
    
    initialized_ = true;
    
    if (logger_) {
        logger_->info("AmdtpReceiver::initialize: Initialized successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> AmdtpReceiver::setupComponents(IOFireWireLibNubRef interface) {
    if (logger_) {
        logger_->debug("AmdtpReceiver::setupComponents (Kernel Style)");
    }

    // 1. Create IsochBufferManager (using new config)
    bufferManager_ = std::make_unique<IsochBufferManager>(logger_);
    IsochBufferManager::Config bufferConfig = {
        .numGroups = config_.numGroups,
        .packetsPerGroup = config_.packetsPerGroup,
        .packetDataSize = config_.packetDataSize
    };
    auto bufferSetupResult = bufferManager_->setupBuffers(bufferConfig);
    if (!bufferSetupResult) {
         if (logger_) logger_->error("Failed to set up buffers: {}", iokit_error_category().message(static_cast<int>(bufferSetupResult.error())));
        return bufferSetupResult;
    }

    // 2. Create and initialize IsochPortChannelManager (unchanged)
    portChannelManager_ = std::make_unique<IsochPortChannelManager>(logger_, interface, runLoopRef_, false); // false=listener
    auto initPortResult = portChannelManager_->initialize();
     if (!initPortResult) {
         if (logger_) logger_->error("Failed to initialize PortChannelManager: {}", iokit_error_category().message(static_cast<int>(initPortResult.error())));
        return initPortResult;
    }

    // 3. Create IsochDCLManager (using new config)
    IOFireWireLibNuDCLPoolRef nuDCLPool = portChannelManager_->getNuDCLPool();
     if (!nuDCLPool) {
        if (logger_) logger_->error("Failed to get NuDCLPool");
        portChannelManager_->reset();
        return std::unexpected(IOKitError::NotReady);
    }
    IsochDCLManager::Config dclConfig = {
        .numGroups = config_.numGroups,
        .packetsPerGroup = config_.packetsPerGroup,
        .callbackGroupInterval = config_.callbackGroupInterval
    };
    // Pass const ref to bufferManager
    dclManager_ = std::make_unique<IsochDCLManager>(logger_, nuDCLPool, *bufferManager_, dclConfig);

    // 4. Set up DCL callbacks on the DCL Manager (unchanged)
    dclManager_->setDCLCompleteCallback(AmdtpReceiver::handleDCLComplete, this);
    dclManager_->setDCLOverrunCallback(AmdtpReceiver::handleDCLOverrun, this);

    // 5. Create DCL program structure via DCL Manager (unchanged interface)
    auto createDCLResult = dclManager_->createDCLProgram();
     if (!createDCLResult) {
         if (logger_) logger_->error("Failed to create DCL program: {}", iokit_error_category().message(static_cast<int>(createDCLResult.error())));
        portChannelManager_->reset();
        return std::unexpected(createDCLResult.error());
    }
    DCLCommand* dclProgramHandle = createDCLResult.value();

    // 6. Finish Port/Channel setup (unchanged)
    auto setupChannelResult = portChannelManager_->setupLocalPortAndChannel(
        dclProgramHandle,
        bufferManager_->getBufferRange()); // Still pass the full range
     if (!setupChannelResult) {
         if (logger_) logger_->error("Failed to set up Local Port/Channel: {}", iokit_error_category().message(static_cast<int>(setupChannelResult.error())));
        dclManager_->reset();
        portChannelManager_->reset();
        return setupChannelResult;
    }

    // 7. Create IsochTransportManager (unchanged)
    transportManager_ = std::make_unique<IsochTransportManager>(logger_);
    transportManager_->setFinalizeCallback(handleTransportFinalize, this);

    // 8. Create IsochPacketProcessor (updated to use new callback)
    packetProcessor_ = std::make_unique<IsochPacketProcessor>(logger_);
    packetProcessor_->setProcessedDataCallback(AmdtpReceiver::handleProcessedDataStatic, this);
    packetProcessor_->setOverrunCallback(handleDCLOverrun, this);

    // --- Instantiate PLL and Ring Buffer ---
    pll_ = std::make_unique<AudioClockPLL>(logger_);

    // Configure Ring Buffer Size (Example: ~200ms at 48kHz Stereo Float)
    const size_t frameSize = sizeof(ProcessedAudioFrame); // float L, float R, uint64_t ts
    const size_t desiredLatencyMs = 200;
    const size_t sampleRate = 48000; // TODO: Get actual rate from config/FDF later
    const size_t framesForLatency = (sampleRate * desiredLatencyMs) / 1000;
    // Calculate power-of-two size, ensure it's large enough for buffer + safety margin
    const size_t ringBufferSize = framesForLatency * frameSize * 2;
    appRingBuffer_ = std::make_unique<raul::RingBuffer>(ringBufferSize, logger_);
    if (!appRingBuffer_) {
         if (logger_) logger_->error("Failed to create application ring buffer");
         return std::unexpected(IOKitError::NoMemory);
    }
     if (logger_) logger_->info("Application Ring Buffer created with size: {} bytes (for {} frames)",
                              ringBufferSize, ringBufferSize / frameSize);
    // --- End Instantiation ---

    // 9. Create IsochMonitoringManager (unchanged)
    monitoringManager_ = std::make_unique<IsochMonitoringManager>(logger_, runLoopRef_);

    // Attempt initial PLL synchronization
    auto syncResult = synchronizeAndInitializePLL();
    if (!syncResult) {
        // Log warning, but don't fail the whole setup
        // PLL can potentially initialize later when first timestamp arrives
        if (logger_) logger_->warn("Initial PLL synchronization failed: {}",
            iokit_error_category().message(static_cast<int>(syncResult.error())));
    } else {
        if (logger_) logger_->info("Initial PLL synchronization successful");
    }

    if (logger_) logger_->info("AmdtpReceiver::setupComponents: Components set up successfully");
    return {};
}

// ... configure() remains similar, passes speed/channel to portChannelManager_ ...

std::expected<void, IOKitError> AmdtpReceiver::startReceive() {
     // ... (initial checks) ...
     if (!initialized_) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Not initialized");
        return std::unexpected(IOKitError::NotReady);
    }
    if (running_) {
        if (logger_) logger_->warn("AmdtpReceiver::startReceive: Already running");
        return {}; // Not an error
    }
     if (!dclManager_ || !portChannelManager_ || !transportManager_) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Required components not available");
        return std::unexpected(IOKitError::NotReady);
    }

    // Fix DCL jump targets via DCLManager, passing the Local Port
    IOFireWireLibLocalIsochPortRef localPort = portChannelManager_->getLocalPort();
     if (!localPort) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Failed to get Local Port");
        return std::unexpected(IOKitError::NotReady);
    }
    auto fixupResult = dclManager_->fixupDCLJumpTargets(localPort);
     if (!fixupResult) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Failed to fix up DCL jump targets: {}", 
            iokit_error_category().message(static_cast<int>(fixupResult.error())));
        return fixupResult;
    }

    // Start transport via Transport Manager, passing the Isoch Channel
    IOFireWireLibIsochChannelRef channelRef = portChannelManager_->getIsochChannel();
      if (!channelRef) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Failed to get Isoch Channel");
        return std::unexpected(IOKitError::NotReady);
    }
    auto result = transportManager_->start(channelRef);
     if (!result) {
        if (logger_) logger_->error("AmdtpReceiver::startReceive: Failed to start transport: {}", 
            iokit_error_category().message(static_cast<int>(result.error())));
        return result;
    }

    // Start monitoring if configured
    if (monitoringManager_ && noDataCallback_ && config_.timeout > 0) {
        monitoringManager_->startMonitoring(config_.timeout);
    }

    running_ = true;
    if (logger_) logger_->info("AmdtpReceiver::startReceive: Started receiving (Kernel Style)");
    return {};
}

std::expected<void, IOKitError> AmdtpReceiver::stopReceive() {
    if (!initialized_) {
        if (logger_) { logger_->error("AmdtpReceiver::stopReceive: Not initialized"); }
        return std::unexpected(IOKitError::NotReady);
    }
    if (!running_) {
        if (logger_) { logger_->debug("AmdtpReceiver::stopReceive: Not running"); }
        return {};
    }
    // Check required managers
    if (!transportManager_ || !portChannelManager_) {
        if (logger_) { logger_->error("AmdtpReceiver::stopReceive: Required components not available"); }
        return std::unexpected(IOKitError::NotReady);
    }

    // Stop monitoring
    if (monitoringManager_) {
        monitoringManager_->stopMonitoring();
    }

    // Get the channel from PortChannelManager
    IOFireWireLibIsochChannelRef channelRef = portChannelManager_->getIsochChannel();
    if (!channelRef) {
        if (logger_) { logger_->error("AmdtpReceiver::stopReceive: Failed to get Isoch Channel"); }
        return std::unexpected(IOKitError::NotReady);
    }

    // Stop using TransportManager
    auto result = transportManager_->stop(channelRef);
    if (!result) {
        if (logger_) { 
            logger_->error("AmdtpReceiver::stopReceive: Failed to stop transport: {}", 
                          iokit_error_category().message(static_cast<int>(result.error()))); 
        }
        return result;
    }

    running_ = false;
    if (logger_) { logger_->info("AmdtpReceiver::stopReceive: Stopped receiving"); }
    return {};
}

std::expected<void, IOKitError> AmdtpReceiver::configure(IOFWSpeed speed, uint32_t channel) {
    if (!initialized_) {
        if (logger_) { logger_->error("AmdtpReceiver::configure: Not initialized"); }
        return std::unexpected(IOKitError::NotReady);
    }
    if (running_) {
        if (logger_) { logger_->error("AmdtpReceiver::configure: Cannot configure while running"); }
        return std::unexpected(IOKitError::Busy);
    }
    
    if (!portChannelManager_) {
        if (logger_) { logger_->error("AmdtpReceiver::configure: PortChannelManager not available"); }
        return std::unexpected(IOKitError::NotReady);
    }

    auto result = portChannelManager_->configure(speed, channel);
    if (!result) {
        if (logger_) {
            logger_->error("AmdtpReceiver::configure: Configuration failed: {}",
                         iokit_error_category().message(static_cast<int>(result.error())));
        }
        return result;
    }

    if (logger_) {
        logger_->info("AmdtpReceiver::configure: Configured with speed={}, channel={}",
                     static_cast<int>(speed), channel);
    }
    return {};
}

// REMOVE old setPacketCallback method
// void AmdtpReceiver::setPacketCallback(PacketCallback callback, void* refCon) { ... }

// ADD new setProcessedDataCallback method
void AmdtpReceiver::setProcessedDataCallback(ProcessedDataCallback callback, void* refCon) {
     if (!packetProcessor_) {
        if (logger_) logger_->error("AmdtpReceiver::setProcessedDataCallback: PacketProcessor not available");
        return;
    }
    // Store client's callback info
    processedDataCallback_ = callback;
    processedDataCallbackRefCon_ = refCon;

    // Note: The callback on the processor is already set during setupComponents
    // and points to our static handler with 'this' as refCon.
    // We store the client's callback here to be called by our handler.

    if (logger_) logger_->debug("AmdtpReceiver::setProcessedDataCallback: Stored client callback={:p}, refCon={:p}",
                     (void*)callback, refCon);
}

void AmdtpReceiver::setMessageCallback(MessageCallback callback, void* refCon) {
    messageCallback_ = callback;
    messageCallbackRefCon_ = refCon;
    
    if (logger_) {
        logger_->debug("AmdtpReceiver::setMessageCallback: Set callback={:p}, refCon={:p}",
                     (void*)callback, refCon);
    }
}

void AmdtpReceiver::setStructuredCallback(StructuredDataCallback callback, void* refCon) {
    structuredCallback_ = callback;
    structuredCallbackRefCon_ = refCon;
    
    // Create a CallbackData record for forwarding properly
    auto callbackData = std::make_unique<CallbackData>();
    callbackData->receiver = this;
    callbackData->clientRefCon = refCon;
    callbackDataStore_.push_back(std::move(callbackData));
    
    if (logger_) {
        logger_->debug("AmdtpReceiver::setStructuredCallback: Set callback={:p}, refCon={:p}",
                     (void*)callback, refCon);
    }
}

void AmdtpReceiver::setNoDataCallback(NoDataCallback callback, void* refCon, 
                                      uint32_t timeout, bool cipOnlyMode) {
    noDataCallback_ = callback;
    noDataCallbackRefCon_ = refCon;
    
    // Create a CallbackData record for forwarding properly
    auto callbackData = std::make_unique<CallbackData>();
    callbackData->receiver = this;
    callbackData->clientRefCon = refCon;
    callbackDataStore_.push_back(std::move(callbackData));
    
    // Configure the monitoring manager with the callback
    if (monitoringManager_ && callback) {
        config_.timeout = timeout; // Store in config for potential restarts
        monitoringManager_->setNoDataCallback(
            &AmdtpReceiver::handleNoDataCallback,
            callbackDataStore_.back().get()
        );
        
        if (running_) {
            // If we're already running, start monitoring now
            monitoringManager_->startMonitoring(timeout);
        }
    }
    
    if (logger_) {
        logger_->debug("AmdtpReceiver::setNoDataCallback: Set callback={:p}, refCon={:p}, timeout={}ms, cipOnly={}",
                     (void*)callback, refCon, timeout, cipOnlyMode);
    }
}

void AmdtpReceiver::setGroupCompletionCallback(GroupCompletionCallback callback, void* refCon) {
    groupCompletionCallback_ = callback;
    groupCompletionRefCon_ = refCon;
    
    if (logger_) {
        logger_->debug("AmdtpReceiver::setGroupCompletionCallback: Set callback={:p}, refCon={:p}",
                    (void*)callback, refCon);
    }
}

// --- Implement New Handlers ---

// Static handler called by IsochPacketProcessor
void AmdtpReceiver::handleProcessedDataStatic(const std::vector<ProcessedSample>& samples,
                                             const PacketTimingInfo& timing,
                                             void* refCon) {
    auto receiver = static_cast<AmdtpReceiver*>(refCon);
    if (receiver) {
        receiver->handleProcessedData(samples, timing);
    }
}

// Instance method doing the work for Phase 2 (PLL/RingBuffer)
void AmdtpReceiver::handleProcessedData(const std::vector<ProcessedSample>& samples,
                                       const PacketTimingInfo& timing) {

    if (!pll_ || !appRingBuffer_) {
        if (logger_) logger_->error("handleProcessedData called before PLL/RingBuffer initialization!");
        return;
    }

    // Get current host time *once* in absolute units
    uint64_t nowHostTimeAbs = mach_absolute_time();

    // Update the PLL state. It will internally handle initialization check.
    pll_->update(timing, nowHostTimeAbs); // Pass absolute time

    // --- Write processed samples to the application ring buffer ---
    if (!samples.empty()) {
        // Only proceed if PLL is initialized and ready to provide timestamps
        if (pll_->isInitialized()) {
            if (logger_) logger_->trace("Writing {} samples to App Ring Buffer. First AbsIdx: {}", samples.size(), samples[0].absoluteSampleIndex);

            ProcessedAudioFrame frame; // Reuse frame struct
            for (const auto& sample : samples) {
                // Calculate presentation time using the PLL
                // This now happens *inside* the loop for potentially better accuracy per frame
                frame.presentationNanos = pll_->getPresentationTimeNs(sample.absoluteSampleIndex);

                // Check for valid timestamp (e.g., PLL might return 0 if it can't estimate yet)
                if (frame.presentationNanos == 0) {
                     if (logger_) logger_->warn("PLL returned 0 presentation time for sample index {}, skipping frame.", sample.absoluteSampleIndex);
                     continue; // Skip writing this frame
                }

                // Assemble the rest of the frame
                frame.sampleL = sample.sampleL;
                frame.sampleR = sample.sampleR;

                // Write frame to appRingBuffer_
                size_t written = appRingBuffer_->write(sizeof(frame), &frame);
                if (written != sizeof(frame)) {
                     if (logger_) logger_->error("Failed to write complete frame (AbsIdx {}) to ring buffer! Buffer full?", sample.absoluteSampleIndex);
                     // Handle ring buffer full - break is reasonable for now
                     break;
                }
            }
             if (logger_ && !samples.empty()) logger_->trace("Finished writing samples. Last AbsIdx: {}", samples.back().absoluteSampleIndex);

        } else {
            // PLL not ready, drop samples for this packet
             if (logger_) logger_->warn("PLL not initialized, dropping {} samples for packet with FW TS {}", samples.size(), timing.fwTimestamp);
        }
    } else if (timing.numSamplesInPacket == 0 && timing.fdf != 0xFF) {
        // Handle case where processor signaled discontinuity via empty vector
         if (logger_) logger_->warn("handleProcessedData received empty sample vector (DBC discontinuity?). FW TS: {}, SYT: {:#06x}, DBC: {}",
                      timing.fwTimestamp, timing.syt, timing.firstDBC);
    }

    // --- Client Callback (DEPRECATE / REMOVE LATER) ---
    // This should eventually be removed. The client (ASP via XPC)
    // will read directly from the ring buffer.
     if (processedDataCallback_) {
         // Pass empty vector if samples were dropped due to PLL init state?
         // Or pass original samples? Let's pass original for now.
         processedDataCallback_(samples, timing, processedDataCallbackRefCon_);
     }
     // --- End Client Callback ---
}

void AmdtpReceiver::handleBufferGroupComplete(uint32_t groupIndex) {
    if (!running_) return;
    if (!bufferManager_ || !packetProcessor_) {
        if (logger_) logger_->error("handleBufferGroupComplete: Required components missing");
        notifyMessage(static_cast<uint32_t>(ReceiverMessage::BufferError));
        return;
    }

    // Log which group completed
    // logger_->info("*** PROCESSING GROUP {} ***", groupIndex);

    const uint32_t packetsInGroup = bufferManager_->getPacketsPerGroup();
    const size_t expectedTotalPacketSize = bufferManager_->getTotalPacketSize(); // Get expected total packet size

    // Process all packets within this completed group
    for (uint32_t packetIdx = 0; packetIdx < packetsInGroup && running_; ++packetIdx) {
        // --- Get Raw Packet Pointer and Log Raw Data ---
        auto rawPacketPtrExp = bufferManager_->getRawPacketSlotPtr(groupIndex, packetIdx);
        auto tsPtrExp = bufferManager_->getPacketTimestampPtr(groupIndex, packetIdx);

        if (!rawPacketPtrExp || !tsPtrExp) {
            logger_->error("Failed to get raw pointers for G:{} P:{}", groupIndex, packetIdx);
            continue;
        }

        uint8_t* rawPacketPtr = rawPacketPtrExp.value();
        uint32_t timestamp = *tsPtrExp.value(); // Get timestamp

        // Determine how much data to dump (avoid reading past buffer end if possible)
        size_t dumpSize = std::min((size_t)80, expectedTotalPacketSize); // Dump up to 80 bytes or expected size

        std::vector<uint8_t> raw_packet_bytes(dumpSize);
        std::memcpy(raw_packet_bytes.data(), rawPacketPtr, dumpSize);

//        logger_->debug("Raw Packet G:{} P:{} @ {:p} (Expected Size: {}):",
//                      groupIndex, packetIdx, (void*)rawPacketPtr, expectedTotalPacketSize);
//        logger_->debug("  Hex Dump ({} bytes): {}", dumpSize, spdlog::to_hex(raw_packet_bytes));
//        // --- End Raw Logging ---

        // --- Now, get the separated pointers as before for processing ---
        auto isochHdrPtrExp = bufferManager_->getPacketIsochHeaderPtr(groupIndex, packetIdx);
        auto cipHdrPtrExp = bufferManager_->getPacketCIPHeaderPtr(groupIndex, packetIdx);
        auto dataPtrExp = bufferManager_->getPacketDataPtr(groupIndex, packetIdx);

        if (!isochHdrPtrExp || !cipHdrPtrExp || !dataPtrExp) {
            logger_->error("Failed to get separated pointers for G:{} P:{}", groupIndex, packetIdx);
            notifyMessage(static_cast<uint32_t>(ReceiverMessage::BufferError));
            continue; // Skip this packet
        }

        // Extract pointers after validation
        auto isochHdrPtr = isochHdrPtrExp.value();
        auto cipHdrPtr = cipHdrPtrExp.value();
        auto dataPtr = dataPtrExp.value();
        uint32_t dataSize = bufferManager_->getPacketDataSize();

        // Process packet with the separated data
        auto procResult = packetProcessor_->processPacket(
            groupIndex, packetIdx,
            isochHdrPtr, 
            cipHdrPtr,
            dataPtr, 
            dataSize,
            timestamp);

        if (!procResult) {
            logger_->error("Failed to process packet G:{} P:{}: {}", 
                         groupIndex, packetIdx, 
                         static_cast<int>(procResult.error()));
            notifyMessage(static_cast<uint32_t>(ReceiverMessage::PacketError));
        }
    }

    // Reset the no-data timer after processing the group
    if (monitoringManager_) {
        monitoringManager_->resetTimer();
        monitoringManager_->updateLastCycle(groupIndex); // Use groupIndex as a proxy for 'cycle'
    }

    // Call group completion callback if registered
    if (groupCompletionCallback_) {
        // Get timestamp for the first packet in group as representative timestamp
        auto tsPtrExp = bufferManager_->getPacketTimestampPtr(groupIndex, 0);
        uint32_t timestamp = tsPtrExp ? *tsPtrExp.value() : 0;
        
        groupCompletionCallback_(groupIndex, timestamp, groupCompletionRefCon_);
    }

    // logger_->info("*** COMPLETED GROUP {} ***", groupIndex);
}

// --- Static Callbacks ---
void AmdtpReceiver::handleDCLComplete(uint32_t groupIndex, void* refCon) {
    // refCon is AmdtpReceiver*
    auto receiver = static_cast<AmdtpReceiver*>(refCon);
    if (receiver) {
        // Call the new instance method
        receiver->handleBufferGroupComplete(groupIndex);
    }
}

void AmdtpReceiver::handleDCLOverrun(void* refCon) {
    auto receiver = static_cast<AmdtpReceiver*>(refCon);
    if (receiver) {
        receiver->handleOverrun();
    }
}

void AmdtpReceiver::handleTransportFinalize(void* refCon) {
    auto receiver = static_cast<AmdtpReceiver*>(refCon);
    if (receiver) {
        // Handle transport finalization
        receiver->notifyMessage(0, 0, 0); // Could use a specific message code
    }
}

void AmdtpReceiver::handleOverrun() {
    if (!running_) {
        return;
    }
    
    // Attempt to recover from the overrun
    auto result = handleOverrunRecovery();
    if (!result) {
        logger_->error("AmdtpReceiver::handleOverrun: Failed to recover from overrun: {}", 
                     static_cast<int>(result.error()));
        
        // If recovery failed, notify the client and stop
        notifyMessage(static_cast<uint32_t>(ReceiverMessage::OverrunError));
        stopReceive();
    }
}

std::expected<void, IOKitError> AmdtpReceiver::handleOverrunRecovery() {
    if (!running_) { return {}; }

    if (logger_) { logger_->warn("AmdtpReceiver::handleOverrunRecovery: Attempting recovery"); }

    // Notify client
    notifyMessage(static_cast<uint32_t>(ReceiverMessage::OverrunError));

    // Get channel from PortChannelManager
    auto channelRef = portChannelManager_->getIsochChannel();
    if (!channelRef) {
        logger_->error("AmdtpReceiver::handleOverrunRecovery: No active channel");
        return std::unexpected(IOKitError::NotReady);
    }

    // Stop the channel 
    IOReturn io_result = (*channelRef)->Stop(channelRef);
    if (io_result != kIOReturnSuccess) {
        logger_->error("AmdtpReceiver::handleOverrunRecovery: Failed to stop channel: 0x{:08X}", io_result);
    }

    // Release the channel
    (*channelRef)->ReleaseChannel(channelRef);

    // Fix up DCL jump targets
    IOFireWireLibLocalIsochPortRef localPort = portChannelManager_->getLocalPort();
    if (!localPort) {
        if (logger_) { logger_->error("AmdtpReceiver::handleOverrunRecovery: Failed to get Local Port for fixup"); }
        running_ = false; 
        return std::unexpected(IOKitError::NotReady);
    }
    auto fixupResult = dclManager_->fixupDCLJumpTargets(localPort);
    if (!fixupResult) {
        logger_->error("AmdtpReceiver::handleOverrunRecovery: Failed to fix up DCL jump targets: {}",
                    iokit_error_category().message(static_cast<int>(fixupResult.error())));
        running_ = false; 
        return fixupResult;
    }

    // Re-allocate the channel
    io_result = (*channelRef)->AllocateChannel(channelRef);
    if (io_result != kIOReturnSuccess) {
        logger_->error("AmdtpReceiver::handleOverrunRecovery: Failed to reallocate channel: 0x{:08X}", io_result);
        running_ = false;
        return std::unexpected(IOKitError(io_result));
    }

    // Re-start the channel
    io_result = (*channelRef)->Start(channelRef);
    if (io_result != kIOReturnSuccess) {
        logger_->error("AmdtpReceiver::handleOverrunRecovery: Failed to restart channel: 0x{:08X}", io_result);
        (*channelRef)->ReleaseChannel(channelRef);
        running_ = false;
        return std::unexpected(IOKitError(io_result));
    }

    // Reset monitor timer
    if (monitoringManager_) {
        monitoringManager_->resetTimer();
    }

    logger_->info("AmdtpReceiver::handleOverrunRecovery: Successfully recovered");
    return {};
}

void AmdtpReceiver::notifyMessage(uint32_t msg, uint32_t param1, uint32_t param2) {
    if (messageCallback_) {
        messageCallback_(msg, param1, param2, messageCallbackRefCon_);
    }
}

void AmdtpReceiver::handleStructuredCallback(const ReceivedCycleData& data, void* refCon) {
    auto* callbackData = static_cast<CallbackData*>(refCon);
    if (callbackData && callbackData->receiver && callbackData->receiver->structuredCallback_) {
        ReceivedCycleData modifiedData = data;
        modifiedData.refCon = callbackData->clientRefCon;
        callbackData->receiver->structuredCallback_(modifiedData, callbackData->clientRefCon);
    }
}

void AmdtpReceiver::handleNoDataCallback(uint32_t lastCycle, void* refCon) {
    auto* callbackData = static_cast<CallbackData*>(refCon);
    if (callbackData && callbackData->receiver && callbackData->receiver->noDataCallback_) {
        callbackData->receiver->noDataCallback_(lastCycle, callbackData->clientRefCon);
    }
}

std::expected<void, IOKitError> AmdtpReceiver::synchronizeAndInitializePLL() {
    if (!portChannelManager_ || !pll_) {
        if (logger_) logger_->error("AmdtpReceiver::synchronizeAndInitializePLL: Required components missing");
        return std::unexpected(IOKitError::NotReady);
    }

    IOFireWireLibNubRef nubInterface = portChannelManager_->getNubInterface();
    if (!nubInterface) {
        if (logger_) logger_->error("AmdtpReceiver::synchronizeAndInitializePLL: Failed to get nub interface");
        return std::unexpected(IOKitError::NotReady);
    }

    UInt32 fwCycleTime = 0;
    UInt64 hostUptimeAbs = 0; // Get host time in absolute units

    // Use the direct correlation method to get synchronized timestamps
    IOReturn result = (*nubInterface)->GetCycleTimeAndUpTime(nubInterface, &fwCycleTime, &hostUptimeAbs);

    if (result != kIOReturnSuccess) {
        if (logger_) logger_->error("AmdtpReceiver::synchronizeAndInitializePLL: Failed to get CycleTime and UpTime: 0x{:08X}", result);
        return std::unexpected(IOKitError(result));
    }

    if (logger_) logger_->info("PLL Sync Point: FW CycleTime={:#010x}, Host UptimeAbs={}", 
                             fwCycleTime, hostUptimeAbs);

    // Initialize the PLL with this correlation point (absolute time)
    pll_->initialize(hostUptimeAbs, fwCycleTime);

    return {};
}

raul::RingBuffer* AmdtpReceiver::getAppRingBuffer() const {
    return appRingBuffer_.get(); // Simply return the raw pointer from unique_ptr
}


} // namespace Isoch
} // namespace FWA






=== src/Isoch/core/AmdtpTransmitter.cpp ===
#include "Isoch/core/AmdtpTransmitter.hpp"
#include "Isoch/core/IsochTransmitBufferManager.hpp"
#include "Isoch/core/IsochPortChannelManager.hpp"
#include "Isoch/core/IsochTransmitDCLManager.hpp"
#include "Isoch/core/IsochTransportManager.hpp"
#include "Isoch/core/IsochPacketProvider.hpp"
#include <mach/mach_time.h> // For mach_absolute_time
#include <CoreServices/CoreServices.h> // For endian swap
#include <vector>
#include <chrono> // For timing/sleep (optional)

namespace FWA {
namespace Isoch {

// --- Factory Method ---
std::shared_ptr<AmdtpTransmitter> AmdtpTransmitter::create(const TransmitterConfig& config) {
    // Using make_shared with a helper struct to handle enable_shared_from_this properly
    struct MakeSharedEnabler : public AmdtpTransmitter {
        MakeSharedEnabler(const TransmitterConfig& cfg) : AmdtpTransmitter(cfg) {}
    };
    return std::make_shared<MakeSharedEnabler>(config);
}


ITransmitPacketProvider* AmdtpTransmitter::getPacketProvider() const {
    return packetProvider_.get(); // Return raw pointer from unique_ptr
}

std::expected<void, IOKitError> AmdtpTransmitter::startTransmit() {
    // Temporary storage for callback info
    MessageCallback callback_to_notify = nullptr;
    void* refcon_to_notify = nullptr;
    IOKitError error_code = IOKitError::Success; // Use a status variable
    
    { // --- Start Scope for stateMutex_ ---
        std::lock_guard<std::mutex> lock(stateMutex_);
        if (!initialized_) {
            logger_->error("startTransmit: Not initialized.");
            return std::unexpected(IOKitError::NotReady);
        }
        if (running_) {
            logger_->warn("startTransmit: Already running.");
            return {}; // Not an error
        }
        if (!portChannelManager_ || !dclManager_ || !transportManager_ || !packetProvider_ || !bufferManager_) {
            logger_->error("startTransmit: Required components not available.");
            return std::unexpected(IOKitError::NotReady);
        }

        logger_->info("AmdtpTransmitter starting transmit...");

        // --- 1. Reset State ---
        initializeCIPState(); // Reset DBC, SYT state, first callback flag etc.

        // --- 2. Initial DCL Memory Preparation Loop ---
        // Pre-fill the *memory* associated with *all* DCLs with initial safe values
        logger_->debug("Performing initial memory preparation for DCL ring...");
        uint32_t totalPacketsToPrep = config_.numGroups * config_.packetsPerGroup;

        for (uint32_t absPktIdx = 0; absPktIdx < totalPacketsToPrep; ++absPktIdx) {
            uint32_t g = absPktIdx / config_.packetsPerGroup;
            uint32_t p = absPktIdx % config_.packetsPerGroup;

            // --- 2a. Get Buffer Pointers ---
            auto cipHdrPtrExp = bufferManager_->getPacketCIPHeaderPtr(g, p);
            uint8_t* audioDataTargetPtr = nullptr;
            if(bufferManager_->getClientAudioBufferPtr() && bufferManager_->getClientAudioBufferSize() > 0) {
               audioDataTargetPtr = bufferManager_->getClientAudioBufferPtr()
                               + (absPktIdx * bufferManager_->getAudioPayloadSizePerPacket()) % bufferManager_->getClientAudioBufferSize();
            }
            auto isochHdrPtrExp = bufferManager_->getPacketIsochHeaderPtr(g, p); // For template update

            if (!cipHdrPtrExp || !audioDataTargetPtr || !isochHdrPtrExp) {
                logger_->error("startTransmit: Failed to get buffer pointers for initial prep G={}, P={}", g, p);
                // Don't start if buffers aren't right
                error_code = IOKitError::InternalError;
                // Go to end of locked scope
                break;
            }
            CIPHeader* cipHdrTarget = reinterpret_cast<CIPHeader*>(cipHdrPtrExp.value());
            size_t audioPayloadTargetSize = bufferManager_->getAudioPayloadSizePerPacket();
            IsochHeaderData* isochHdrTarget = reinterpret_cast<IsochHeaderData*>(isochHdrPtrExp.value());

            // --- 2b. Fill Audio Payload (Initial Silence) ---
            // Ask provider to fill - it should generate silence if its buffer is empty.
            TransmitPacketInfo dummyInfo = { .segmentIndex = g, .packetIndexInGroup = p, .absolutePacketIndex = absPktIdx };
            PreparedPacketData packetDataStatus = packetProvider_->fillPacketData(
                audioDataTargetPtr,
                audioPayloadTargetSize,
                dummyInfo
            );

            // --- 2c. Prepare CIP Header (Initial State) ---
            prepareCIPHeader(cipHdrTarget);

            // --- 2d. Prepare Isoch Header Template ---
            // Set the channel, tag, tcode in the template memory
            uint8_t fwChannel = portChannelManager_->getActiveChannel().value_or(config_.initialChannel & 0x3F);
            // Calculate expected data_length (CIP + Payload, even if payload is silence for now)
            uint16_t dataLength = kTransmitCIPHeaderSize + audioPayloadTargetSize;
            isochHdrTarget->data_length = OSSwapHostToBigInt16(dataLength); // HW might overwrite if ranges differ
            isochHdrTarget->tag_channel = (1 << 6) | (fwChannel & 0x3F); // Tag=1
            isochHdrTarget->tcode_sy = (0xA << 4) | 0; // TCode=A, Sy=0
        } // End initial prep loop
        
        // Check for error from the loop
        if (error_code != IOKitError::Success) {
            return std::unexpected(error_code);
        }
        
        logger_->debug("Initial memory preparation complete.");

        // --- 3. Fixup DCL Jumps ---
        // Link the last DCL back to the first one and notify the port.
        auto localPort = portChannelManager_->getLocalPort();
        if (!localPort) {
            logger_->error("startTransmit: Cannot get local port for DCL fixup.");
            error_code = IOKitError::NotReady; // Store error
            // Go to end of locked scope
        } else {
            auto dclFixupResult = dclManager_->fixupDCLJumpTargets(localPort);
            if (!dclFixupResult) {
                logger_->error("startTransmit: Failed to fix up DCL jump targets: {}",
                              iokit_error_category().message(static_cast<int>(dclFixupResult.error())));
                error_code = dclFixupResult.error(); // Store error
                // Go to end of locked scope
            }
        }

        // --- 4. Start Transport (only if no error so far) ---
        if (error_code == IOKitError::Success) {
            auto channel = portChannelManager_->getIsochChannel();
            if (!channel) {
                logger_->error("startTransmit: Cannot get isoch channel to start transport.");
                error_code = IOKitError::NotReady; // Store error
            } else {
                auto startResult = transportManager_->start(channel);
                if (!startResult) {
                    logger_->error("startTransmit: Failed to start transport manager: {}",
                                 iokit_error_category().message(static_cast<int>(startResult.error())));
                    error_code = startResult.error(); // Store error
                }
            }
        }

        // --- 5. Update State (only if no error so far) ---
        if (error_code == IOKitError::Success) {
            running_ = true;
            firstDCLCallbackOccurred_ = false; // Reset for timing measurements
            logger_->info("AmdtpTransmitter transmit started successfully.");

            // -- Read callback info while lock is held --
            callback_to_notify = messageCallback_;
            refcon_to_notify = messageCallbackRefCon_;
            // -----------------------------------------
        }
        
    } // --- End Scope for stateMutex_ --- lock is released here

    // --- Handle return/notification outside the lock ---
    if (error_code != IOKitError::Success) {
        // An error occurred during setup
        return std::unexpected(error_code);
    }

    // Call the callback directly after releasing the lock
    if (callback_to_notify) {
        callback_to_notify(static_cast<uint32_t>(TransmitterMessage::StreamStarted), 0, 0, refcon_to_notify);
    }

    return {}; // Success
}

// --- IMPLEMENT stopTransmit ---
std::expected<void, IOKitError> AmdtpTransmitter::stopTransmit() {
    std::lock_guard<std::mutex> lock(stateMutex_); // Ensure exclusive access
    if (!initialized_) {
        return {}; // Nothing to do
    }
    if (!running_) {
        return {}; // Already stopped
    }

    logger_->info("AmdtpTransmitter stopping transmit...");
    running_ = false; // Signal handlers/callbacks to stop processing ASAP

    // Check required components for cleanup
    if (!portChannelManager_ || !transportManager_) {
        logger_->error("stopTransmit: PortChannelManager or TransportManager missing. Cannot stop cleanly.");
        // Setting running_ to false might prevent some crashes.
        return std::unexpected(IOKitError::NotReady);
    }

    // Get the channel to stop transport
    auto channel = portChannelManager_->getIsochChannel();
    if (!channel) {
        logger_->error("stopTransmit: Cannot get IsochChannel to stop transport.");
        running_ = true; // Revert state if we can't proceed
        return std::unexpected(IOKitError::NotReady);
    }

    // Stop the transport manager
    auto stopResult = transportManager_->stop(channel);
    
    logger_->info("AmdtpTransmitter transmit stopped.");
    notifyMessage(TransmitterMessage::StreamStopped); // Notify client

    if (!stopResult) {
        logger_->error("stopTransmit: TransportManager failed to stop cleanly: {}. State set to stopped, but resources might leak.",
                     iokit_error_category().message(static_cast<int>(stopResult.error())));
        // Return the error from stop so caller knows it wasn't clean
        return std::unexpected(stopResult.error());
    }

    return {}; // Success
}

// --- handleDCLOverrun implementation ---
void AmdtpTransmitter::handleDCLOverrun() {
    // Running check should happen *before* this is called ideally,
    // but double check here.
    if (!running_.load()) return;

    logger_->error("AmdtpTransmitter DCL Overrun detected!");
    notifyMessage(TransmitterMessage::OverrunError);

    // Attempt to stop the transport cleanly
    logger_->warn("Attempting to stop stream due to overrun...");
    auto stopExp = stopTransmit();
    if (!stopExp) {
        logger_->error("Failed to stop stream cleanly during overrun handling: {}",
                     iokit_error_category().message(static_cast<int>(stopExp.error())));
        // At this point, state might be inconsistent.
    }
}

// --- IMPLEMENTATION OF handleDCLComplete (Instance Method) ---
// This is the core real-time loop function called from the RunLoop via the static helper
void AmdtpTransmitter::handleDCLComplete(uint32_t completedGroupIndex) {
    // --- 1. State Check ---
    // Check running state *without* lock first for performance optimisation
    if (!running_.load(std::memory_order_relaxed)) {
        // logger_->trace("handleDCLComplete: Not running, ignoring callback for group {}", completedGroupIndex);
        return;
    }

    // Get essential components (check for null - should ideally not happen if running)
    auto localPort = portChannelManager_ ? portChannelManager_->getLocalPort() : nullptr;
    if (!localPort || !dclManager_ || !bufferManager_ || !packetProvider_) {
        logger_->error("handleDCLComplete: Required manager component is missing! Stopping stream.");
        // Attempt to stop cleanly, ignoring potential errors during error handling
        auto stopExp = stopTransmit(); // This will acquire the lock if needed
        notifyMessage(TransmitterMessage::Error); // Notify client of error
        return;
    }

    // --- 2. Timing & Debug ---
    uint64_t callbackEntryTime = mach_absolute_time(); // Measure entry time
    if (!firstDCLCallbackOccurred_) {
        firstDCLCallbackOccurred_ = true;
        // Potentially record first callback time for latency estimation
        logger_->info("First DCL completion callback received for group {}", completedGroupIndex);
    }

    // Read hardware completion timestamp for the completed group
    uint32_t completionTimestamp = 0;
    auto tsExp = bufferManager_->getGroupTimestampPtr(completedGroupIndex);
    if (tsExp) {
        completionTimestamp = *tsExp.value();
        // logger_->trace("Completed Group {}: HW Timestamp = {:#010x}", completedGroupIndex, completionTimestamp);
        // TODO: Use this timestamp for PLL/rate estimation later
    } else {
         logger_->warn("Could not get completion timestamp for group {}", completedGroupIndex);
    }


    // --- 3. Determine Next Segment to Fill ---
    // We need to fill the segment that the hardware will encounter *after*
    // the currently executing segments. With a callback interval of 1,
    // when group N completes, the hardware might be starting group N+1.
    // We should prepare group N+2. If the interval is larger, adjust accordingly.
    // For simplicity and robustness (double buffering), let's prepare the group
    // immediately following the completed one in the ring.
    uint32_t fillGroupIndex = (completedGroupIndex + 1) % config_.numGroups;
    // logger_->trace("handleDCLComplete: Completed Group = {}, Preparing Group = {}", completedGroupIndex, fillGroupIndex);


    // --- 4. Prepare Next Segment Loop ---
    // Iterate through all packets within the 'fillGroupIndex' segment
    for (uint32_t p = 0; p < config_.packetsPerGroup; ++p) {
        uint32_t absolutePacketIndex = fillGroupIndex * config_.packetsPerGroup + p;

        // --- 4a. Get Buffer Pointers ---
        // Pointers to where we write the headers in DMA memory
        auto isochHdrPtrExp = bufferManager_->getPacketIsochHeaderPtr(fillGroupIndex, p);
        auto cipHdrPtrExp = bufferManager_->getPacketCIPHeaderPtr(fillGroupIndex, p);
        // Pointer to where the *provider* writes audio data in DMA memory
        uint8_t* audioDataTargetPtr = nullptr;
         if(bufferManager_->getClientAudioBufferPtr() && bufferManager_->getClientAudioBufferSize() > 0) {
            audioDataTargetPtr = bufferManager_->getClientAudioBufferPtr()
                           + (absolutePacketIndex * bufferManager_->getAudioPayloadSizePerPacket()) % bufferManager_->getClientAudioBufferSize();
         }

        if (!isochHdrPtrExp || !cipHdrPtrExp || !audioDataTargetPtr) {
            logger_->error("handleDCLComplete: Failed to get buffer pointers for G={}, P={}. Skipping packet.", fillGroupIndex, p);
            continue; // Skip this packet
        }
        
        IsochHeaderData* isochHdrTarget = reinterpret_cast<IsochHeaderData*>(isochHdrPtrExp.value());
        CIPHeader* cipHdrTarget = reinterpret_cast<CIPHeader*>(cipHdrPtrExp.value());
        size_t audioPayloadTargetSize = bufferManager_->getAudioPayloadSizePerPacket();


        // --- 4b. Prepare TransmitPacketInfo ---
        // Estimate timing for this future packet (basic estimation for now)
        // TODO: Integrate with PLL/Timing module for accurate prediction
        uint64_t estimatedHostTimeNano = 0; // Placeholder
        uint32_t estimatedFirewireTimestamp = 0; // Placeholder

        TransmitPacketInfo packetInfo = {
            .segmentIndex = fillGroupIndex,
            .packetIndexInGroup = p,
            .absolutePacketIndex = absolutePacketIndex,
            .hostTimestampNano = estimatedHostTimeNano,
            .firewireTimestamp = estimatedFirewireTimestamp
        };


        // --- 4c. Fill Audio Data ---
        // Ask provider to fill the audio data directly into the DMA buffer slot
        PreparedPacketData packetDataStatus = packetProvider_->fillPacketData(
            audioDataTargetPtr,
            audioPayloadTargetSize,
            packetInfo
        );

        // Handle Underrun Notification
        if (packetDataStatus.generatedSilence) {
            // Notify client about underrun for this specific packet
             // Throttle notification?
             // logger_->warn("handleDCLComplete: Underrun preparing G={}, P={}", fillGroupIndex, p);
            notifyMessage(TransmitterMessage::BufferUnderrun, fillGroupIndex, p);
        }


        // --- 4d. Prepare CIP Header ---
        // Generate the CIP header content (with updated DBC, SYT=0xFFFF for now)
        // and write it directly into the DMA buffer slot.
        prepareCIPHeader(cipHdrTarget); // NEW - Function now calculates isNoData internally


        // --- 4e. Update Isoch Header ---
        // Update Isoch header template with appropriate data_length, channel, etc.
        uint8_t fwChannel = portChannelManager_->getActiveChannel().value_or(config_.initialChannel & 0x3F);
        isochHdrTarget->data_length = OSSwapHostToBigInt16(kTransmitCIPHeaderSize + packetDataStatus.dataLength);
        isochHdrTarget->tag_channel = (1 << 6) | (fwChannel & 0x3F);
        isochHdrTarget->tcode_sy = (0xA << 4) | 0; // TCode=0xA (Isoch Data Block)


        // --- 4f. Update DCL Ranges (if needed) ---
        // Determine the correct number of ranges based on data availability
        IOVirtualRange ranges[2];
        uint32_t numRanges = 0;

        // Range 0: CIP Header (Always present)
        ranges[0].address = reinterpret_cast<IOVirtualAddress>(cipHdrTarget);
        ranges[0].length = kTransmitCIPHeaderSize;
        numRanges++;

        // Range 1: Audio Data (Only if data is available/not NO_DATA packet)
        if (!packetDataStatus.generatedSilence && packetDataStatus.dataLength > 0) {
             // Ensure the length matches what the provider gave, even if it generated silence (length would be targetSize)
             // But we only add the range if !generatedSilence (meaning it's real data or intended silence padding)
             // And dataLength should match audioPayloadTargetSize unless something went wrong.
            ranges[1].address = reinterpret_cast<IOVirtualAddress>(audioDataTargetPtr);
            ranges[1].length = packetDataStatus.dataLength; // Use length from provider status
            numRanges++;
        } else if (packetDataStatus.generatedSilence) {
             // It's a NO_DATA packet conceptually, but we might still need to send
             // the zeroed buffer if hardware requires fixed packet sizes.
             // OR we tell the DCL to only send the CIP header.
             // Let's assume for now we send only CIP for NO_DATA (FDF=0xFF).
             numRanges = 1; // Only send CIP header range for NO_DATA packets
             logger_->trace("handleDCLComplete: Setting numRanges=1 for NO_DATA G={}, P={}", fillGroupIndex, p);
        }

        // Update the DCL command's ranges *if* the number of ranges changed
        // (e.g., switching between NO_DATA and data)
        // TODO: Need a way to get the *current* range count from the DCL to compare.
        // For now, let's call update unconditionally, assuming SetDCLRanges handles it.
        auto updateExp = dclManager_->updateDCLPacket(fillGroupIndex, p, ranges, numRanges, nullptr);
        if (!updateExp) {
             logger_->error("handleDCLComplete: Failed to update DCL packet ranges for G={}, P={}: {}",
                           fillGroupIndex, p, iokit_error_category().message(static_cast<int>(updateExp.error())));
             // Decide how to handle this error - skip packet? stop stream?
        }

    } // --- End packet loop (p) ---


    // --- 5. Notify Hardware of Memory Updates ---
    // Tell the hardware that the *memory content* (CIP headers, audio data)
    // for the 'fillGroupIndex' has been updated and needs to be re-read before execution.
    auto notifyContentExp = dclManager_->notifySegmentUpdate(localPort, fillGroupIndex);
     if (!notifyContentExp) {
         logger_->error("handleDCLComplete: Failed to notify segment content update for G={}: {}",
                       fillGroupIndex, iokit_error_category().message(static_cast<int>(notifyContentExp.error())));
        // Handle error - might lead to hardware sending stale data.
    }

    // --- 6. No DCL Jump Target Updates Needed ---
    // We use a static circular DCL program configured during setup
    // Hardware follows the pre-defined circular path

    // --- 7. Performance Monitoring (Optional) ---
    uint64_t callbackExitTime = mach_absolute_time();
    uint64_t callbackDuration = callbackExitTime - callbackEntryTime;
    
    // Convert to milliseconds (this is a simple approximation)
    static mach_timebase_info_data_t timebase;
    if (timebase.denom == 0) {
        mach_timebase_info(&timebase);
    }
    
    uint64_t durationNanos = callbackDuration * timebase.numer / timebase.denom;
    double durationMs = static_cast<double>(durationNanos) / 1000000.0;
    
    // Log if duration exceeds threshold (e.g., 1ms for real-time audio)
    static const double kWarningThresholdMs = 1.0; // 1ms is quite strict for real-time audio
//    if (durationMs > kWarningThresholdMs) {
//        logger_->warn("handleDCLComplete: Long processing time for G={}: {:.3f}ms", 
//                     completedGroupIndex, durationMs);
//    }
}

// --- Static Callbacks ---
void AmdtpTransmitter::DCLCompleteCallback_Helper(uint32_t completedGroupIndex, void* refCon) {
    AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    if (self) self->handleDCLComplete(completedGroupIndex);
}

void AmdtpTransmitter::DCLOverrunCallback_Helper(void* refCon) {
    AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    if (self) self->handleDCLOverrun();
}

void AmdtpTransmitter::TransportFinalize_Helper(void* refCon) {
    // AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    // if (self) self->handleFinalize(); // If finalize handling is needed
}





// --- ADD THE MISSING DEFINITIONS ---

// Constructor
AmdtpTransmitter::AmdtpTransmitter(const TransmitterConfig& config)
 : config_(config), logger_(config.logger ? config.logger : spdlog::default_logger()) {
    logger_->info("AmdtpTransmitter constructing...");
    // Initialize other members if necessary
}

// Destructor
AmdtpTransmitter::~AmdtpTransmitter() {
    logger_->info("AmdtpTransmitter destructing...");
     if (running_.load()) {
        // Attempt to stop, log errors but don't throw from destructor
        auto result = stopTransmit();
        if(!result) logger_->error("stopTransmit failed during destruction");
     }
    cleanup();
}

// cleanup
void AmdtpTransmitter::cleanup() noexcept {
    logger_->debug("AmdtpTransmitter cleanup starting...");
    packetProvider_.reset();
    transportManager_.reset();
    dclManager_.reset();
    portChannelManager_.reset();
    bufferManager_.reset();
    initialized_ = false;
    running_ = false;
    logger_->debug("AmdtpTransmitter cleanup finished.");
}

// setupComponents
std::expected<void, IOKitError> AmdtpTransmitter::setupComponents(IOFireWireLibNubRef interface) {
    logger_->debug("AmdtpTransmitter::setupComponents - STUB");
    // Create instances...
     bufferManager_ = std::make_unique<IsochTransmitBufferManager>(logger_);
     portChannelManager_ = std::make_unique<IsochPortChannelManager>(logger_, interface, runLoopRef_, true /*isTalker*/);
     dclManager_ = std::make_unique<IsochTransmitDCLManager>(logger_);
     transportManager_ = std::make_unique<IsochTransportManager>(logger_);
     packetProvider_ = std::make_unique<IsochPacketProvider>(logger_, config_.clientBufferSize);

     // Initialize... (Error checking omitted for brevity in stub)
     bufferManager_->setupBuffers(config_);
     portChannelManager_->initialize();
     auto dclPool = portChannelManager_->getNuDCLPool();
     if (!dclPool) return std::unexpected(IOKitError::NotReady);
     auto dclProgResult = dclManager_->createDCLProgram(config_, dclPool, *bufferManager_);
     if (!dclProgResult) return std::unexpected(dclProgResult.error());
      DCLCommand* dclProgramHandle = dclProgResult.value();
     portChannelManager_->setupLocalPortAndChannel(dclProgramHandle, bufferManager_->getBufferRange());
     dclManager_->setDCLCompleteCallback(DCLCompleteCallback_Helper, this); // Set internal callback forwarder
     dclManager_->setDCLOverrunCallback(DCLOverrunCallback_Helper, this);

    return {};
}

// initialize
std::expected<void, IOKitError> AmdtpTransmitter::initialize(IOFireWireLibNubRef interface) {
     logger_->debug("AmdtpTransmitter::initialize");
     std::lock_guard<std::mutex> lock(stateMutex_);
     if (initialized_) return std::unexpected(IOKitError::Busy);
     if (!interface) return std::unexpected(IOKitError::BadArgument);
     runLoopRef_ = CFRunLoopGetCurrent(); // Assign runloop

     auto setupResult = setupComponents(interface); // Call setup
     if (!setupResult) {
          cleanup();
          return setupResult;
     }
     initialized_ = true;
     return {};
}

// configure
std::expected<void, IOKitError> AmdtpTransmitter::configure(IOFWSpeed speed, uint32_t channel) {
    logger_->debug("AmdtpTransmitter::configure(Speed={}, Channel={})", (int)speed, channel);
    std::lock_guard<std::mutex> lock(stateMutex_);
    if (!initialized_) return std::unexpected(IOKitError::NotReady);
    if (running_) return std::unexpected(IOKitError::Busy);
    if (!portChannelManager_) return std::unexpected(IOKitError::NotReady);
    config_.initialSpeed = speed;
    config_.initialChannel = channel;
    return portChannelManager_->configure(speed, channel);
}

// pushAudioData
bool AmdtpTransmitter::pushAudioData(const void* buffer, size_t bufferSizeInBytes) {
    // logger_->trace("AmdtpTransmitter::pushAudioData"); // Too noisy
    if (!initialized_ || !packetProvider_) return false;
    return packetProvider_->pushAudioData(buffer, bufferSizeInBytes);
}

// setMessageCallback
void AmdtpTransmitter::setMessageCallback(MessageCallback callback, void* refCon) {
    logger_->debug("AmdtpTransmitter::setMessageCallback");
    std::lock_guard<std::mutex> lock(stateMutex_);
    messageCallback_ = callback;
    messageCallbackRefCon_ = refCon;
}

// notifyMessage
void AmdtpTransmitter::notifyMessage(TransmitterMessage msg, uint32_t p1, uint32_t p2) {
     // logger_->trace("AmdtpTransmitter::notifyMessage ({})", static_cast<uint32_t>(msg));
     MessageCallback callback = nullptr;
     void* refCon = nullptr;
     {
        std::lock_guard<std::mutex> lock(stateMutex_);
        callback = messageCallback_;
        refCon = messageCallbackRefCon_;
     }
     if (callback) {
        callback(static_cast<uint32_t>(msg), p1, p2, refCon);
     }
}

// initializeCIPState
void AmdtpTransmitter::initializeCIPState() {
     logger_->debug("AmdtpTransmitter::initializeCIPState");
     dbc_count_ = 0;
     wasNoData_ = true; // Start assuming previous was NoData

     // --- Initialize SYT state ---
     // Start offset >= TICKS_PER_CYCLE to ensure first packets are NO_DATA
     // until the first callback establishes real timing.
     sytOffset_ = TICKS_PER_CYCLE; // Initialize to 3072
     sytPhase_ = 0;
     // --- End Initialize SYT state ---

     firstDCLCallbackOccurred_ = false;
     expectedTimeStampCycle_ = 0;
}

// prepareCIPHeader
void AmdtpTransmitter::prepareCIPHeader(CIPHeader* outHeader) {
    // logger_->trace("AmdtpTransmitter::prepareCIPHeader()");
    if (!outHeader || !portChannelManager_ || !bufferManager_) { /* error */ return; }

    // --- Get Node ID, SFC, Set static fields ---
    uint16_t nodeID = portChannelManager_->getLocalNodeID().value_or(0x3F); // Default to local node ID

    // --- Determine SFC from config ---
    uint8_t sfc = 0x00; // Default 32kHz
    if (config_.sampleRate == 44100.0) sfc = 0x01;      // SFC for 44.1kHz
    else if (config_.sampleRate == 48000.0) sfc = 0x02; // SFC for 48kHz
    else if (config_.sampleRate == 88200.0) sfc = 0x03; // SFC for 88.2kHz
    else if (config_.sampleRate == 96000.0) sfc = 0x04; // SFC for 96kHz
    else if (config_.sampleRate == 176400.0) sfc = 0x05; // SFC for 176.4kHz
    else if (config_.sampleRate == 192000.0) sfc = 0x06; // SFC for 192kHz
    else {
        logger_->warn("prepareCIPHeader: Unsupported sample rate {:.1f}Hz, using SFC for 48kHz.", config_.sampleRate);
        sfc = 0x02; // Fallback
    }

    // --- Set static fields ---
    outHeader->sid_byte = 0; // Assuming HW/Port sets SID correctly
    outHeader->dbs = 2;      // AM824 Stereo (8 bytes/4 = 2)
    outHeader->fn_qpc_sph_rsv = 0; // Usually 0 for AMDTP
    outHeader->fmt_eoh1 = (0x10 << 2) | 0x01; // FMT=0x10 (AM824), EOH=1

    // --- Calculate SYT and isNoData for 44.1kHz ---
    bool calculated_isNoData = false;
    uint16_t calculated_sytVal = 0xFFFF;

    if (!firstDCLCallbackOccurred_) {
        // Before first callback, timing is unknown, force NO_DATA
        calculated_isNoData = true;
        // sytOffset_ remains >= TICKS_PER_CYCLE from initialization
    } else {
        // Apply 44.1kHz SYT offset logic based on decompiled code
        if (sytOffset_ >= TICKS_PER_CYCLE) {
            // Was NO_DATA previously, or just wrapped. Reset offset within the cycle.
            sytOffset_ -= TICKS_PER_CYCLE;
        } else {
            // Normal increment logic for 44.1kHz
            uint32_t phase = sytPhase_ % SYT_PHASE_MOD;
            bool addExtra = (phase && !(phase & 3)) || (sytPhase_ == (SYT_PHASE_RESET - 1)); // Adjusted phase check
            sytOffset_ += BASE_TICKS; // Add ~1386
            if (addExtra) {
                sytOffset_ += 1; // Add occasional extra tick
            }

            // Increment and wrap phase accumulator
            if (++sytPhase_ >= SYT_PHASE_RESET) {
                sytPhase_ = 0;
            }
        }

        // Check if the *new* offset exceeds the cycle boundary
        if (sytOffset_ >= TICKS_PER_CYCLE) {
            calculated_isNoData = true; // Will send NO_DATA this time
        } else {
            calculated_isNoData = false; // Will send valid data
            calculated_sytVal = static_cast<uint16_t>(sytOffset_);
        }
    }
    // --- End SYT Calculation ---

    // --- Set Dynamic Fields (FDF, SYT, DBC) ---
    if (calculated_isNoData) {
        outHeader->fdf = 0xFF; // FDF for NO_DATA
        outHeader->syt = OSSwapHostToBigInt16(0xFFFF); // SYT for NO_DATA
        // DBC: Repeat the previous DBC value if sending NO_DATA
        outHeader->dbc = dbc_count_;
    } else {
        outHeader->fdf = sfc; // FDF for the specific sample rate
        outHeader->syt = OSSwapHostToBigInt16(calculated_sytVal); // Calculated SYT value
        // DBC: Increment only if the *previous* packet was *not* NO_DATA
        uint8_t blocksPerPacket = bufferManager_->getAudioPayloadSizePerPacket() / 8; // 64/8 = 8 blocks typically
        uint8_t increment = blocksPerPacket;
        // Use wasNoData_ (state *before* this packet)
        uint8_t next_dbc = wasNoData_ ? dbc_count_ : (dbc_count_ + increment);
        outHeader->dbc = next_dbc & 0xFF;
    }
    // --- End Set Dynamic Fields ---

    // --- Update State for *Next* Call ---
    dbc_count_ = outHeader->dbc;    // Store the DBC we *just* put in the header
    wasNoData_ = calculated_isNoData; // Store the type of packet we *just* prepared
    // Note: sytOffset_ and sytPhase_ were already updated during calculation
}

// --- Static Callback Helpers (Assumed Defined Elsewhere) ---
// void AmdtpTransmitter::DCLCompleteCallback_Helper(...) ...
// void AmdtpTransmitter::DCLOverrunCallback_Helper(...) ...
// void AmdtpTransmitter::TransportFinalize_Helper(...) ...


// --- Previously Implemented Methods ---
// std::shared_ptr<AmdtpTransmitter> AmdtpTransmitter::create(...) ...
// std::expected<void, IOKitError> AmdtpTransmitter::startTransmit() ...
// std::expected<void, IOKitError> AmdtpTransmitter::stopTransmit() ...
// void AmdtpTransmitter::handleDCLOverrun() ...
// void AmdtpTransmitter::handleDCLComplete(uint32_t completedGroupIndex) ...



} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochPacketProcessor.cpp ===
#include "Isoch/core/IsochPacketProcessor.hpp"
#include <spdlog/spdlog.h>
#include <spdlog/fmt/bin_to_hex.h>
#include <vector>
#include <cstring> // For memcpy
#include <CoreServices/CoreServices.h> // For endian conversion functions

// Define bytes per sample for clarity
constexpr size_t BYTES_PER_AM824_SAMPLE = 4;
// Define max value for 24-bit signed int normalization
constexpr float MAX_24BIT_SIGNED_FLOAT = 8388607.0f; // 2^23 - 1
    // Define common header sizes for reference
constexpr size_t kIsochHeaderSize = 4;
constexpr size_t kCIPHeaderSize = 8;

namespace FWA {
namespace Isoch {

IsochPacketProcessor::IsochPacketProcessor(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)),
      expectedDBC_(0), // Initialize expected DBC
      dbcInitialized_(false),
      currentAbsSampleIndex_(0), // Start absolute count at 0
      sampleIndexInitialized_(false),
      lastPacketNumDataBlocks_(0), // Initialize correctly
      lastPacketWasNoData_(false)  // Assume first packet is not preceded by NO_DATA
{
    if (logger_) {
        logger_->debug("IsochPacketProcessor created");
    }
}

void IsochPacketProcessor::setProcessedDataCallback(ProcessedDataCallback callback, void* refCon) {
    processedDataCallback_ = callback;
    processedDataCallbackRefCon_ = refCon;
}

void IsochPacketProcessor::setOverrunCallback(OverrunCallback callback, void* refCon) {
    overrunCallback_ = callback;
    overrunCallbackRefCon_ = refCon;
}

std::expected<void, IOKitError> IsochPacketProcessor::processPacket(
    uint32_t groupIndex,
    uint32_t packetIndexInGroup,
    const uint8_t* isochHeader,
    const uint8_t* cipHeader,
    const uint8_t* packetData,
    size_t packetDataLength,
    uint32_t fwTimestamp)
{
    if (!isochHeader || !cipHeader || !packetData) {
        return std::unexpected(IOKitError::BadArgument);
    }

    if (logger_ && logger_->should_log(spdlog::level::trace)) { // Reduce log spam slightly
        // --- Log Raw Headers ---
        std::vector<uint8_t> raw_iso(kIsochHeaderSize);
        std::memcpy(raw_iso.data(), isochHeader, kIsochHeaderSize);
        logger_->trace("Packet G:{} P:{} - Raw Isoch Header @ {:p}: {}",
                      groupIndex, packetIndexInGroup, (void*)isochHeader, spdlog::to_hex(raw_iso));

        std::vector<uint8_t> raw_cip(kCIPHeaderSize);
        std::memcpy(raw_cip.data(), cipHeader, kCIPHeaderSize);
        logger_->trace("Packet G:{} P:{} - Raw CIP Header @ {:p}: {}",
                      groupIndex, packetIndexInGroup, (void*)cipHeader, spdlog::to_hex(raw_cip));
        logger_->trace("Packet G:{} P:{} - Packet Data @ {:p}, Length: {}",
                      groupIndex, packetIndexInGroup, (void*)packetData, packetDataLength);
        logger_->trace("Packet G:{} P:{} - FW Timestamp: {:#010x} ({})",
                      groupIndex, packetIndexInGroup, fwTimestamp, fwTimestamp);
    }

    // --- 1. Parse Isoch Header ---
    uint32_t isochHeaderVal = 0;
    std::memcpy(&isochHeaderVal, isochHeader, sizeof(isochHeaderVal));
    isochHeaderVal = OSSwapBigToHostInt32(isochHeaderVal); // Use CoreServices
    uint16_t dataLenFromIsoch = (isochHeaderVal >> 16) & 0xFFFF;
    uint8_t tag = (isochHeaderVal >> 14) & 0x03;
    uint8_t channel = (isochHeaderVal >> 8) & 0x3F;
    uint8_t tcode = (isochHeaderVal >> 4) & 0x0F;
    uint8_t sy = isochHeaderVal & 0x0F;

    if (logger_) logger_->trace("Packet G:{} P:{} - Parsed Isoch: Len={}, Tag={}, Ch={}, TCode={:#x}, Sy={}",
                               groupIndex, packetIndexInGroup, dataLenFromIsoch, tag, channel, tcode, sy);

    // --- 2. Parse CIP Header ---
    uint32_t cipQuadlets[2];
    std::memcpy(cipQuadlets, cipHeader, sizeof(cipQuadlets));
    uint32_t cip0 = OSSwapBigToHostInt32(cipQuadlets[0]);
    uint32_t cip1 = OSSwapBigToHostInt32(cipQuadlets[1]);

    uint8_t sid = (cip0 >> 24) & 0x3F; // Source ID
    uint8_t dbs = (cip0 >> 16) & 0xFF; // Data Block Size (quadlets)
    uint8_t dbc = cip0 & 0xFF;         // Data Block Counter
    uint8_t fmt = (cip1 >> 24) & 0x3F; // Format ID
    uint8_t fdf = (cip1 >> 16) & 0xFF; // Format Dependent Field
    uint16_t syt = cip1 & 0xFFFF;      // SYT field

    if (logger_) logger_->trace("Packet G:{} P:{} - Parsed CIP: SID={}, DBS={}, DBC={}, FMT={:#x}, FDF={:#x}, SYT={:#06x}",
                               groupIndex, packetIndexInGroup, sid, dbs, dbc, fmt, fdf, syt);

    // --- 3. Check for AMDTP format ---
    const uint8_t EXPECTED_FMT = 0x10;
    if (fmt != EXPECTED_FMT) {
        if (logger_) {
            std::vector<uint8_t> cip_bytes(8);
            std::memcpy(cip_bytes.data(), cipHeader, 8);
            logger_->warn("Packet G:{} P:{} - Unexpected CIP FMT: {:#04x} (Expected {:#04x}). Full CIP Header (BE): {}",
                          groupIndex, packetIndexInGroup, fmt, EXPECTED_FMT, spdlog::to_hex(cip_bytes));
        }
        return {}; // Skip non-AMDTP packets
    }

    // --- 4. Calculate block/sample info ---
    uint32_t dbs_bytes = dbs * 4;
    uint32_t samplesPerBlock = 0; // AM824 samples per CIP Data Block
    uint32_t numDataBlocks = 0;   // CIP Data Blocks in this FW packet

    if (dbs == 0 && fdf != 0xFF) {
        // If DBS is 0 but it's not a NO_DATA packet, something is wrong.
        if (logger_) logger_->warn("Packet G:{} P:{} - DBS is 0 but FDF is not NO_DATA ({:#x})!", 
                                  groupIndex, packetIndexInGroup, fdf);
        // Assume 0 blocks/samples and proceed to update DBC state based on this packet's DBC
        dbs_bytes = 0;
        samplesPerBlock = 0;
        numDataBlocks = 0; // Explicitly 0 blocks
    } else if (dbs > 0) {
        if ((dbs_bytes % BYTES_PER_AM824_SAMPLE) != 0) {
            if (logger_) logger_->error("Packet G:{} P:{} - DBS bytes ({}) not multiple of AM824 sample size ({})!", 
                                       groupIndex, packetIndexInGroup, dbs_bytes, BYTES_PER_AM824_SAMPLE);
            return std::unexpected(IOKitError::BadArgument); // Cannot process this packet
        }
        samplesPerBlock = dbs_bytes / BYTES_PER_AM824_SAMPLE;

        if (packetDataLength > 0 && dbs_bytes > 0) {
            if ((packetDataLength % dbs_bytes) != 0) {
                if (logger_) logger_->warn("Packet G:{} P:{} - Packet data length ({}) not multiple of DBS bytes ({})! Processing only full blocks.", 
                                          groupIndex, packetIndexInGroup, packetDataLength, dbs_bytes);
                // Only process full blocks contained within the packet data length
                numDataBlocks = packetDataLength / dbs_bytes;
            } else {
                numDataBlocks = packetDataLength / dbs_bytes;
            }
        } else {
            numDataBlocks = 0; // No data or zero DBS
        }
    } // else dbs is 0 and FDF is NO_DATA, numDataBlocks remains 0

    uint32_t totalSamplesInPacket = numDataBlocks * samplesPerBlock;

    // --- ADD EXTRA LOGGING HERE ---
    // if (logger_) logger_->debug("Packet G:{} P:{} - CALC: dbs={}, dbs_bytes={}, packetDataLength={}, samplesPerBlock={}, ***numDataBlocks={}***",
    //                            groupIndex, packetIndexInGroup, dbs, dbs_bytes, packetDataLength, samplesPerBlock, numDataBlocks);
    // // --- END EXTRA LOGGING ---

    // if (logger_) logger_->trace("Packet G:{} P:{} - Calculated: DBS_Bytes={}, SamplesPerBlock={}, NumDataBlocks={}, TotalSamples={}",
    //                            groupIndex, packetIndexInGroup, dbs_bytes, samplesPerBlock, numDataBlocks, totalSamplesInPacket);

    // --- State for callback ---
    std::vector<ProcessedSample> packetSamples;
    packetSamples.reserve(totalSamplesInPacket / 2); // Reserve for stereo frames
    uint64_t packetStartAbsSampleIndex = 0; // Will be set later
    bool discontinuityDetected = false;

    // Determine if current packet is NO_DATA
    bool currentPacketIsNoData = (fdf == 0xFF);

    // --- 5. Handle Packet Processing ---
    if (!dbcInitialized_) {
        // --- First Packet Initialization ---
        if (currentPacketIsNoData) {
            if (logger_) logger_->debug("First packet is NO_DATA, waiting for data to init DBC.");
            // Don't initialize state yet
            lastPacketWasNoData_ = true; // Mark that this packet was NO_DATA
        } else { // First packet is DATA
            expectedDBC_ = dbc;
            lastPacketNumDataBlocks_ = numDataBlocks; // Store blocks from THIS packet
            lastPacketWasNoData_ = false;             // THIS packet was DATA
            dbcInitialized_ = true;
            if (logger_) logger_->info("Packet G:{} P:{} - Initialized DBC tracking. First DBC={}, Blocks={}, Expecting next after {} blocks.",
                                      groupIndex, packetIndexInGroup, dbc, numDataBlocks, numDataBlocks);
            
            // Initialize Sample Index if it's the first DATA packet
            packetStartAbsSampleIndex = 0; // Since it's the first DATA packet
            if (!sampleIndexInitialized_) {
                currentAbsSampleIndex_ = 0;
                sampleIndexInitialized_ = true;
                if (logger_) logger_->info("Packet G:{} P:{} - Initialized absolute sample index to 0", groupIndex, packetIndexInGroup);
                
                // Initialize PLL here using fwTimestamp and SYT (if valid)
                if (processedDataCallback_ && syt != 0xFFFF) { // Only if callback set and SYT valid
                    PacketTimingInfo initTiming = { 
                        .fwTimestamp = fwTimestamp,
                        .syt = syt,
                        .firstDBC = dbc, 
                        .numSamplesInPacket = 0, // Pass 0 samples for init
                        .fdf = fdf,
                        .sfc = getSFCFromFDF(fdf),
                        .firstAbsSampleIndex = 0
                    };
                    std::vector<ProcessedSample> emptySamples;
                    processedDataCallback_(emptySamples, initTiming, processedDataCallbackRefCon_); // Signal for PLL init
                }
            }
        }
    } else {
        // --- Subsequent Packet Processing ---
        uint8_t nextExpectedDBC;

        // --- Calculate Correct Expectation ---
        if (lastPacketWasNoData_) {
            // If previous was NO_DATA, expect the SAME DBC it carried
            nextExpectedDBC = expectedDBC_;
            if (logger_) logger_->trace("Packet G:{} P:{} - Expecting SAME DBC {} (after NO_DATA)", 
                                       groupIndex, packetIndexInGroup, nextExpectedDBC);
        } else {
            // If previous was DATA, expect DBC + blocks from previous DATA packet
            nextExpectedDBC = (expectedDBC_ + lastPacketNumDataBlocks_) & 0xFF;
            if (logger_) logger_->trace("Packet G:{} P:{} - Expecting DBC {} + {} = {} (after DATA)", 
                                       groupIndex, packetIndexInGroup, expectedDBC_, lastPacketNumDataBlocks_, nextExpectedDBC);
        }

        // --- Compare Received DBC with Expectation ---
        if (dbc != nextExpectedDBC) {
            // --- DISCONTINUITY ---
            int8_t diff_s8 = static_cast<int8_t>(dbc - nextExpectedDBC);
            if (diff_s8 != -8) {
                // TODO: fix dbc continuity check
                // if (logger_) logger_->warn("Packet G:{} P:{} ({}) - DBC DISCONTINUITY! PrevDBC={}, PrevWasNoData={}, PrevBlocks={}, Expected {}, Got {}. Diff={}",
                //     groupIndex, packetIndexInGroup, (currentPacketIsNoData?"NO_DATA":"DATA"),
                //     expectedDBC_, lastPacketWasNoData_, lastPacketNumDataBlocks_, nextExpectedDBC, dbc, (int)diff_s8);

            }

            // --- Adjust sample index FORWARD only if diff > 0 ---
            if (sampleIndexInitialized_ && !currentPacketIsNoData) { // Only adjust for DATA packets after discontinuity
                if (diff_s8 > 0 && diff_s8 < 128) {
                    if (samplesPerBlock > 0) {
                        uint64_t lostSamples = static_cast<uint64_t>(diff_s8) * samplesPerBlock;
                        currentAbsSampleIndex_ += lostSamples / 2;
                        // TODO: fix dbc continuity check
                        // if (logger_) logger_->warn("  Adjusted sample index FORWARD by {} frames (~{} blocks of {} samples)", 
                        //                           lostSamples / 2, diff_s8, samplesPerBlock);
                    } else {
                        if (logger_) logger_->warn("  Cannot adjust sample index: samplesPerBlock is 0 for this packet.");
                    }
                } else {
                    // if (logger_) logger_->warn("  Negative or large DBC jump ({}), not adjusting sample index.", (int)diff_s8);
                }
            }

            // --- RESYNC State based on CURRENT packet ---
            expectedDBC_ = dbc;                       // Base NEXT expectation on THIS packet's DBC
            lastPacketNumDataBlocks_ = numDataBlocks;  // Use blocks from THIS packet
            lastPacketWasNoData_ = currentPacketIsNoData; // Store type of THIS packet
            discontinuityDetected = true;
            // if (logger_) logger_->debug("Packet G:{} P:{} - RESYNC state: Next expected after PrevDBC={}, PrevBlocks={}, PrevWasNoData={}",
            //                             groupIndex, packetIndexInGroup, expectedDBC_, lastPacketNumDataBlocks_, lastPacketWasNoData_);

        } else {
            // --- DBC OK ---
            if (logger_) logger_->trace("Packet G:{} P:{} ({}) - DBC OK (Expected {})",
                                        groupIndex, packetIndexInGroup, (currentPacketIsNoData?"NO_DATA":"DATA"), nextExpectedDBC);

            // --- Update state based on CURRENT packet for NEXT check ---
            expectedDBC_ = dbc;                        // Base NEXT expectation on THIS packet's DBC
            lastPacketNumDataBlocks_ = numDataBlocks;   // Use blocks from THIS packet
            lastPacketWasNoData_ = currentPacketIsNoData; // Store type of THIS packet
            if (logger_) logger_->trace("Packet G:{} P:{} - Updated state for next check: Next expected after PrevDBC={}, PrevBlocks={}, PrevWasNoData={}",
                                        groupIndex, packetIndexInGroup, expectedDBC_, lastPacketNumDataBlocks_, lastPacketWasNoData_);
        }

        // Set start sample index for potential processing
        packetStartAbsSampleIndex = currentAbsSampleIndex_;

        // Initialize sample index if it hadn't been initialized yet and this is the first DATA packet
        if (!sampleIndexInitialized_ && !currentPacketIsNoData) {
            currentAbsSampleIndex_ = 0;
            packetStartAbsSampleIndex = 0; // Adjust start index as well
            sampleIndexInitialized_ = true;
            if (logger_) logger_->info("Packet G:{} P:{} - Initialized absolute sample index to 0 (on first valid data packet after init)", 
                                      groupIndex, packetIndexInGroup);
                
            // Initialize PLL here using fwTimestamp and SYT (if valid)
            if (processedDataCallback_ && syt != 0xFFFF) { // Only if callback set and SYT valid
                PacketTimingInfo initTiming = { 
                    .fwTimestamp = fwTimestamp,
                    .syt = syt,
                    .firstDBC = dbc, 
                    .numSamplesInPacket = 0, // Pass 0 samples for init
                    .fdf = fdf,
                    .sfc = getSFCFromFDF(fdf),
                    .firstAbsSampleIndex = 0
                };
                std::vector<ProcessedSample> emptySamples;
                processedDataCallback_(emptySamples, initTiming, processedDataCallbackRefCon_); // Signal for PLL init
            }
        }
    } // End if (Subsequent Packet)

    // --- 6. Process Samples (Only for DATA packets) ---
    if (!currentPacketIsNoData && totalSamplesInPacket > 0) {
        for (uint32_t blockIdx = 0; blockIdx < numDataBlocks; ++blockIdx) {
            const uint8_t* blockPtr = packetData + (blockIdx * dbs_bytes);
            uint8_t currentBlockDBC = (dbc + blockIdx) & 0xFF; // DBC for this specific block

            for (uint32_t sampleIdx = 0; sampleIdx < samplesPerBlock; sampleIdx += 2) { // Stereo pairs
                if ((sampleIdx + 1) >= samplesPerBlock) {
                    if (logger_) logger_->warn("Packet G:{} P:{} B:{} - Odd number of samples in block? Skipping last sample.",
                                             groupIndex, packetIndexInGroup, currentBlockDBC);
                    break; // Avoid reading past end
                }

                uint64_t frameAbsSampleIndex = packetStartAbsSampleIndex + (blockIdx * samplesPerBlock + sampleIdx) / 2;

                // Extract Left Sample (AM824 format)
                uint32_t am824_be_L;
                std::memcpy(&am824_be_L, blockPtr + (sampleIdx * BYTES_PER_AM824_SAMPLE), sizeof(uint32_t));
                uint32_t am824_le_L = OSSwapBigToHostInt32(am824_be_L); // To Host Endian
                int32_t sample24_L = am824_le_L & 0x00FFFFFF;
                if (sample24_L & 0x00800000) { sample24_L |= 0xFF000000; }
                float sampleFloatL = static_cast<float>(sample24_L) / MAX_24BIT_SIGNED_FLOAT;

                // Extract Right Sample
                uint32_t am824_be_R;
                std::memcpy(&am824_be_R, blockPtr + ((sampleIdx + 1) * BYTES_PER_AM824_SAMPLE), sizeof(uint32_t));
                uint32_t am824_le_R = OSSwapBigToHostInt32(am824_be_R);
                int32_t sample24_R = am824_le_R & 0x00FFFFFF;
                if (sample24_R & 0x00800000) { sample24_R |= 0xFF000000; }
                float sampleFloatR = static_cast<float>(sample24_R) / MAX_24BIT_SIGNED_FLOAT;

                packetSamples.push_back({sampleFloatL, sampleFloatR, frameAbsSampleIndex});
            }
        }
        // Increment absolute sample counter AFTER processing samples
        currentAbsSampleIndex_ += totalSamplesInPacket / 2;
    } else if (!currentPacketIsNoData) {
        if (logger_) logger_->trace("Packet G:{} P:{} - No samples to process in DATA packet (NumDataBlocks={}, SamplesPerBlock={})",
                                   groupIndex, packetIndexInGroup, numDataBlocks, samplesPerBlock);
    } // No processing needed for NO_DATA packets here

    // --- 7. Prepare Timing Info ---
    PacketTimingInfo timingInfo = {
        .fwTimestamp = fwTimestamp,
        .syt = syt,
        .firstDBC = dbc, // DBC of the first block in *this* packet
        .numSamplesInPacket = totalSamplesInPacket,
        .fdf = fdf,
        .sfc = getSFCFromFDF(fdf),
        .firstAbsSampleIndex = packetStartAbsSampleIndex // Start index for samples in *this* packet
    };

    // --- 8. Send data upstream ---
    if (processedDataCallback_) {
        // Call with samples (even if empty for NO_DATA packets or on discontinuity)
        processedDataCallback_(packetSamples, timingInfo, processedDataCallbackRefCon_);
    } else if (logger_) {
        logger_->warn("Packet G:{} P:{} - No processed data callback set!", groupIndex, packetIndexInGroup);
    }

    return {};
}

// --- Legacy processPacket (Marked Deprecated) ---
std::expected<void, IOKitError> IsochPacketProcessor::processPacket(
    uint32_t segment, uint32_t cycle, const uint8_t* data, size_t length)
{
    // DEPRECATED - This function assumes a combined buffer.
    if (logger_) logger_->warn("Deprecated IsochPacketProcessor::processPacket called!");

    if (!data || length < (IsochBufferManager::kIsochHeaderSize + IsochBufferManager::kCIPHeaderSize)) {
        return std::unexpected(IOKitError::BadArgument);
    }

    const uint8_t* isochHeader = data;
    const uint8_t* cipHeader = data + IsochBufferManager::kIsochHeaderSize;
    const uint8_t* packetData = data + IsochBufferManager::kIsochHeaderSize + IsochBufferManager::kCIPHeaderSize;
    size_t packetDataLength = length - IsochBufferManager::kIsochHeaderSize - IsochBufferManager::kCIPHeaderSize;

    // Cannot get real FW Timestamp here. Pass 0.
    return processPacket(segment, cycle, isochHeader, cipHeader, packetData, packetDataLength, 0);
}

std::expected<void, IOKitError> IsochPacketProcessor::handleOverrun() {
    if (logger_) {
        logger_->error("IsochPacketProcessor::handleOverrun detected - Resetting DBC/SampleIndex state.");
    }
    // Reset tracking state on overrun to force re-sync
    dbcInitialized_ = false;
    sampleIndexInitialized_ = false; // Force re-sync of sample index
    lastPacketNumDataBlocks_ = 0;    // Reset this too
    lastPacketWasNoData_ = false;    // Reset this state too
    currentAbsSampleIndex_ = 0;      // Reset sample index on overrun

    if (overrunCallback_) {
        overrunCallback_(overrunCallbackRefCon_);
    }
    return {};
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochPortChannelManager.cpp ===
#include "Isoch/core/IsochPortChannelManager.hpp"
#include <spdlog/spdlog.h>
#include <unistd.h>

namespace FWA {
namespace Isoch {

// Static constant definition
constexpr uint32_t IsochPortChannelManager::kAnyAvailableIsochChannel;

IsochPortChannelManager::IsochPortChannelManager(
    std::shared_ptr<spdlog::logger> logger,
    IOFireWireLibNubRef interface,
    CFRunLoopRef runLoop,
    bool isTalker)
    : logger_(std::move(logger))
    , interface_(interface)
    , runLoop_(runLoop ? runLoop : CFRunLoopGetCurrent())
    , isTalker_(isTalker) {
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager created, isTalker={}", isTalker_);
    }
    
    // Retain the interface reference (needed for proper RAII)
    if (interface_) {
        (*interface_)->AddRef(interface_);
    }
}

IsochPortChannelManager::~IsochPortChannelManager() {
    reset();
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager destroyed");
    }
}

void IsochPortChannelManager::reset() {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    // Clean up resources
    cleanupResources();
    
    // Clean up dispatchers if they were added
    if (dispatchersAdded_ && interface_) {
        cleanupDispatchers();
    }
    
    // Release interface last
    if (interface_) {
        (*interface_)->Release(interface_);
        interface_ = nullptr;
    }
    
    // Reset state
    initialized_ = false;
    finalized_ = false;
    running_ = false;
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager reset completed");
    }
}

void IsochPortChannelManager::cleanupResources() noexcept {
    // Release isoch channel
    if (isochChannel_) {
        if (running_) {
            (*isochChannel_)->Stop(isochChannel_);
            (*isochChannel_)->ReleaseChannel(isochChannel_);
            running_ = false;
        }
        (*isochChannel_)->Release(isochChannel_);
        isochChannel_ = nullptr;
    }
    
    // Release local port
    if (localPort_) {
        (*localPort_)->Release(localPort_);
        localPort_ = nullptr;
    }
    
    // Release remote port
    if (remotePort_) {
        (*remotePort_)->Release(remotePort_);
        remotePort_ = nullptr;
    }
    
    // Release NuDCL pool
    if (nuDCLPool_) {
        (*nuDCLPool_)->Release(nuDCLPool_);
        nuDCLPool_ = nullptr;
    }
    
    // Reset active channel
    activeChannel_ = kAnyAvailableIsochChannel;
}

void IsochPortChannelManager::cleanupDispatchers() noexcept {
    if (!interface_ || !dispatchersAdded_) {
        return;
    }
    
    // Remove dispatchers from RunLoop
    (*interface_)->RemoveIsochCallbackDispatcherFromRunLoop(interface_);
    (*interface_)->RemoveCallbackDispatcherFromRunLoop(interface_);
    
    dispatchersAdded_ = false;
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager::cleanupDispatchers: Dispatchers removed from RunLoop");
    }
}

std::expected<void, IOKitError> IsochPortChannelManager::initialize() {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (initialized_) {
        return std::unexpected(IOKitError::Busy);
    }
    
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::initialize: interface is null");
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    if (logger_) {
        logger_->info("IsochPortChannelManager::initialize: isTalker={}, runLoop={:p}",
                      isTalker_, (void*)runLoop_);
    }
    
    // Add dispatchers to RunLoop
    auto result = setupDispatchers();
    if (!result) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::initialize: Failed to setup dispatchers: {}",
                          static_cast<int>(result.error()));
        }
        return result;
    }
    
    // Setup NuDCL pool
    result = setupNuDCLPool();
    if (!result) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::initialize: Failed to setup NuDCL pool: {}",
                           static_cast<int>(result.error()));
        }
        cleanupDispatchers();
        return result;
    }
    
    // Create remote port
    result = createRemotePort();
    if (!result) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::initialize: Failed to create remote port: {}",
                           static_cast<int>(result.error()));
        }
        
        // Clean up resources created so far
        if (nuDCLPool_) {
            (*nuDCLPool_)->Release(nuDCLPool_);
            nuDCLPool_ = nullptr;
        }
        
        cleanupDispatchers();
        return result;
    }
    
    // Mark initialization as successful
    initialized_ = true;
    
    if (logger_) {
        logger_->info("IsochPortChannelManager::initialize: completed successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::setupDispatchers() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupDispatchers: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Add required dispatchers to RunLoop
    IOReturn ret = (*interface_)->AddCallbackDispatcherToRunLoop(interface_, runLoop_);
    if (ret != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupDispatchers: Failed to add callback dispatcher to RunLoop: 0x{:08X}", ret);
        }
        return std::unexpected(IOKitError(ret));
    }
    
    ret = (*interface_)->AddIsochCallbackDispatcherToRunLoop(interface_, runLoop_);
    if (ret != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupDispatchers: Failed to add isoch callback dispatcher to RunLoop: 0x{:08X}", ret);
        }
        (*interface_)->RemoveCallbackDispatcherFromRunLoop(interface_);
        return std::unexpected(IOKitError(ret));
    }
    
    dispatchersAdded_ = true;
    
    if (logger_) {
        logger_->info("IsochPortChannelManager::setupDispatchers: dispatchers added to RunLoop");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::setupNuDCLPool() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupNuDCLPool: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Create the NuDCL pool
    nuDCLPool_ = (*interface_)->CreateNuDCLPool(
                                                interface_,
                                                0,
                                                CFUUIDGetUUIDBytes(kIOFireWireNuDCLPoolInterfaceID));
    
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupNuDCLPool: failed to create NuDCL pool");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager::setupNuDCLPool: NuDCL pool created");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::createRemotePort() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createRemotePort: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Create remote isoch port
    // Note: Remote port is listener if local is talker, and vice versa
    remotePort_ = (*interface_)->CreateRemoteIsochPort(
                                                       interface_,
                                                       !isTalker_,  // opposite of local role
                                                       CFUUIDGetUUIDBytes(kIOFireWireRemoteIsochPortInterfaceID));
    
    if (!remotePort_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createRemotePort: failed to create remote port");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    // Set this instance as the refCon for the port
    (*remotePort_)->SetRefCon((IOFireWireLibIsochPortRef)remotePort_, this);
    
    // Set up callback handlers
    (*remotePort_)->SetGetSupportedHandler(remotePort_, RemotePort_GetSupported_Helper);
    (*remotePort_)->SetAllocatePortHandler(remotePort_, RemotePort_AllocatePort_Helper);
    (*remotePort_)->SetReleasePortHandler(remotePort_, RemotePort_ReleasePort_Helper);
    (*remotePort_)->SetStartHandler(remotePort_, RemotePort_Start_Helper);
    (*remotePort_)->SetStopHandler(remotePort_, RemotePort_Stop_Helper);
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager::createRemotePort: remote port created");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::createLocalPort(
    DCLCommand* program,
    const IOVirtualRange& bufferRange) {

    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: Interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }

    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }

    if (!program) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: DCL program is null");
        }
        return std::unexpected(IOKitError::BadArgument);
    }

    if (!bufferRange.address || !bufferRange.length) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: Invalid buffer range");
        }
        return std::unexpected(IOKitError::BadArgument);
    }

    // Buffer must be 32-bit aligned - check without using reinterpret_cast
    if ((bufferRange.address & 0x3ULL) != 0) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: Buffer not 32-bit aligned");
        }
        return std::unexpected(IOKitError::BadArgument);
    }

    if (logger_) {
        logger_->info("IsochPortChannelManager::createLocalPort: Creating port with buffer at {:p}, length={}",
                     (void*)(uintptr_t)bufferRange.address, bufferRange.length);
    }

    // Create a non-const copy of the buffer range to pass to CreateLocalIsochPort
    IOVirtualRange bufferRangeCopy = bufferRange;

    // Create the local port using correct DCLCommand* parameter
    localPort_ = (*interface_)->CreateLocalIsochPort(
        interface_,
        isTalker_,              // True for talker, false for listener
        program,                // DCL program handle (DCLCommand*) from GetProgram
        0,                      // startEvent
        0,                      // startState
        0,                      // startMask
        nullptr,                // dclProgramRanges - we don't use this for our simple config
        0,                      // dclProgramRangeCount
        reinterpret_cast<::IOVirtualRange*>(&bufferRangeCopy),  // Cast to the system IOVirtualRange type
        1,                      // bufferRangeCount
        CFUUIDGetUUIDBytes(kIOFireWireLocalIsochPortInterfaceID)
    );

    if (!localPort_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: CreateLocalIsochPort failed");
        }
        return std::unexpected(IOKitError::NoMemory);
    }

    // Set refcon pointer for callbacks
    (*localPort_)->SetRefCon((IOFireWireLibIsochPortRef)localPort_, this);

    // Set finalize callback
    IOReturn result = (*localPort_)->SetFinalizeCallback(localPort_, PortFinalize_Helper);
    if (result != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createLocalPort: Failed to set finalize callback: 0x{:08X}", result);
        }
        // Clean up local port
        (*localPort_)->Release(localPort_);
        localPort_ = nullptr;
        return std::unexpected(IOKitError(result));
    }

    if (logger_) {
        logger_->debug("IsochPortChannelManager::createLocalPort: Local port created successfully");
    }
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::createIsochChannel() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createIsochChannel: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (!localPort_ || !remotePort_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createIsochChannel: Ports are not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Calculate packet size for IRM allocations - this should be determined based on audio needs
    const uint32_t irmPacketSize = 72; // 64 bytes for samples + 8 bytes for CIP header
    
    // Create the isoch channel
    isochChannel_ = (*interface_)->CreateIsochChannel(
                                                      interface_,
                                                      true,  // doIRMAllocations
                                                      irmPacketSize,
                                                      kFWSpeedMaximum,
                                                      CFUUIDGetUUIDBytes(kIOFireWireIsochChannelInterfaceID));
    
    if (!isochChannel_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::createIsochChannel: Failed to create isoch channel");
        }
        return std::unexpected(IOKitError::Error);
    }
    
    // Set up channel with appropriate talker/listener roles
    IOReturn result;
    if (isTalker_) {
        // We are talker, remote is listener
        if (logger_) {
            logger_->info("IsochPortChannelManager::createIsochChannel: This is a talker, remote is listener");
        }
        
        result = (*isochChannel_)->AddListener(
                                               isochChannel_,
                                               reinterpret_cast<IOFireWireLibIsochPortRef>(remotePort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochPortChannelManager::createIsochChannel: Failed to add listener: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
        
        result = (*isochChannel_)->SetTalker(
                                             isochChannel_,
                                             reinterpret_cast<IOFireWireLibIsochPortRef>(localPort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochPortChannelManager::createIsochChannel: Failed to set talker: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
    } else {
        // We are listener, remote is talker
        if (logger_) {
            logger_->info("IsochPortChannelManager::createIsochChannel: This is a listener, remote is talker");
        }
        
        result = (*isochChannel_)->AddListener(
                                               isochChannel_,
                                               reinterpret_cast<IOFireWireLibIsochPortRef>(localPort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochPortChannelManager::createIsochChannel: Failed to add listener: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
        
        result = (*isochChannel_)->SetTalker(
                                             isochChannel_,
                                             reinterpret_cast<IOFireWireLibIsochPortRef>(remotePort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochPortChannelManager::createIsochChannel: Failed to set talker: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
    }
    
    // Set this as the refcon for the channel
    (*isochChannel_)->SetRefCon(isochChannel_, this);
    
    if (logger_) {
        logger_->debug("IsochPortChannelManager::createIsochChannel: Isoch channel created successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::setupLocalPortAndChannel(
    DCLCommand* program,
    const IOVirtualRange& bufferRange) {

    std::lock_guard<std::mutex> lock(stateMutex_);

    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupLocalPortAndChannel: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }

    // Create local port first
    auto result = createLocalPort(program, bufferRange);
    if (!result) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupLocalPortAndChannel: Failed to create local port: {}",
                         iokit_error_category().message(static_cast<int>(result.error())));
        }
        return result;
    }

    // Then create the isoch channel
    result = createIsochChannel();
    if (!result) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::setupLocalPortAndChannel: Failed to create isoch channel: {}",
                         iokit_error_category().message(static_cast<int>(result.error())));
        }
        // Cleanup local port if channel creation fails
        if (localPort_) {
            (*localPort_)->Release(localPort_);
            localPort_ = nullptr;
        }
        return result;
    }

    if (logger_) {
        logger_->info("IsochPortChannelManager::setupLocalPortAndChannel: Port and channel setup successfully");
    }
    return {};
}

std::expected<void, IOKitError> IsochPortChannelManager::configure(IOFWSpeed speed, uint32_t channel) {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::configure: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (running_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::configure: Cannot configure while running");
        }
        return std::unexpected(IOKitError::Busy);
    }
    
    configuredSpeed_ = speed;
    configuredChannel_ = channel;
    
    if (logger_) {
        logger_->info("IsochPortChannelManager::configure: Set speed={}, channel={}",
                      static_cast<int>(speed), channel);
    }
    
    return {};
}

IOFireWireLibNuDCLPoolRef IsochPortChannelManager::getNuDCLPool() const {
    return nuDCLPool_;
}

IOFireWireLibLocalIsochPortRef IsochPortChannelManager::getLocalPort() const {
    return localPort_;
}

IOFireWireLibIsochChannelRef IsochPortChannelManager::getIsochChannel() const {
    return isochChannel_;
}

std::expected<uint32_t, IOKitError> IsochPortChannelManager::getActiveChannel() const {
    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochPortChannelManager::getActiveChannel: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    return activeChannel_;
}

std::expected<uint16_t, IOKitError> IsochPortChannelManager::getLocalNodeID() const {
     if (!interface_) {
         if (logger_) logger_->error("IsochPortChannelManager::getLocalNodeID: interface is null");
         return std::unexpected(IOKitError::NotReady);
     }
     
     UInt32 generation = 0;
     UInt16 nodeID = 0;
     
     IOReturn result = (*interface_)->GetBusGeneration(interface_, &generation);
     if (result != kIOReturnSuccess) {
          if(logger_) logger_->error("IsochPortChannelManager::getLocalNodeID: Failed to get bus generation: {:#0x}", result);
         return std::unexpected(IOKitError(result));
     }
     
     result = (*interface_)->GetLocalNodeIDWithGeneration(interface_, generation, &nodeID);
     if (result != kIOReturnSuccess) {
          if(logger_) logger_->error("IsochPortChannelManager::getLocalNodeID: Failed to get local node ID: {:#0x}", result);
         return std::unexpected(IOKitError(result));
     }
     
     if(logger_) logger_->trace("IsochPortChannelManager::getLocalNodeID: Got local node ID: {:#x}", nodeID);
     return nodeID;
}

void IsochPortChannelManager::handlePortFinalize() {
    if (logger_) {
        logger_->debug("IsochPortChannelManager::handlePortFinalize: Port finalize called");
    }
    
    finalized_ = true;
}

// Static callback handlers
IOReturn IsochPortChannelManager::RemotePort_GetSupported_Helper(
                                                      IOFireWireLibIsochPortRef interface,
                                                      IOFWSpeed *outMaxSpeed,
                                                      UInt64 *outChanSupported) {
    
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    return manager->handleRemotePortGetSupported(outMaxSpeed, outChanSupported);
}

IOReturn IsochPortChannelManager::RemotePort_AllocatePort_Helper(
                                                      IOFireWireLibIsochPortRef interface,
                                                      IOFWSpeed maxSpeed,
                                                      UInt32 channel) {
    
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    return manager->handleRemotePortAllocatePort(maxSpeed, channel);
}

IOReturn IsochPortChannelManager::RemotePort_ReleasePort_Helper(
                                                     IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    return manager->handleRemotePortReleasePort();
}

IOReturn IsochPortChannelManager::RemotePort_Start_Helper(
                                               IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    return manager->handleRemotePortStart();
}

IOReturn IsochPortChannelManager::RemotePort_Stop_Helper(
                                              IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    return manager->handleRemotePortStop();
}

IOReturn IsochPortChannelManager::PortFinalize_Helper(void* refcon) {
    // Get the IsochPortChannelManager instance from the refcon
    auto manager = static_cast<IsochPortChannelManager*>(refcon);
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    manager->handlePortFinalize();
    
    return kIOReturnSuccess;
}

// Instance methods called by static helpers
IOReturn IsochPortChannelManager::handleRemotePortGetSupported(IOFWSpeed *outMaxSpeed, UInt64 *outChanSupported) {
    // Use stored speed from configuration
    *outMaxSpeed = configuredSpeed_;
    
    // Handle channel selection based on configuration
    uint32_t channel = configuredChannel_;
    if (channel == kAnyAvailableIsochChannel) {
        // Allow FireWireFamily to determine an available channel
        // Enable all channels except 0 (which is reserved)
        *outChanSupported = ~1ULL;
    } else {
        // Use a specific channel - create a mask with only that bit set
        *outChanSupported = (((UInt64)0x80000000 << 32 | (UInt64)0x00000000) >> channel);
    }
    
    if (logger_) {
        logger_->debug("RemotePort_GetSupported: speed={}, channel={}",
                        static_cast<int>(*outMaxSpeed),
                        (channel == kAnyAvailableIsochChannel) ?
                        "any" : std::to_string(channel));
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochPortChannelManager::handleRemotePortAllocatePort(IOFWSpeed maxSpeed, UInt32 channel) {
    // Store the allocated channel for future reference
    activeChannel_ = channel;
    
    if (logger_) {
        logger_->debug("RemotePort_AllocatePort: speed={}, channel={}",
                        static_cast<int>(maxSpeed), channel);
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochPortChannelManager::handleRemotePortReleasePort() {
    // Reset active channel
    activeChannel_ = kAnyAvailableIsochChannel;
    
    if (logger_) {
        logger_->debug("RemotePort_ReleasePort called");
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochPortChannelManager::handleRemotePortStart() {
    // Set the running state
    running_ = true;
    
    if (logger_) {
        logger_->debug("RemotePort_Start called");
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochPortChannelManager::handleRemotePortStop() {
    // Clear the running state
    running_ = false;
    
    if (logger_) {
        logger_->debug("RemotePort_Stop called");
    }
    
    return kIOReturnSuccess;
}

} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochTransmitBufferManager.cpp ===
#include "Isoch/core/IsochTransmitBufferManager.hpp"
#include "Isoch/core/TransmitterTypes.hpp" // Include for kTransmitCIPHeaderSize and kTransmitIsochHeaderSize constants
#include <mach/mach.h>
#include <cstring> // For bzero

namespace FWA {
namespace Isoch {

// Constants from TransmitterTypes.hpp are now used
constexpr size_t kTimestampSize = 4;

IsochTransmitBufferManager::IsochTransmitBufferManager(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)) {
    if (logger_) logger_->debug("IsochTransmitBufferManager created");
}

IsochTransmitBufferManager::~IsochTransmitBufferManager() {
    // Acquire lock here before calling cleanup
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup();
    if (logger_) logger_->debug("IsochTransmitBufferManager destroyed");
}

void IsochTransmitBufferManager::cleanup() noexcept {
    // NOTE: This function now assumes the caller holds the mutex_ lock.
    if (mainBuffer_) {
        vm_deallocate(mach_task_self(), reinterpret_cast<vm_address_t>(mainBuffer_), totalBufferSize_);
        mainBuffer_ = nullptr;
        clientAudioArea_ = nullptr;
        isochHeaderArea_ = nullptr;
        cipHeaderArea_ = nullptr;
        timestampArea_ = nullptr;
        totalBufferSize_ = 0;
        bufferRange_ = {};
        if (logger_) logger_->debug("IsochTransmitBufferManager::cleanup: Released buffer");
    }
}

void IsochTransmitBufferManager::calculateBufferLayout() {
    totalPackets_ = config_.numGroups * config_.packetsPerGroup;

    // --- MODIFICATION START ---
    // Explicitly set audio payload size. For AM824 Stereo, DBS=2 (8 bytes/frame).
    // Assuming 8 frames per packet for a 64-byte payload, consistent with receiver/legacy.
    // This calculation might become dynamic based on config_.sampleRate and format later.
    const size_t framesPerPacket = 8; // Based on common practice / legacy UniversalTransmitter
    const size_t bytesPerFrameStereoAM824 = 8; // 2 channels * 4 bytes/sample (incl. label)
    audioPayloadSizePerPacket_ = framesPerPacket * bytesPerFrameStereoAM824; // Should be 64 bytes

    if (logger_) {
         logger_->debug("Buffer layout calculated for SampleRate={:.1f}Hz", config_.sampleRate);
         logger_->debug("  Assumed FramesPerPacket={}, BytesPerFrame={}, Resulting PayloadSize={}",
                        framesPerPacket, bytesPerFrameStereoAM824, audioPayloadSizePerPacket_);
    }
     // --- MODIFICATION END ---

    // --- Sizes calculation (NO CHANGE needed here, uses config/constants) ---
    size_t clientDataSize = config_.clientBufferSize;
    size_t cipHeadersSize = totalPackets_ * kTransmitCIPHeaderSize;
    size_t isochHeadersSize = totalPackets_ * kTransmitIsochHeaderSize; // Template only
    size_t timestampsSize = config_.numGroups * kTimestampSize; // Only need one per group/segment completion
    // --- End Sizes calculation ---

    // Align each section
    clientBufferSize_aligned_ = (clientDataSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    cipHeaderTotalSize_aligned_ = (cipHeadersSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    isochHeaderTotalSize_aligned_ = (isochHeadersSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    timestampTotalSize_aligned_ = (timestampsSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

    totalBufferSize_ = clientBufferSize_aligned_ + cipHeaderTotalSize_aligned_ + isochHeaderTotalSize_aligned_ + timestampTotalSize_aligned_;

    if (logger_) {
        logger_->debug("Buffer layout calculated:");
        logger_->debug("  Total packets: {}", totalPackets_);
        logger_->debug("  Audio payload per packet: {} bytes", audioPayloadSizePerPacket_);
        logger_->debug("  Client buffer: {} bytes (aligned: {})", clientDataSize, clientBufferSize_aligned_);
        logger_->debug("  CIP headers: {} bytes (aligned: {})", cipHeadersSize, cipHeaderTotalSize_aligned_);
        logger_->debug("  Isoch headers: {} bytes (aligned: {})", isochHeadersSize, isochHeaderTotalSize_aligned_);
        logger_->debug("  Timestamps: {} bytes (aligned: {})", timestampsSize, timestampTotalSize_aligned_);
        logger_->debug("  Total buffer size: {} bytes", totalBufferSize_);
    }
}

std::expected<void, IOKitError> IsochTransmitBufferManager::setupBuffers(const TransmitterConfig& config) {
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup(); // Clean up previous if any
    config_ = config;

    if (config_.numGroups == 0 || config_.packetsPerGroup == 0 || config_.clientBufferSize == 0) {
        if (logger_) logger_->error("IsochTransmitBufferManager: Invalid config (zeros)");
        return std::unexpected(IOKitError::BadArgument);
    }

    calculateBufferLayout();

    vm_address_t buffer = 0;
    kern_return_t result = vm_allocate(mach_task_self(), &buffer, totalBufferSize_, VM_FLAGS_ANYWHERE);
    if (result != KERN_SUCCESS) {
        if (logger_) logger_->error("IsochTransmitBufferManager: vm_allocate failed: {}", result);
        return std::unexpected(IOKitError::NoMemory);
    }

    mainBuffer_ = reinterpret_cast<uint8_t*>(buffer);
    bzero(mainBuffer_, totalBufferSize_);

    // Assign pointers based on layout
    clientAudioArea_ = mainBuffer_;
    cipHeaderArea_ = clientAudioArea_ + clientBufferSize_aligned_;
    isochHeaderArea_ = cipHeaderArea_ + cipHeaderTotalSize_aligned_;
    timestampArea_ = reinterpret_cast<uint32_t*>(isochHeaderArea_ + isochHeaderTotalSize_aligned_);

    bufferRange_.address = reinterpret_cast<IOVirtualAddress>(mainBuffer_);
    bufferRange_.length = totalBufferSize_;

    if (logger_) {
        logger_->info("IsochTransmitBufferManager::setupBuffers: Allocated buffer at {:p} size {}", (void*)mainBuffer_, totalBufferSize_);
        logger_->debug("  Client audio area: {:p}", (void*)clientAudioArea_);
        logger_->debug("  CIP header area: {:p}", (void*)cipHeaderArea_);
        logger_->debug("  Isoch header area: {:p}", (void*)isochHeaderArea_);
        logger_->debug("  Timestamp area: {:p}", (void*)timestampArea_);
    }

    return {};
}

// Implement Getters (with basic checks)
std::expected<uint8_t*, IOKitError> IsochTransmitBufferManager::getPacketIsochHeaderPtr(uint32_t g, uint32_t p) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups || p >= config_.packetsPerGroup) {
        return std::unexpected(IOKitError::BadArgument);
    }
    size_t offset = (g * config_.packetsPerGroup + p) * kTransmitIsochHeaderSize;
    return isochHeaderArea_ + offset;
}

std::expected<uint8_t*, IOKitError> IsochTransmitBufferManager::getPacketCIPHeaderPtr(uint32_t g, uint32_t p) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups || p >= config_.packetsPerGroup) {
        return std::unexpected(IOKitError::BadArgument);
    }
    size_t offset = (g * config_.packetsPerGroup + p) * kTransmitCIPHeaderSize;
    return cipHeaderArea_ + offset;
}

std::expected<uint32_t*, IOKitError> IsochTransmitBufferManager::getGroupTimestampPtr(uint32_t g) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups) {
        return std::unexpected(IOKitError::BadArgument);
    }
    return timestampArea_ + g;
}

uint8_t* IsochTransmitBufferManager::getClientAudioBufferPtr() const { 
    return clientAudioArea_; 
}

size_t IsochTransmitBufferManager::getClientAudioBufferSize() const { 
    return config_.clientBufferSize;  // Return requested size
}

size_t IsochTransmitBufferManager::getAudioPayloadSizePerPacket() const { 
    return audioPayloadSizePerPacket_; 
}

const IOVirtualRange& IsochTransmitBufferManager::getBufferRange() const { 
    return bufferRange_; 
}

size_t IsochTransmitBufferManager::getTotalBufferSize() const { 
    return totalBufferSize_; 
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochManager.cpp ===
#include "Isoch/core/IsochManager.hpp"
#include <spdlog/spdlog.h>
#include <unistd.h>

namespace FWA {
namespace Isoch {

IsochManager::IsochManager(std::shared_ptr<spdlog::logger> logger)
: logger_(std::move(logger)) {
    if (logger_) {
        logger_->debug("IsochManager created");
    }
}

IsochManager::~IsochManager() {
    reset();
    
    if (logger_) {
        logger_->debug("IsochManager destroyed");
    }
}

void IsochManager::reset() {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    // Release isoch channel
    if (isochChannel_) {
        if (running_) {
            (*isochChannel_)->Stop(isochChannel_);
            (*isochChannel_)->ReleaseChannel(isochChannel_);
            running_ = false;
        }
        (*isochChannel_)->Release(isochChannel_);
        isochChannel_ = nullptr;
    }
    
    // Release local port
    if (localPort_) {
        (*localPort_)->Release(localPort_);
        localPort_ = nullptr;
    }
    
    // Release remote port
    if (remotePort_) {
        (*remotePort_)->Release(remotePort_);
        remotePort_ = nullptr;
    }
    
    // Release NuDCL pool and free update bags
    if (nuDCLPool_) {
        // Clean up update bags
        for (auto& segment : segments_) {
            if (segment.updateBag) {
                CFRelease(segment.updateBag);
                segment.updateBag = nullptr;
            }
        }
        
        (*nuDCLPool_)->Release(nuDCLPool_);
        nuDCLPool_ = nullptr;
    }
    
    // Clear segment information
    segments_.clear();
    overrunDCL_ = nullptr;
    
    // Clear buffer pointers
    baseBuffer_ = nullptr;
    timestampBuffer_ = nullptr;
    
    // Reset state
    initialized_ = false;
    finalized_ = false;
    running_ = false;
    
    if (logger_) {
        logger_->debug("IsochManager reset completed");
    }
}

std::expected<void, IOKitError> IsochManager::initialize(
                                                         IOFireWireLibNubRef interface,
                                                         bool isTalker,
                                                         CFRunLoopRef runLoop) {
    
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (initialized_) {
        return std::unexpected(IOKitError::Busy);
    }
    
    if (!interface) {
        if (logger_) {
            logger_->error("IsochManager::initialize: interface is null");
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // Store parameters
    interface_ = interface;
    isTalker_ = isTalker;
    runLoop_ = runLoop ? runLoop : CFRunLoopGetCurrent();
    
    if (logger_) {
        logger_->info("IsochManager::initialize: isTalker={}, runLoop={:p}",
                      isTalker_, (void*)runLoop_);
    }
    
    // Retain the interface reference (needed for proper RAII)
    (*interface_)->AddRef(interface_);
    
    // Add required dispatchers to RunLoop
    IOReturn ret = (*interface_)->AddCallbackDispatcherToRunLoop(interface_, runLoop_);
    if (ret != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("Failed to add callback dispatcher to RunLoop: 0x{:08X}", ret);
        }
        (*interface_)->Release(interface_);
        interface_ = nullptr;
        return std::unexpected(IOKitError(ret));
    }
    
    ret = (*interface_)->AddIsochCallbackDispatcherToRunLoop(interface_, runLoop_);
    if (ret != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("Failed to add isoch callback dispatcher to RunLoop: 0x{:08X}", ret);
        }
        (*interface_)->RemoveCallbackDispatcherFromRunLoop(interface_);
        (*interface_)->Release(interface_);
        interface_ = nullptr;
        return std::unexpected(IOKitError(ret));
    }
    
    if (logger_) {
        logger_->info("IsochManager::initialize: dispatchers added to RunLoop");
    }
    
    // Setup NuDCL pool (this must be done first)
    auto result = setupNuDCLPool();
    if (!result) {
        if (logger_) {
            logger_->error("Failed to setup NuDCL pool: {}",
                           static_cast<int>(result.error()));
        }
        
        // Clean up
        (*interface_)->RemoveIsochCallbackDispatcherFromRunLoop(interface_);
        (*interface_)->RemoveCallbackDispatcherFromRunLoop(interface_);
        (*interface_)->Release(interface_);
        interface_ = nullptr;
        return result;
    }
    
    // Remote port is required for both talker and listener roles
    result = createRemotePort();
    if (!result) {
        if (logger_) {
            logger_->error("Failed to create remote port: {}",
                           static_cast<int>(result.error()));
        }
        
        reset();
        return result;
    }
    
    // Mark initialization as successful at this point
    // Note: Local port and isoch channel will be created when createDCLProgram is called
    initialized_ = true;
    
    if (logger_) {
        logger_->info("IsochManager::initialize: completed successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::setupNuDCLPool() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochManager::setupNuDCLPool: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Create the NuDCL pool
    nuDCLPool_ = (*interface_)->CreateNuDCLPool(
                                                interface_,
                                                0,
                                                CFUUIDGetUUIDBytes(kIOFireWireNuDCLPoolInterfaceID));
    
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::setupNuDCLPool: failed to create NuDCL pool");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    if (logger_) {
        logger_->debug("IsochManager::setupNuDCLPool: NuDCL pool created");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createRemotePort() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochManager::createRemotePort: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Create remote isoch port
    // Note: Remote port is listener if local is talker, and vice versa
    remotePort_ = (*interface_)->CreateRemoteIsochPort(
                                                       interface_,
                                                       !isTalker_,  // opposite of local role
                                                       CFUUIDGetUUIDBytes(kIOFireWireRemoteIsochPortInterfaceID));
    
    if (!remotePort_) {
        if (logger_) {
            logger_->error("IsochManager::createRemotePort: failed to create remote port");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    // Set this instance as the refCon for the port
    (*remotePort_)->SetRefCon((IOFireWireLibIsochPortRef)remotePort_, this);
    
    // Set up callback handlers
    (*remotePort_)->SetGetSupportedHandler(remotePort_, RemotePort_GetSupported_Helper);
    (*remotePort_)->SetAllocatePortHandler(remotePort_, RemotePort_AllocatePort_Helper);
    (*remotePort_)->SetReleasePortHandler(remotePort_, RemotePort_ReleasePort_Helper);
    (*remotePort_)->SetStartHandler(remotePort_, RemotePort_Start_Helper);
    (*remotePort_)->SetStopHandler(remotePort_, RemotePort_Stop_Helper);
    
    if (logger_) {
        logger_->debug("IsochManager::createRemotePort: remote port created");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createLocalPort(IOVirtualRange& bufferRange) {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Get the DCL program
    DCLCommandPtr program = (*nuDCLPool_)->GetProgram(nuDCLPool_);
    if (!program) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: GetProgram returned null");
        }
        return std::unexpected(IOKitError::Error);
    }
    
    // Validate buffer range
    if (!bufferRange.address || !bufferRange.length) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: Invalid buffer range: address={:p}, length={}",
                           (void*)bufferRange.address, bufferRange.length);
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // Check buffer alignment (4-byte alignment required)
    if (bufferRange.address & 0x3) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: Buffer not 4-byte aligned: address={:p}",
                           (void*)bufferRange.address);
        }
        return std::unexpected(IOKitError::NotAligned);
    }
    
    if (logger_) {
        logger_->info("IsochManager::createLocalPort: Creating local port with buffer: address={:p}, length={}",
                      (void*)bufferRange.address, bufferRange.length);
    }
    
    // Create the local port
    localPort_ = (*interface_)->CreateLocalIsochPort(
                                                     interface_,
                                                     isTalker_,
                                                     program,
                                                     0,              // startEvent
                                                     0,              // startState
                                                     0,              // startMask
                                                     nullptr,        // dclProgramRanges
                                                     0,              // dclProgramRangeCount
                                                     &bufferRange,   // bufferRanges - now compatible with system type
                                                     1,              // bufferRangeCount
                                                     CFUUIDGetUUIDBytes(kIOFireWireLocalIsochPortInterfaceID));
    
    if (!localPort_) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: Failed to create local port");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    // Set this instance as the refCon for the port
    (*localPort_)->SetRefCon((IOFireWireLibIsochPortRef)localPort_, this);
    
    
    
    
    // Set the finalize callback
    IOReturn result = (*localPort_)->SetFinalizeCallback(localPort_, PortFinalize_Helper);
    if (result != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("IsochManager::createLocalPort: Failed to set finalize callback: {}", result);
        }
        return std::unexpected(IOKitError(result));
    }
    
    if (logger_) {
        logger_->debug("IsochManager::createLocalPort: Local port created successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createIsochChannel() {
    if (!interface_) {
        if (logger_) {
            logger_->error("IsochManager::createIsochChannel: interface is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (!localPort_ || !remotePort_) {
        if (logger_) {
            logger_->error("IsochManager::createIsochChannel: Ports are not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Calculate packet size for IRM allocations - this should be determined based on audio needs
    const uint32_t irmPacketSize = 72; // 64 bytes for samples + 8 bytes for CIP header
    
    // Create the isoch channel
    isochChannel_ = (*interface_)->CreateIsochChannel(
                                                      interface_,
                                                      true,  // doIRMAllocations
                                                      irmPacketSize,
                                                      kFWSpeedMaximum,
                                                      CFUUIDGetUUIDBytes(kIOFireWireIsochChannelInterfaceID));
    
    if (!isochChannel_) {
        if (logger_) {
            logger_->error("IsochManager::createIsochChannel: Failed to create isoch channel");
        }
        return std::unexpected(IOKitError::Error);
    }
    
    // Set up channel with appropriate talker/listener roles
    IOReturn result;
    if (isTalker_) {
        // We are talker, remote is listener
        if (logger_) {
            logger_->info("IsochManager::createIsochChannel: This is a talker, remote is listener");
        }
        
        result = (*isochChannel_)->AddListener(
                                               isochChannel_,
                                               reinterpret_cast<IOFireWireLibIsochPortRef>(remotePort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochManager::createIsochChannel: Failed to add listener: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
        
        result = (*isochChannel_)->SetTalker(
                                             isochChannel_,
                                             reinterpret_cast<IOFireWireLibIsochPortRef>(localPort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochManager::createIsochChannel: Failed to set talker: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
    } else {
        // We are listener, remote is talker
        if (logger_) {
            logger_->info("IsochManager::createIsochChannel: This is a listener, remote is talker");
        }
        
        result = (*isochChannel_)->AddListener(
                                               isochChannel_,
                                               reinterpret_cast<IOFireWireLibIsochPortRef>(localPort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochManager::createIsochChannel: Failed to add listener: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
        
        result = (*isochChannel_)->SetTalker(
                                             isochChannel_,
                                             reinterpret_cast<IOFireWireLibIsochPortRef>(remotePort_));
        
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochManager::createIsochChannel: Failed to set talker: 0x{:08X}", result);
            }
            return std::unexpected(IOKitError(result));
        }
    }
    
    
    // fix up the DCL program here!
    auto fixupResult = fixupDCLJumpTargets();
    if (!fixupResult) {
        if (logger_) {
            logger_->error("IsochManager::createIsochChannel: Failed to fix up DCL jump targets: {}",
                           static_cast<int>(fixupResult.error()));
        }
        return fixupResult;
    }
    
    logger_->info("IsochManager::createIsochChannel: FIXUP SUCCESSFUL");
    
    
    
    
    // Set this as the refcon for the channel
    (*isochChannel_)->SetRefCon(isochChannel_, this);
    
    if (logger_) {
        logger_->debug("IsochManager::createIsochChannel: Isoch channel created successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createDCLProgram(
                                                               uint32_t cyclesPerSegment,
                                                               uint32_t numSegments,
                                                               uint32_t cycleBufferSize,
                                                               IOVirtualRange& bufferRange) {
    
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Store configuration values
    cyclesPerSegment_ = cyclesPerSegment;
    numSegments_ = numSegments;
    cycleBufferSize_ = cycleBufferSize;
    baseBuffer_ = reinterpret_cast<uint8_t*>(bufferRange.address);
    
    if (logger_) {
        logger_->info("IsochManager::createDCLProgram: cyclesPerSegment={}, numSegments={}, cycleBufferSize={}",
                      cyclesPerSegment_, numSegments_, cycleBufferSize_);
        logger_->info("IsochManager::createDCLProgram: Using buffer range: address={:p}, length={}",
                      (void*)bufferRange.address, bufferRange.length);
    }
    
    // Calculate total buffer size needed for all cycle buffers
    uint32_t totalCyclesBufferSize = cyclesPerSegment_ * numSegments_ * cycleBufferSize_;
    uint32_t overrunBufferSize = cycleBufferSize_; // One additional buffer for overruns
    uint32_t timestampBufferSize = numSegments_ * sizeof(uint32_t); // One timestamp per segment
    
    size_t totalRequiredSize = totalCyclesBufferSize + overrunBufferSize + timestampBufferSize;
    
    if (totalRequiredSize > bufferRange.length) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Buffer too small: needed={}, provided={}",
                           totalRequiredSize, bufferRange.length);
        }
        return std::unexpected(IOKitError::NoSpace);
    }
    
    // Prepare segments vector
    segments_.resize(numSegments_);
    
    // Calculate timestamp buffer location
    timestampBuffer_ = reinterpret_cast<uint32_t*>(
                                                   baseBuffer_ + totalCyclesBufferSize + overrunBufferSize);
    
    // Create segment DCLs with direct buffer reference
    auto result = createSegmentDCLs(bufferRange);
    if (!result) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Failed to create segment DCLs: {}",
                           static_cast<int>(result.error()));
        }
        segments_.clear();
        return result;
    }
    
    // Create overrun DCL
    result = createOverrunDCL(bufferRange);
    if (!result) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Failed to create overrun DCL: {}",
                           static_cast<int>(result.error()));
        }
        segments_.clear();
        return result;
    }
    
    // Create the local port
    result = createLocalPort(bufferRange);
    if (!result) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Failed to create local port: {}",
                           static_cast<int>(result.error()));
        }
        segments_.clear();
        overrunDCL_ = nullptr;
        return result;
    }
    
    // Create the isoch channel
    result = createIsochChannel();
    if (!result) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Failed to create isoch channel: {}",
                           static_cast<int>(result.error()));
        }
        // Local port will be cleaned up in reset()
        segments_.clear();
        overrunDCL_ = nullptr;
        return result;
    }
    
    // Fix up DCL jump targets
    result = fixupDCLJumpTargets();
    if (!result) {
        if (logger_) {
            logger_->error("IsochManager::createDCLProgram: Failed to fix up DCL jump targets: {}",
                           static_cast<int>(result.error()));
        }
        segments_.clear();
        overrunDCL_ = nullptr;
        return result;
    }
    
    // Reset segment position to start
    currentSegment_ = 0;
    
    if (logger_) {
        logger_->info("IsochManager::createDCLProgram: DCL program created successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createSegmentDCLs(IOVirtualRange& bufferRange) {
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::createSegmentDCLs: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (logger_) {
        logger_->debug("IsochManager::createSegmentDCLs: Creating DCLs for {} segments with {} cycles each",
                       numSegments_, cyclesPerSegment_);
        logger_->debug("IsochManager::createSegmentDCLs: Base buffer={:p}, timestamp buffer={:p}",
                       (void*)baseBuffer_, (void*)timestampBuffer_);
    }
    
    // Create DCLs for each segment
    for (uint32_t segment = 0; segment < numSegments_; segment++) {
        // Create a mutable bag for update lists
        segments_[segment].updateBag = CFSetCreateMutable(nullptr, 0, nullptr);
        if (!segments_[segment].updateBag) {
            if (logger_) {
                logger_->error("IsochManager::createSegmentDCLs: Failed to create update bag for segment {}", segment);
            }
            return std::unexpected(IOKitError::NoMemory);
        }
        
        // For each cycle in the segment
        for (uint32_t cycle = 0; cycle < cyclesPerSegment_; cycle++) {
            // Calculate buffer offset directly
            uint32_t bufferOffset = (segment * cyclesPerSegment_ + cycle) * cycleBufferSize_;
            
            // Create virtual range directly from main buffer
            IOVirtualRange range;
            range.address = bufferRange.address + bufferOffset;
            range.length = cycleBufferSize_;
            
            // Allocate receive packet DCL
            NuDCLRef dcl = (*nuDCLPool_)->AllocateReceivePacket(
                                                                nuDCLPool_,
                                                                segments_[segment].updateBag,
                                                                4,  // Header size in quadlets (4 bytes each)
                                                                1,  // Number of ranges
                                                                &range);
            
            if (!dcl) {
                if (logger_) {
                    logger_->error("IsochManager::createSegmentDCLs: Failed to allocate receive packet DCL");
                }
                return std::unexpected(IOKitError::NoMemory);
            }
            
            // Set DCL flags
            (*nuDCLPool_)->SetDCLFlags(dcl, kNuDCLDynamic | kNuDCLUpdateBeforeCallback);
            
            // Set refcon
            (*nuDCLPool_)->SetDCLRefcon(dcl, this);
            
            // Special handling for first DCL in segment
            if (cycle == 0) {
                segments_[segment].startDCL = dcl;
                
                // Set timestamp pointer directly to the timestamp buffer
                (*nuDCLPool_)->SetDCLTimeStampPtr(dcl, &timestampBuffer_[segment]);
                
                if (logger_) {
                    logger_->debug("IsochManager::createSegmentDCLs: Start DCL for segment {}: {:p}",
                                   segment, (void*)dcl);
                }
            }
            
            // Special handling for last DCL in segment
            if (cycle == cyclesPerSegment_ - 1) {
                segments_[segment].endDCL = dcl;
                
                // Set update list
                (*nuDCLPool_)->SetDCLUpdateList(dcl, segments_[segment].updateBag);
                
                // Set callback
                (*nuDCLPool_)->SetDCLCallback(dcl, DCLComplete_Helper);
                
                if (logger_) {
                    logger_->debug("IsochManager::createSegmentDCLs: End DCL for segment {}: {:p}",
                                   segment, (void*)dcl);
                }
            }
        }
        
        // Mark segment as not active initially
        segments_[segment].isActive = false;
        
        if (logger_) {
            logger_->debug("IsochManager::createSegmentDCLs: Created DCLs for segment {}", segment);
        }
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::createOverrunDCL(IOVirtualRange& bufferRange) {
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::createOverrunDCL: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Calculate overrun buffer address
    uint32_t totalCyclesBufferSize = cyclesPerSegment_ * numSegments_ * cycleBufferSize_;
    
    // Create range for overrun buffer
    IOVirtualRange range;
    range.address = bufferRange.address + totalCyclesBufferSize;
    range.length = cycleBufferSize_;
    
    if (logger_) {
        logger_->debug("IsochManager::createOverrunDCL: Overrun buffer at address={:p}, length={}",
                       (void*)range.address, range.length);
    }
    
    // Create overrun DCL
    overrunDCL_ = (*nuDCLPool_)->AllocateReceivePacket(
                                                       nuDCLPool_,
                                                       nullptr,  // No update bag for overrun DCL
                                                       4,        // Header size in quadlets
                                                       1,        // Single range
                                                       &range);
    
    if (!overrunDCL_) {
        if (logger_) {
            logger_->error("IsochManager::createOverrunDCL: Failed to allocate overrun DCL");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    // Set DCL flags
    (*nuDCLPool_)->SetDCLFlags(overrunDCL_, kNuDCLDynamic | kNuDCLUpdateBeforeCallback);
    
    // Set refcon
    (*nuDCLPool_)->SetDCLRefcon(overrunDCL_, this);
    
    // Set callback
    (*nuDCLPool_)->SetDCLCallback(overrunDCL_, DCLOverrun_Helper);
    
    //    (*nuDCLPool_)->PrintProgram(nuDCLPool_);
    
    if (logger_) {
        logger_->debug("IsochManager::createOverrunDCL: Created overrun DCL: {:p}", (void*)overrunDCL_);
    }
    
    return {};
}

std::expected<void, IOKitError> IsochManager::fixupDCLJumpTargets() {
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::fixupDCLJumpTargets: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (!localPort_) {
        if (logger_) {
            logger_->error("IsochManager::fixupDCLJumpTargets: Local port is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (segments_.empty() || !overrunDCL_) {
        if (logger_) {
            logger_->error("IsochManager::fixupDCLJumpTargets: Segments or overrun DCL not created");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (logger_) {
        logger_->debug("IsochManager::fixupDCLJumpTargets: Fixing up DCL jump targets for {} segments", 
                     segments_.size());
    }
    
    // Fix up jump targets - each segment's last DCL jumps to the next segment
    for (size_t i = 0; i < segments_.size(); i++) {
        // Get the end DCL of the current segment
        NuDCLRef endDCL = segments_[i].endDCL;
        if (!endDCL) {
            if (logger_) {
                logger_->error("IsochManager::fixupDCLJumpTargets: End DCL for segment {} is null", i);
            }
            return std::unexpected(IOKitError::BadArgument);
        }
        
        // Set the branch target
        NuDCLRef targetDCL;
        if (i != (segments_.size() - 1)) {
            // Not the last segment, jump to the next segment's start
            targetDCL = segments_[i + 1].startDCL;
            if (logger_) {
                logger_->debug("IsochManager::fixupDCLJumpTargets: Segment {} jumps to segment {}", 
                               i, i + 1);
            }
        } else {
            // Last segment, jump to the overrun DCL
            targetDCL = overrunDCL_;
            if (logger_) {
                logger_->debug("IsochManager::fixupDCLJumpTargets: Last segment {} jumps to overrun DCL", i);
            }
        }
        
        if (!targetDCL) {
            if (logger_) {
                logger_->error("IsochManager::fixupDCLJumpTargets: Target DCL is null for segment {}", i);
            }
            return std::unexpected(IOKitError::BadArgument);
        }
        
        // Set the branch
        (*nuDCLPool_)->SetDCLBranch(endDCL, targetDCL);
        
        // Send notification
        IOReturn result = notifyJumpUpdate(endDCL);
        if (result != kIOReturnSuccess) {
            if (logger_) {
                logger_->error("IsochManager::fixupDCLJumpTargets: Notify failed for segment {}: 0x{:08X}", 
                             i, result);
            }
            // Continue despite error - not fatal
        }
    }
    
    // CRITICAL: Set the overrun DCL to jump back to the first segment
    if (overrunDCL_ && !segments_.empty() && segments_[0].startDCL) {
        (*nuDCLPool_)->SetDCLBranch(overrunDCL_, segments_[0].startDCL);
        
        // Add clear logging for this critical step
        logger_->info("IsochManager: Set overrun DCL {:p} to branch back to segment 0 start DCL {:p}", 
                     (void*)overrunDCL_, (void*)segments_[0].startDCL);
        
        // Send notification for overrun DCL
        IOReturn result = (*localPort_)->Notify(
            localPort_,
            kFWNuDCLModifyJumpNotification,
            (void**) &overrunDCL_,  // Use direct cast like in UniversalReceiver
            1);
            
        if (result != kIOReturnSuccess) {
            logger_->error("IsochManager::fixupDCLJumpTargets: Notify failed for overrun DCL: 0x{:08X}", 
                         result);
            // Continue despite error - not fatal
        } else {
            logger_->info("IsochManager: Successfully notified overrun DCL branch update");
        }
    } else {
        logger_->error("IsochManager: Cannot set overrun DCL branch - missing required DCLs");
    }

    logger_->info("DCL Program Flow: segment0 → segment1 → overrun → segment0");
    logger_->info("Segment Counter Initialization: currentSegment_ = 0");
    
    // Reset the current segment to 0
    currentSegment_ = 0;
    
    if (logger_) {
        logger_->debug("IsochManager::fixupDCLJumpTargets: Fixed up all DCL jump targets successfully");
    }
    
    return {};
}

IOReturn IsochManager::notifyJumpUpdate(NuDCLRef dcl) {
    if (!localPort_ || !dcl) {
        return kIOReturnBadArgument;
    }

    // CRITICAL: Must pass the ADDRESS OF the DCL pointer variable
    // Not just a copy of the pointer itself
    void** dclPtrAddr = (void**)&dcl;  // Get address of the DCL pointer
    
    return (*localPort_)->Notify(
        localPort_,
        kFWNuDCLModifyJumpNotification,
        dclPtrAddr,  // Pass address of the pointer, not a temporary
        1);
}

std::expected<void, IOKitError> IsochManager::configure(IOFWSpeed speed, uint32_t channel) {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochManager::configure: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (running_) {
        if (logger_) {
            logger_->error("IsochManager::configure: Cannot configure while running");
        }
        return std::unexpected(IOKitError::Busy);
    }
    
    configuredSpeed_ = speed;
    configuredChannel_ = channel;
    
    if (logger_) {
        logger_->info("IsochManager::configure: Set speed={}, channel={}",
                      static_cast<int>(speed), channel);
    }
    
    return {};
}

std::expected<DCLCommandPtr, IOKitError> IsochManager::getProgram() const {
    if (!nuDCLPool_) {
        if (logger_) {
            logger_->error("IsochManager::getProgram: NuDCL pool is null");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    DCLCommandPtr program = (*nuDCLPool_)->GetProgram(nuDCLPool_);
    if (!program) {
        if (logger_) {
            logger_->error("IsochManager::getProgram: GetProgram returned null");
        }
        return std::unexpected(IOKitError::Error);
    }
    
    return program;
}

std::expected<uint32_t*, IOKitError> IsochManager::getTimestampPtr(uint32_t segment) const {
    if (!initialized_ || !timestampBuffer_) {
        if (logger_) {
            logger_->error("IsochManager::getTimestampPtr: Not initialized or no timestamp buffer");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (segment >= numSegments_) {
        if (logger_) {
            logger_->error("IsochManager::getTimestampPtr: Invalid segment {}", segment);
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    return &timestampBuffer_[segment];
}

std::expected<uint32_t, IOKitError> IsochManager::getActiveChannel() const {
    if (!initialized_) {
        if (logger_) {
            logger_->error("IsochManager::getActiveChannel: Not initialized");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    return activeChannel_;
}



std::expected<void, IOKitError> IsochManager::handleSegmentComplete(uint32_t segment) {
    if (segment >= segments_.size()) {
        if (logger_) {
            logger_->error("IsochManager::handleSegmentComplete: Invalid segment number: {}", segment);
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // Mark segment as inactive
    segments_[segment].isActive = false;
    
    if (logger_) {
        logger_->debug("IsochManager::handleSegmentComplete: Segment {} complete", segment);
    }
    
    // Notify callback with proper refcon
    if (dclCompleteCallback_) {
        dclCompleteCallback_(segment, dclCompleteRefCon_);
    }
    
    return {};
}

bool IsochManager::isValidSegment(uint32_t segment) const {
    return segment < segments_.size();
}

NuDCLRef IsochManager::getDCLForSegment(uint32_t segment, uint32_t cycle) const {
    if (!isValidSegment(segment) || cycle >= cyclesPerSegment_) {
        return nullptr;
    }
    
    if (cycle == 0) {
        return segments_[segment].startDCL;
    } else if (cycle == cyclesPerSegment_ - 1) {
        return segments_[segment].endDCL;
    } else {
        // For middle DCLs, we'd need to maintain an array of all DCLs
        // This is a limitation of the current implementation
        return nullptr;
    }
}

// Static callback handlers
IOReturn IsochManager::RemotePort_GetSupported_Helper(
                                                      IOFireWireLibIsochPortRef interface,
                                                      IOFWSpeed *outMaxSpeed,
                                                      UInt64 *outChanSupported) {
    
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Use stored speed from configuration
    *outMaxSpeed = manager->configuredSpeed_;
    
    // Handle channel selection based on configuration
    uint32_t channel = manager->configuredChannel_;
    if (channel == kAnyAvailableIsochChannel) {
        // Allow FireWireFamily to determine an available channel
        // Enable all channels except 0 (which is reserved)
        *outChanSupported = ~1ULL;
    } else {
        // Use a specific channel - create a mask with only that bit set
        *outChanSupported = (((UInt64)0x80000000 << 32 | (UInt64)0x00000000) >> channel);
    }
    
    if (manager->logger_) {
        manager->logger_->debug("RemotePort_GetSupported: speed={}, channel={}",
                                static_cast<int>(*outMaxSpeed),
                                (channel == kAnyAvailableIsochChannel) ?
                                "any" : std::to_string(channel));
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochManager::RemotePort_AllocatePort_Helper(
                                                      IOFireWireLibIsochPortRef interface,
                                                      IOFWSpeed maxSpeed,
                                                      UInt32 channel) {
    
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Store the allocated channel for future reference
    manager->activeChannel_ = channel;
    
    if (manager->logger_) {
        manager->logger_->debug("RemotePort_AllocatePort: speed={}, channel={}",
                                static_cast<int>(maxSpeed), channel);
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochManager::RemotePort_ReleasePort_Helper(
                                                     IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Reset active channel
    manager->activeChannel_ = kAnyAvailableIsochChannel;
    
    if (manager->logger_) {
        manager->logger_->debug("RemotePort_ReleasePort called");
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochManager::RemotePort_Start_Helper(
                                               IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Set the running state
    manager->running_ = true;
    
    if (manager->logger_) {
        manager->logger_->debug("RemotePort_Start called");
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochManager::RemotePort_Stop_Helper(
                                              IOFireWireLibIsochPortRef interface) {
    
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>((*interface)->GetRefCon(interface));
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Clear the running state
    manager->running_ = false;
    
    if (manager->logger_) {
        manager->logger_->debug("RemotePort_Stop called");
    }
    
    return kIOReturnSuccess;
}

IOReturn IsochManager::PortFinalize_Helper(void* refcon) {
    // Get the IsochManager instance from the refcon
    auto manager = static_cast<IsochManager*>(refcon);
    if (!manager) {
        return kIOReturnBadArgument;
    }
    
    // Handle port finalization
    manager->handlePortFinalize();
    
    return kIOReturnSuccess;
}



// Static callback handler
// TODO: make it static?
void IsochManager::DCLComplete_Helper(void* refcon, NuDCLRef dcl) {
    // This just forwards to the instance method, ignoring the dcl parameter
    auto manager = static_cast<IsochManager*>(refcon);
    if (manager) {
        manager->handleDCLComplete(nullptr); // Pass nullptr to indicate we don't care which DCL
    }
}

void IsochManager::DCLOverrun_Helper(void* refcon, NuDCLRef dcl) {
    // Get static logger for emergency debugging
    auto staticLogger = spdlog::default_logger();
    staticLogger->critical("OVERRUN_CALLBACK: ENTERED with refcon={:p}, dcl={:p}", refcon, (void*)dcl);
    
    // This is just for debugging now - no actual overrun handling yet
    auto manager = static_cast<IsochManager*>(refcon);
    if (!manager) {
        staticLogger->critical("OVERRUN_CALLBACK: NULL MANAGER REFCON!");
        return;
    }
    
    staticLogger->critical("OVERRUN_CALLBACK: Found manager at {:p}", (void*)manager);
    staticLogger->critical("OVERRUN_CALLBACK: COMPLETED");
}

// void IsochManager::DCLOverrun_Helper(void* refcon, NuDCLRef dcl) {
//     // Get the IsochManager instance from the refcon
//     auto manager = static_cast<IsochManager*>(refcon);
//     if (manager) {
//         manager->handleDCLOverrun();
//     }
// }

std::expected<uint32_t, IOKitError> IsochManager::getSegmentTimestamp(uint32_t segment) const {
    if (!initialized_ || !timestampBuffer_) {
        if (logger_) {
            logger_->error("IsochManager::getSegmentTimestamp: Not initialized or no timestamp buffer");
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (segment >= numSegments_) {
        if (logger_) {
            logger_->error("IsochManager::getSegmentTimestamp: Invalid segment {}", segment);
        }
        return std::unexpected(IOKitError::BadArgument);
    }
    
    return timestampBuffer_[segment];
}


void IsochManager::handleDCLComplete(NuDCLRef dcl) {
    // Get segment and timestamps without locks
    uint32_t segment = currentSegment_.load(std::memory_order_relaxed);
    uint32_t timestamp = timestampBuffer_ ? timestampBuffer_[segment] : 0;
    
    // CRITICAL: Do minimal local work first without callbacks
    logger_->debug("Processing segment {}", segment);
    
    // Calculate total segments and previous segment
    uint32_t numSegments = segments_.size();
    uint32_t prevSegment = (segment == 0) ? (numSegments - 1) : (segment - 1);
    
    // dclCompleteCallback_ is removed - beginning to simplify callback chain
    // if (dclCompleteCallback_) {
    //     try {
    //         // Call a minimal callback function that just logs
    //         dclCompleteCallback_(segment, dclCompleteRefCon_);
    //     } catch (const std::exception& e) {
    //         logger_->error("Exception in callback: {}", e.what());
    //     }
    // }

    // FIRST: Do minimal buffer processing
    processSegmentData(segment, timestamp);
    
    // SECOND: Update branch targets EXACTLY as original
    if (segments_.size() > 0 && nuDCLPool_ && overrunDCL_) {
        // Current segment's end DCL → overrun DCL
        (*nuDCLPool_)->SetDCLBranch(segments_[segment].endDCL, overrunDCL_);
        (*localPort_)->Notify(
            localPort_,
            kFWNuDCLModifyJumpNotification,
            (void**) &segments_[segment].endDCL,
            1);
        
        // Previous segment's end DCL → current segment's start DCL
        (*nuDCLPool_)->SetDCLBranch(
            segments_[prevSegment].endDCL,
            segments_[segment].startDCL);
        (*localPort_)->Notify(
            localPort_,
            kFWNuDCLModifyJumpNotification,
            (void**) &segments_[prevSegment].endDCL,
            1);
    }
    
    // THIRD: Update segment counter AFTER branch updates
    currentSegment_.store((segment + 1) % numSegments, std::memory_order_relaxed);
    

}

// Simple direct access to buffer data - revised
void IsochManager::processSegmentData(uint32_t segment, uint32_t timestamp) {
    // Skip if buffer is not initialized
    if (!baseBuffer_ || segment >= segments_.size()) {
        logger_->warn("Cannot process segment {}: invalid buffer state", segment);
        return;
    }
    
    // Get direct access to segment buffer
    uint8_t* bufferBase = baseBuffer_ + (segment * cyclesPerSegment_ * cycleBufferSize_);
    
    // Log the buffer pointer but don't do complex processing here
    logger_->debug("Segment {} buffer at {:p}, timestamp: {}", 
                 segment, (void*)bufferBase, timestamp);
    
    // Store that this was the last segment processed
    processedSegments_.store(segment, std::memory_order_release);
    processedTimestamps_.store(timestamp, std::memory_order_release);
    
    // Set hasData flag based on simple check
    // For example, see if first quadlet indicates valid data
    bool hasData = false;
    if (bufferBase) {
        uint32_t* firstQuadlet = reinterpret_cast<uint32_t*>(bufferBase);
        uint32_t payloadLength = (*firstQuadlet & 0xFFFF0000) >> 16;
        hasData = (payloadLength > 0);
        
        // Log if we found data
        if (hasData) {
            logger_->debug("Segment {} has data: payload length={}", segment, payloadLength);
        }
    }
    
    // Track if we've seen data
    hasReceivedData_.store(hasData, std::memory_order_release);
}




void IsochManager::handleDCLOverrun() {
    if (logger_) {
        logger_->warn("IsochManager::handleDCLOverrun: DCL overrun detected");
    }
    
    // Notify callback with proper refcon
    if (dclOverrunCallback_) {
        dclOverrunCallback_(dclOverrunRefCon_);
    }
}

void IsochManager::handlePortFinalize() {
    if (logger_) {
        logger_->debug("IsochManager::handlePortFinalize: Port finalize called");
    }
    
    finalized_ = true;
}

} // namespace Isoch
} // namespace FWA






=== src/Isoch/core/AmdtpTransmitStreamProcessor.cpp ===
#include "Isoch/core/AmdtpTransmitStreamProcessor.hpp"
#include <iostream>
#include <chrono>
#include <cstring>
#include <spdlog/spdlog.h>
#include <thread> // Keep for logger thread

namespace AVS {

AmdtpTransmitStreamProcessor::AmdtpTransmitStreamProcessor(std::shared_ptr<spdlog::logger> logger)
: audioBuffer_(RING_BUFFER_SIZE, logger), // Initialize RingBuffer with logger
  logger_(logger)
{
#if DEBUG_LOGGING
    logger_->info("[AmdtpTransmitStreamProcessor] Initialized Simplified (size: {} bytes)", RING_BUFFER_SIZE);
    startSampleRateLogger(); // Keep logger thread if desired for debug
#endif
}

AmdtpTransmitStreamProcessor::~AmdtpTransmitStreamProcessor() {
    // RAUL::RingBuffer cleans up automatically.
#if DEBUG_LOGGING
    logger_->info("[AmdtpTransmitStreamProcessor] Simplified Destroyed.");
#endif
}

void AmdtpTransmitStreamProcessor::pushAudioData(const void* buff, unsigned int buffBytesSize) {
    if (!buff || buffBytesSize == 0) {
        return;
    }

    // Simplified Direct Ring Buffer Write
    size_t bytesToWrite = buffBytesSize;
    const uint8_t* bufferPtr = static_cast<const uint8_t*>(buff);

    uint32_t written = audioBuffer_.write(bytesToWrite, bufferPtr);

    if (written < bytesToWrite) {
        // Buffer was full or couldn't accept all data at once.
        // The RingBuffer's write() only writes if the *entire* size fits.
        overflowWriteAttempts_.fetch_add(1, std::memory_order_relaxed);
#if DEBUG_LOGGING
         // Log periodically to avoid spamming
         static auto lastWarnTime = std::chrono::steady_clock::now();
         auto now = std::chrono::steady_clock::now();
         if (now - lastWarnTime > std::chrono::seconds(1)) {
             logger_->warn("[pushAudioData] Ring buffer full, couldn't write {} bytes. Available space: {}. Attempts: {}",
                          bytesToWrite, audioBuffer_.write_space(), overflowWriteAttempts_.load());
             lastWarnTime = now;
         }
#endif
        // Data was dropped because it didn't fit
    } else {
        // Successfully wrote the data
        // Assuming 32-bit PCM data as input based on original code context
        size_t samplesWritten = written / sizeof(int32_t);
        totalPushedSamples_.fetch_add(samplesWritten, std::memory_order_relaxed);
        samplesInBuffer_.fetch_add(samplesWritten, std::memory_order_release);
    }
}

void AmdtpTransmitStreamProcessor::startSampleRateLogger() {
#if DEBUG_LOGGING
    std::thread([this]() {
        using namespace std::chrono;
        auto lastTime = steady_clock::now();
        uint64_t lastSampleCount = totalPushedSamples_.load(std::memory_order_relaxed);
        size_t lastOverflowCount = overflowWriteAttempts_.load(std::memory_order_relaxed);
        while (true) { // Consider adding a proper stop mechanism if needed
            std::this_thread::sleep_for(seconds(2)); // Log less frequently
            auto now = steady_clock::now();
            uint64_t currentSampleCount = totalPushedSamples_.load(std::memory_order_relaxed);
            size_t currentOverflowCount = overflowWriteAttempts_.load(std::memory_order_relaxed);

            double elapsedSec = duration_cast<duration<double>>(now - lastTime).count();
            uint64_t samplesInInterval = currentSampleCount - lastSampleCount;
            size_t overflowsInInterval = currentOverflowCount - lastOverflowCount;
            double samplesPerSecond = (elapsedSec > 0) ? (samplesInInterval / elapsedSec) : 0.0;
            size_t currentSamplesBuffered = samplesInBuffer_.load(std::memory_order_relaxed);

            logger_->debug("[ProcessorStats] Pushed ~{:.0f} samples/sec. CurrentBuffered: {}. OverflowWrites: {}",
                         samplesPerSecond, currentSamplesBuffered, overflowsInInterval);

            lastSampleCount = currentSampleCount;
            lastOverflowCount = currentOverflowCount;
            lastTime = now;
        }
    }).detach();
#endif
}

} // namespace FWA



=== src/Isoch/core/IsochTransportManager.cpp ===
#include "Isoch/core/IsochTransportManager.hpp"
#include <unistd.h>
#include <spdlog/spdlog.h>

namespace FWA {
namespace Isoch {

IsochTransportManager::IsochTransportManager(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)) {
    if (logger_) {
        logger_->debug("IsochTransportManager created");
    }
}

IsochTransportManager::~IsochTransportManager() {
    if (state_ != State::Stopped) {
        if (logger_) {
            logger_->warn("IsochTransportManager destroyed while not stopped");
        }
    }
}

std::expected<void, IOKitError> IsochTransportManager::start(IOFireWireLibIsochChannelRef channel) {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (state_ != State::Stopped) {
        if (logger_) {
            logger_->error("IsochTransportManager::start: Invalid state: {}",
                         static_cast<int>(state_.load()));
        }
        return std::unexpected(IOKitError::Busy);
    }
    
    // Change state to starting
    state_ = State::Starting;
    finalizeCallbackCalled_ = false;
    
    // Prepare for start
    auto result = prepareStart();
    if (!result) {
        state_ = State::Stopped;
        return result;
    }
    
    // Allocate channel
    IOReturn ret = (*channel)->AllocateChannel(channel);
    if (ret != kIOReturnSuccess) {
        state_ = State::Stopped;
        if (logger_) {
            logger_->error("IsochTransportManager::start: Failed to allocate channel: 0x{:08X}", ret);
        }
        return std::unexpected(IOKitError(ret));
    }
    
    if (logger_) {
        logger_->info("IsochTransportManager::start: Channel allocated successfully");
    }
    
    // Start the channel
    ret = (*channel)->Start(channel);
    if (ret != kIOReturnSuccess) {
        // Clean up allocated channel
        (*channel)->ReleaseChannel(channel);
        state_ = State::Stopped;
        if (logger_) {
            logger_->error("IsochTransportManager::start: Failed to start channel: 0x{:08X}", ret);
        }
        return std::unexpected(IOKitError(ret));
    }
    
    // Change state to running
    state_ = State::Running;
    
    if (logger_) {
        logger_->info("IsochTransportManager::start: Transport started successfully");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochTransportManager::stop(IOFireWireLibIsochChannelRef channel) {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(stateMutex_);
    
    if (state_ != State::Running) {
        if (logger_) {
            logger_->error("IsochTransportManager::stop: Invalid state: {}",
                         static_cast<int>(state_.load()));
        }
        return std::unexpected(IOKitError::NotReady);
    }
    
    // Change state to stopping
    state_ = State::Stopping;
    
    // Stop the channel
    IOReturn ret = (*channel)->Stop(channel);
    if (ret != kIOReturnSuccess) {
        if (logger_) {
            logger_->error("IsochTransportManager::stop: Failed to stop channel: 0x{:08X}", ret);
        }
        // Don't return error, continue with cleanup
    }
    
    // Release the channel
    (*channel)->ReleaseChannel(channel);
    
    // Finish stop
    auto result = finishStop();
    if (!result) {
        return result;
    }
    
    // Wait for finalize callback if it hasn't been called yet
    int waitCount = 0;
    const int maxWaitCycles = 100; // Maximum wait time = 100ms
    
    while (!finalizeCallbackCalled_ && waitCount < maxWaitCycles) {
        usleep(1000); // 1ms sleep
        waitCount++;
    }
    
    if (!finalizeCallbackCalled_ && waitCount >= maxWaitCycles) {
        if (logger_) {
            logger_->warn("IsochTransportManager::stop: Finalize callback not called after {}ms", waitCount);
        }
    }
    
    // Change state to stopped regardless of finalize callback
    state_ = State::Stopped;
    
    if (logger_) {
        logger_->info("IsochTransportManager::stop: Transport stopped successfully");
    }
    
    return {};
}

void IsochTransportManager::handleFinalize() {
    if (logger_) {
        logger_->debug("IsochTransportManager::handleFinalize called");
    }
    
    // Set flag to indicate finalize callback was called
    finalizeCallbackCalled_ = true;
    
    // Call user-provided finalize callback with refcon
    if (finalizeCallback_) {
        finalizeCallback_(finalizeRefCon_);
    }
}

std::expected<void, IOKitError> IsochTransportManager::prepareStart() {
    // This can be extended with implementation-specific operations
    // before starting the transport
    
    if (logger_) {
        logger_->debug("IsochTransportManager::prepareStart: Preparing transport start");
    }
    
    return {};
}

std::expected<void, IOKitError> IsochTransportManager::finishStop() {
    // This can be extended with implementation-specific operations
    // after stopping the transport
    
    if (logger_) {
        logger_->debug("IsochTransportManager::finishStop: Finishing transport stop");
    }
    
    return {};
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/ReceiverFactory.cpp ===
#include "Isoch/core/ReceiverFactory.hpp"
#include <spdlog/spdlog.h>

namespace FWA {
namespace Isoch {

// New method that accepts a complete ReceiverConfig directly
std::shared_ptr<AmdtpReceiver> ReceiverFactory::createStandardReceiver(const ReceiverConfig& config) {
    // Create and return receiver directly with provided config
    return AmdtpReceiver::create(config);
}

std::shared_ptr<AmdtpReceiver> ReceiverFactory::createStandardReceiver(
    std::shared_ptr<spdlog::logger> logger,
    uint32_t cyclesPerSegment,
    uint32_t numSegments,
    uint32_t cycleBufferSize) {
    
    // Create configuration with standard settings, using new packet-based parameters
    ReceiverConfig config;
    config.logger = logger ? logger : spdlog::default_logger();
    
    // Convert old parameters to new packet-based configuration
    // This maintains backward compatibility with existing code
    config.numGroups = numSegments;
    config.packetsPerGroup = cyclesPerSegment;
    config.packetDataSize = cycleBufferSize;
    config.callbackGroupInterval = 1; // Default to callback every group
    
    config.timeout = 1000; // 1 second timeout
    config.doIRMAllocations = true;
    config.irmPacketSize = 72; // Default for audio (64 bytes + 8 bytes CIP header)
    
    // Create and return receiver
    return AmdtpReceiver::create(config);
}

std::shared_ptr<AmdtpReceiver> ReceiverFactory::createHighPerformanceReceiver(
    std::shared_ptr<spdlog::logger> logger) {
    
    // Create configuration with high-performance settings
    ReceiverConfig config;
    config.logger = logger ? logger : spdlog::default_logger();
    
    // High-performance parameters
    config.numGroups = 8;           // More groups
    config.packetsPerGroup = 16;    // More packets per group
    config.packetDataSize = 1024;   // Larger packets
    config.callbackGroupInterval = 2; // Callback every other group for efficiency
    
    config.timeout = 2000; // 2 second timeout (more tolerant)
    config.doIRMAllocations = true;
    config.irmPacketSize = 144; // Double size for high-bandwidth (128 bytes + 16 bytes overhead)
    
    // Create and return receiver
    return AmdtpReceiver::create(config);
}

std::shared_ptr<AmdtpReceiver> ReceiverFactory::createLowLatencyReceiver(
    std::shared_ptr<spdlog::logger> logger) {
    
    // Create configuration with low-latency settings
    ReceiverConfig config;
    config.logger = logger ? logger : spdlog::default_logger();
    
    // Low-latency parameters
    config.numGroups = 2;          // Fewer groups
    config.packetsPerGroup = 4;    // Fewer packets per group
    config.packetDataSize = 512;   // Standard size
    config.callbackGroupInterval = 1; // Callback every group for low latency
    
    config.timeout = 500;  // 500ms timeout (more sensitive)
    config.doIRMAllocations = true;
    config.irmPacketSize = 72; // Standard size
    
    // Create and return receiver
    return AmdtpReceiver::create(config);
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochPacketProvider.cpp ===
#include "Isoch/core/IsochPacketProvider.hpp"
#include <CoreServices/CoreServices.h> // For endian swap
#include <cstring> // For memcpy/memmove/bzero
#include <algorithm> // For std::min
#include <spdlog/spdlog.h>
// Include header with AM824 constants if needed
#include "Isoch/core/TransmitterTypes.hpp" // Assuming constants are here

namespace FWA {
namespace Isoch {

// --- UPDATED Constructor ---
IsochPacketProvider::IsochPacketProvider(std::shared_ptr<spdlog::logger> logger, size_t ringBufferSize)
    : logger_(std::move(logger)),
      audioBuffer_(ringBufferSize, logger_) // Initialize OWN buffer
{
    if(logger_) logger_->debug("IsochPacketProvider created with RingBuffer size {}", ringBufferSize);
    reset();
}

IsochPacketProvider::~IsochPacketProvider() {
     if(logger_) logger_->debug("IsochPacketProvider destroyed");
}

void IsochPacketProvider::reset() {
    audioBuffer_.reset(); // Reset OWN buffer
    isInitialized_ = false;
    underrunCount_ = 0;
    totalPushedBytes_ = 0;
    totalPulledBytes_ = 0;
    overflowWriteAttempts_ = 0;
     if(logger_) logger_->info("IsochPacketProvider reset");
}

// --- ADDED Implementation for pushAudioData ---
bool IsochPacketProvider::pushAudioData(const void* buffer, size_t bufferSizeInBytes) {
    if (!buffer || bufferSizeInBytes == 0) return false;

    constexpr size_t sampleSize = sizeof(int32_t); // Assuming 32-bit host PCM
    if (bufferSizeInBytes % sampleSize != 0) {
        if(logger_) logger_->warn("pushAudioData: Received data size {} not multiple of sample size {}. Ignoring.", bufferSizeInBytes, sampleSize);
        return false;
    }

    // Write to OWN ring buffer
    size_t written = audioBuffer_.write(bufferSizeInBytes, buffer);
    totalPushedBytes_ += written;

    if (written < bufferSizeInBytes) {
         overflowWriteAttempts_++;
         // Log periodically
         static auto lastWarnTime = std::chrono::steady_clock::now();
         auto now = std::chrono::steady_clock::now();
         if (now - lastWarnTime > std::chrono::seconds(1)) {
              if(logger_) logger_->warn("[pushAudioData] Ring buffer full, couldn't write {} bytes. Available space: {}. Attempts: {}",
                          bufferSizeInBytes, audioBuffer_.write_space(), overflowWriteAttempts_.load());
             lastWarnTime = now;
         }
         return false; // Indicate not all data was accepted
    }

    // Check if initial fill target is met
    if (!isInitialized_) {
        size_t fillTargetBytes = (audioBuffer_.capacity() * INITIAL_FILL_TARGET_PERCENT) / 100;
        if (audioBuffer_.read_space() >= fillTargetBytes) {
            isInitialized_ = true;
             if(logger_) logger_->info("IsochPacketProvider: Ring buffer initial fill target reached ({} bytes). Ready for streaming.", audioBuffer_.read_space());
        }
    }
    return true;
}
// --- END pushAudioData ---


// --- fillPacketData implementation (mostly unchanged, reads from own buffer) ---
PreparedPacketData IsochPacketProvider::fillPacketData(
    uint8_t* targetBuffer,
    size_t targetBufferSize,
    const TransmitPacketInfo& info)
{
//    if(logger_) logger_->debug("fillPacketData called: Seg={}, Pkt={}, AbsPkt={}, TargetSize={}",
//                              info.segmentIndex, info.packetIndexInGroup, info.absolutePacketIndex, targetBufferSize);

    PreparedPacketData result;
    result.dataPtr = targetBuffer;
    result.dataLength = 0;
    result.generatedSilence = true;

    if (!targetBuffer || targetBufferSize == 0 || (targetBufferSize % sizeof(int32_t) != 0)) {
         if(logger_) logger_->error("fillPacketData: Invalid target buffer, size ({}), or size not multiple of 4.", targetBufferSize);
         return result;
    }

    // --- Check available space in OWN buffer ---
    size_t availableBeforeRead = audioBuffer_.read_space();
    if(logger_) logger_->trace("  Available read space before pull: {} bytes", availableBeforeRead);

    // --- Read data from OWN buffer ---
    size_t bytesRead = audioBuffer_.read(targetBufferSize, targetBuffer);

    if (bytesRead == targetBufferSize) {
        // --- SUCCESSFUL READ - FORMAT IN PLACE ---
        if(logger_) logger_->debug("  Successfully pulled {} bytes. Formatting to AM824...", bytesRead);

        int32_t* samplesPtr = reinterpret_cast<int32_t*>(targetBuffer);
        size_t numSamples = targetBufferSize / sizeof(int32_t);

        // Perform the AM824 conversion and Big Endian swap IN PLACE
        for (size_t i = 0; i < numSamples; ++i) {
            int32_t sample = samplesPtr[i];
            sample &= 0x00FFFFFF;
            uint32_t am824Sample = (AM824_LABEL << LABEL_SHIFT) | sample; // Assumes constants defined
            samplesPtr[i] = OSSwapHostToBigInt32(am824Sample);
        }
         if(logger_) logger_->trace("  AM824 formatting complete.");

        result.generatedSilence = false;
        result.dataLength = bytesRead;
        totalPulledBytes_ += bytesRead; // Track pulled bytes

    } else {
        // --- UNDERRUN ---
//        if(logger_) logger_->warn("  UNDERRUN: Requested {}, pulled only {}. Available was {}.", targetBufferSize, bytesRead, availableBeforeRead);
        handleUnderrun(info);
        bzero(targetBuffer, targetBufferSize);
        result.generatedSilence = true;
        result.dataLength = targetBufferSize;
    }

    return result;
}

// --- isReadyForStreaming and handleUnderrun remain the same ---
bool IsochPacketProvider::isReadyForStreaming() const {
    // Check OWN buffer
    size_t fillTargetBytes = (audioBuffer_.capacity() * INITIAL_FILL_TARGET_PERCENT) / 100;
    return audioBuffer_.read_space() >= fillTargetBytes;
    // return isInitialized_.load(); // Or use the flag if preferred
}

void IsochPacketProvider::handleUnderrun(const TransmitPacketInfo& info) {
    underrunCount_++;
    if (underrunCount_ % 100 == 1) {
         if(logger_) logger_->warn("IsochPacketProvider: Buffer underrun detected at Seg={}, Pkt={}, AbsPkt={}. Total Count={}",
                                  info.segmentIndex, info.packetIndexInGroup, info.absolutePacketIndex, underrunCount_.load());
    }
}

} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochDoubleBufferManager.cpp ===
#include "Isoch/core/IsochDoubleBufferManager.hpp"
#include <spdlog/spdlog.h>
#include <algorithm>
#include <cassert>
#include <cstring>

namespace FWA {
namespace Isoch {

IsochDoubleBufferManager::IsochDoubleBufferManager(
    std::shared_ptr<spdlog::logger> logger,
    uint32_t numSegments,
    uint32_t cyclesPerSegment,
    uint32_t cycleBufferSize)
    : logger_(std::move(logger))
    , numSegments_(numSegments)
    , cyclesPerSegment_(cyclesPerSegment)
    , cycleBufferSize_(cycleBufferSize)
    , segmentSize_(cyclesPerSegment * cycleBufferSize)
    , mainBuffer_(nullptr)
    , totalBufferSize_(0) {
    
    if (logger_) {
        logger_->debug("IsochDoubleBufferManager created with {} segments of {} bytes each",
                     numSegments_, segmentSize_);
    }
    
    // Initialize pointers to nullptr
    segmentCompleteA_ = nullptr;
    segmentCompleteB_ = nullptr;
    segmentProcessedA_ = nullptr;
    segmentProcessedB_ = nullptr;
    segmentsA_ = nullptr;
    segmentsB_ = nullptr;
}

IsochDoubleBufferManager::~IsochDoubleBufferManager() {
    // Free allocated memory
    delete[] segmentCompleteA_;
    delete[] segmentCompleteB_;
    delete[] segmentProcessedA_;
    delete[] segmentProcessedB_;
    delete[] segmentsA_;
    delete[] segmentsB_;
    delete[] mainBuffer_;
    
    if (logger_) {
        logger_->debug("IsochDoubleBufferManager destroyed");
    }
}

bool IsochDoubleBufferManager::initialize(uint8_t* baseBuffer, size_t totalSize) {
    // Check parameters
    if (!baseBuffer || totalSize == 0) {
        if (logger_) {
            logger_->error("IsochDoubleBufferManager::initialize: Invalid buffer parameters");
        }
        return false;
    }
    
    // Store provided buffer
    mainBuffer_ = baseBuffer;
    totalBufferSize_ = totalSize;
    
    // Calculate required buffer size
    const size_t dataSize = 2 * numSegments_ * segmentSize_; // Two complete data buffers
    
    if (totalSize < dataSize) {
        if (logger_) {
            logger_->error("IsochDoubleBufferManager::initialize: Insufficient buffer size. Need at least {} bytes for data, got {} bytes",
                         dataSize, totalSize);
        }
        return false;
    }
    
    // Allocate control arrays
    try {
        segmentCompleteA_ = new std::atomic<bool>[numSegments_];
        segmentCompleteB_ = new std::atomic<bool>[numSegments_];
        segmentProcessedA_ = new std::atomic<bool>[numSegments_];
        segmentProcessedB_ = new std::atomic<bool>[numSegments_];
        segmentsA_ = new BufferSegment[numSegments_];
        segmentsB_ = new BufferSegment[numSegments_];
    } catch (const std::bad_alloc&) {
        if (logger_) {
            logger_->error("IsochDoubleBufferManager::initialize: Failed to allocate control arrays");
        }
        
        // Clean up any arrays that were successfully allocated
        delete[] segmentCompleteA_;
        delete[] segmentCompleteB_;
        delete[] segmentProcessedA_;
        delete[] segmentProcessedB_;
        delete[] segmentsA_;
        delete[] segmentsB_;
        
        // Reset pointers
        segmentCompleteA_ = nullptr;
        segmentCompleteB_ = nullptr;
        segmentProcessedA_ = nullptr;
        segmentProcessedB_ = nullptr;
        segmentsA_ = nullptr;
        segmentsB_ = nullptr;
        
        return false;
    }
    
    // Initialize atomic flags
    for (uint32_t i = 0; i < numSegments_; ++i) {
        segmentCompleteA_[i].store(false);
        segmentCompleteB_[i].store(false);
        segmentProcessedA_[i].store(true);  // Initially processed (ready to write)
        segmentProcessedB_[i].store(true);  // Initially processed (ready to write)
    }
    
    // Set up segment pointers for buffer A
    uint8_t* currentPtr = mainBuffer_;
    for (uint32_t i = 0; i < numSegments_; ++i) {
        segmentsA_[i].data = currentPtr;
        segmentsA_[i].size = segmentSize_;
        currentPtr += segmentSize_;
    }
    
    // Set up segment pointers for buffer B
    for (uint32_t i = 0; i < numSegments_; ++i) {
        segmentsB_[i].data = currentPtr;
        segmentsB_[i].size = segmentSize_;
        currentPtr += segmentSize_;
    }
    
    // Start with buffer A for writing, buffer B for reading
    writeBufferIndex_.store(0);  // A
    readBufferIndex_.store(1);   // B
    bufferAReady_.store(false);
    bufferBReady_.store(false);
    
    if (logger_) {
        logger_->info("IsochDoubleBufferManager::initialize: Initialized with {} bytes of memory at {:p}",
                    totalSize, (void*)baseBuffer);
    }
    
    return true;
}

uint8_t* IsochDoubleBufferManager::getWriteSegmentPtr(uint32_t segment) {
    if (segment >= numSegments_ || !mainBuffer_) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::getWriteSegmentPtr: Invalid segment {} or uninitialized buffer",
                        segment);
        }
        return nullptr;
    }
    
    // Check if segment is ready for writing
    if (!getWriteProcessedFlags()[segment].load()) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::getWriteSegmentPtr: Segment {} not processed yet", segment);
        }
        return nullptr;
    }
    
    // Return pointer to segment data
    return getWriteSegments()[segment].data;
}

uint8_t* IsochDoubleBufferManager::getReadSegmentPtr(uint32_t segment) {
    if (segment >= numSegments_ || !mainBuffer_) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::getReadSegmentPtr: Invalid segment {} or uninitialized buffer",
                        segment);
        }
        return nullptr;
    }
    
    // Check if segment is ready for reading (completed)
    if (!getReadCompleteFlags()[segment].load()) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::getReadSegmentPtr: Segment {} not complete yet", segment);
        }
        return nullptr;
    }
    
    // Return pointer to segment data
    return getReadSegments()[segment].data;
}

void IsochDoubleBufferManager::markSegmentComplete(uint32_t segment) {
    if (segment >= numSegments_) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::markSegmentComplete: Invalid segment {}", segment);
        }
        return;
    }
    
    // Mark segment as complete and not processed
    getWriteCompleteFlags()[segment].store(true);
    getWriteProcessedFlags()[segment].store(false);
    
    // Check if this completes the buffer
    if (isWriteBufferFull()) {
        if (writeBufferIndex_.load() == 0) {
            bufferAReady_.store(true);
        } else {
            bufferBReady_.store(true);
        }
    }
    
    if (logger_) {
        logger_->debug("IsochDoubleBufferManager: Marked write buffer segment {} as complete", segment);
    }
}

void IsochDoubleBufferManager::markSegmentProcessed(uint32_t segment) {
    if (segment >= numSegments_) {
        if (logger_) {
            logger_->warn("IsochDoubleBufferManager::markSegmentProcessed: Invalid segment {}", segment);
        }
        return;
    }
    
    // Mark segment as processed and not complete
    getReadProcessedFlags()[segment].store(true);
    getReadCompleteFlags()[segment].store(false);
    
    if (logger_) {
        logger_->debug("IsochDoubleBufferManager: Marked read buffer segment {} as processed", segment);
    }
}

bool IsochDoubleBufferManager::isSegmentComplete(uint32_t segment) const {
    if (segment >= numSegments_) {
        return false;
    }
    return getWriteCompleteFlags()[segment].load();
}

bool IsochDoubleBufferManager::isSegmentProcessed(uint32_t segment) const {
    if (segment >= numSegments_) {
        return false;
    }
    return getReadProcessedFlags()[segment].load();
}

bool IsochDoubleBufferManager::isWriteBufferFull() const {
    // Check if all segments in write buffer are complete
    const std::atomic<bool>* completeFlags = getWriteCompleteFlags();
    for (uint32_t i = 0; i < numSegments_; ++i) {
        if (!completeFlags[i].load()) {
            return false;
        }
    }
    return true;
}

bool IsochDoubleBufferManager::isReadBufferEmpty() const {
    // Check if all segments in read buffer are processed
    const std::atomic<bool>* processedFlags = getReadProcessedFlags();
    for (uint32_t i = 0; i < numSegments_; ++i) {
        if (!processedFlags[i].load()) {
            return false;
        }
    }
    return true;
}

bool IsochDoubleBufferManager::trySwapBuffers() {
    // Check if buffers are in a state that allows swapping
    if (!isWriteBufferFull() || !isReadBufferEmpty()) {
        return false;
    }
    
    // Perform the swap
    uint32_t oldWrite = writeBufferIndex_.load();
    uint32_t oldRead = readBufferIndex_.load();
    
    writeBufferIndex_.store(oldRead);
    readBufferIndex_.store(oldWrite);
    
    // Update buffer ready flags
    if (oldWrite == 0) {
        bufferAReady_.store(false);  // No longer ready for reading
    } else {
        bufferBReady_.store(false);  // No longer ready for reading
    }
    
    if (logger_) {
        logger_->debug("IsochDoubleBufferManager: Swapped buffers - write buffer is now {}, read buffer is now {}",
                     writeBufferIndex_.load(), readBufferIndex_.load());
    }
    
    return true;
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/AudioProcessingThread.cpp ===
#include "Isoch/core/AudioProcessingThread.hpp"
#include <spdlog/spdlog.h>

namespace FWA {
namespace Isoch {

AudioProcessingThread::AudioProcessingThread(
    std::shared_ptr<IsochDoubleBufferManager> bufferManager,
    std::shared_ptr<spdlog::logger> logger)
    : bufferManager_(std::move(bufferManager))
    , logger_(std::move(logger))
    , running_(false)
    , shouldExit_(false)
    , dataAvailable_(false)
    , audioCallback_(nullptr)
    , audioCallbackRefCon_(nullptr) {
    
    if (!bufferManager_) {
        if (logger_) {
            logger_->error("AudioProcessingThread: Buffer manager is null");
        }
        return;
    }
    
    // Initialize timestamp vector
    if (bufferManager_->getNumSegments() > 0) {
        timestamps_.resize(bufferManager_->getNumSegments(), 0);
    }
    
    if (logger_) {
        logger_->debug("AudioProcessingThread created with {} segments",
                     bufferManager_->getNumSegments());
    }
}

AudioProcessingThread::~AudioProcessingThread() {
    // Make sure thread is stopped
    stop();
    
    if (logger_) {
        logger_->debug("AudioProcessingThread destroyed");
    }
}

bool AudioProcessingThread::start() {
    // Don't start if already running
    if (running_.load()) {
        if (logger_) {
            logger_->warn("AudioProcessingThread::start: Already running");
        }
        return false;
    }
    
    // Reset exit flag
    shouldExit_.store(false);
    
    // Start the thread
    try {
        processingThread_ = std::thread(&AudioProcessingThread::processingLoop, this);
        running_.store(true);
        
        if (logger_) {
            logger_->info("AudioProcessingThread started");
        }
        
        return true;
    } catch (const std::exception& e) {
        if (logger_) {
            logger_->error("AudioProcessingThread::start: Failed to start thread: {}", e.what());
        }
        return false;
    }
}

void AudioProcessingThread::stop() {
    // Skip if not running
    if (!running_.load()) {
        return;
    }
    
    // Signal thread to exit and notify condition variable
    shouldExit_.store(true);
    
    {
        std::lock_guard<std::mutex> lock(condMutex_);
        dataAvailable_ = true;
    }
    
    dataCond_.notify_one();
    
    // Wait for thread to exit
    if (processingThread_.joinable()) {
        processingThread_.join();
    }
    
    // Reset running flag
    running_.store(false);
    
    if (logger_) {
        logger_->info("AudioProcessingThread stopped");
    }
}

void AudioProcessingThread::setAudioCallback(ExtendedPacketCallback callback, void* refCon) {
    audioCallback_ = callback;
    audioCallbackRefCon_ = refCon;
    
    if (logger_) {
        logger_->debug("AudioProcessingThread: Set audio callback to {:p} with refCon {:p}",
                     reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(callback)),
                     refCon);
    }
}

void AudioProcessingThread::notifyNewData() {
    // Signal that new data is available
    {
        std::lock_guard<std::mutex> lock(condMutex_);
        dataAvailable_ = true;
    }
    
    // Notify the processing thread
    dataCond_.notify_one();
    
    if (logger_) {
        logger_->debug("AudioProcessingThread: Notified of new data");
    }
}

void AudioProcessingThread::setSegmentTimestamp(uint32_t segment, uint32_t timestamp) {
    // Check segment bounds
    if (segment >= timestamps_.size()) {
        if (logger_) {
            logger_->warn("AudioProcessingThread::setSegmentTimestamp: Invalid segment index {}", segment);
        }
        return;
    }
    
    // Update timestamp
    {
        std::lock_guard<std::mutex> lock(timestampMutex_);
        timestamps_[segment] = timestamp;
    }
}

void AudioProcessingThread::processingLoop() {
    if (logger_) {
        logger_->debug("AudioProcessingThread: Processing loop started");
    }
    
    // Main loop
    while (!shouldExit_.load()) {
        // Wait for new data signal
        {
            std::unique_lock<std::mutex> lock(condMutex_);
            dataCond_.wait(lock, [this] {
                return dataAvailable_ || shouldExit_.load();
            });
            
            // Reset flag
            dataAvailable_ = false;
        }
        
        // Check if we should exit
        if (shouldExit_.load()) {
            break;
        }
        
        if (!bufferManager_) {
            if (logger_) {
                logger_->error("AudioProcessingThread: Buffer manager is null");
            }
            continue;
        }
        
        // Try to swap buffers if write buffer is full and read buffer is empty
        if (bufferManager_->isWriteBufferFull() && bufferManager_->isReadBufferEmpty()) {
            if (bufferManager_->trySwapBuffers()) {
                if (logger_) {
                    logger_->debug("AudioProcessingThread: Successfully swapped buffers");
                }
                
                // Process all segments in the read buffer
                uint32_t numSegments = bufferManager_->getNumSegments();
                for (uint32_t i = 0; i < numSegments; ++i) {
                    processSegment(i);
                }
            } else {
                if (logger_) {
                    logger_->warn("AudioProcessingThread: Failed to swap buffers");
                }
            }
        }
    }
    
    if (logger_) {
        logger_->debug("AudioProcessingThread: Processing loop exited");
    }
}

void AudioProcessingThread::processSegment(uint32_t segment) {
    // Get segment data
    uint8_t* data = bufferManager_->getReadSegmentPtr(segment);
    
    if (!data) {
        if (logger_) {
            logger_->warn("AudioProcessingThread::processSegment: Failed to get read segment {} data", segment);
        }
        return;
    }
    
    // Get segment size
    size_t size = bufferManager_->getSegmentSize();
    
    // Get timestamp for this segment
    uint32_t timestamp;
    {
        std::lock_guard<std::mutex> lock(timestampMutex_);
        timestamp = segment < timestamps_.size() ? timestamps_[segment] : 0;
    }
    
    // Send data to client via callback
    if (audioCallback_) {
        try {
            audioCallback_(segment, data, size, timestamp, audioCallbackRefCon_);
        } catch (const std::exception& e) {
            if (logger_) {
                logger_->error("AudioProcessingThread::processSegment: Exception in callback: {}", e.what());
            }
        }
    }
    
    // Mark segment as processed
    bufferManager_->markSegmentProcessed(segment);
    
    if (logger_) {
        logger_->debug("AudioProcessingThread: Processed segment {} with timestamp {}", segment, timestamp);
    }
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochDCLManager.cpp ===
#include "Isoch/core/IsochDCLManager.hpp"
#include "Isoch/core/IsochBufferManager.hpp"
#include <spdlog/spdlog.h>
#include <IOKit/IOKitLib.h> // For kIOReturnSuccess etc.

namespace FWA {
namespace Isoch {

// Constants from Buffer Manager
constexpr size_t kIsochHeaderSize = IsochBufferManager::kIsochHeaderSize;
constexpr size_t kCIPHeaderSize = IsochBufferManager::kCIPHeaderSize;

IsochDCLManager::IsochDCLManager(
    std::shared_ptr<spdlog::logger> logger,
    IOFireWireLibNuDCLPoolRef nuDCLPool,
    const IsochBufferManager& bufferManager, // Take const ref
    const Config& config)
    : logger_(std::move(logger))
    , nuDCLPool_(nuDCLPool)
    , bufferManager_(bufferManager) // Store const ref
    , config_(config)
    , totalPackets_(config.numGroups * config.packetsPerGroup)
{
    if (logger_) logger_->debug("IsochDCLManager created (Kernel Style)");
}

IsochDCLManager::~IsochDCLManager() {
    reset();
    if (logger_) logger_->debug("IsochDCLManager destroyed");
}

void IsochDCLManager::reset() {
    std::lock_guard<std::mutex> lock(stateMutex_);
    // NuDCLPool commands are freed when the pool is released (externally)
    groupInfos_.clear(); // Clear metadata vector
    firstDCLRef_ = nullptr;
    lastDCLRef_ = nullptr;
    dclProgramCreated_ = false;
    if (logger_) logger_->debug("IsochDCLManager reset completed");
}

std::expected<DCLCommand*, IOKitError> IsochDCLManager::createDCLProgram() {
    std::lock_guard<std::mutex> lock(stateMutex_);
    if (dclProgramCreated_) return std::unexpected(IOKitError::Busy);
    if (!nuDCLPool_) return std::unexpected(IOKitError::NotReady);

    const uint32_t numGroups = config_.numGroups;
    const uint32_t packetsPerGroup = config_.packetsPerGroup;
    const uint32_t packetDataSize = bufferManager_.getPacketDataSize();
    const uint32_t callbackInterval = config_.callbackGroupInterval > 0 ? config_.callbackGroupInterval : 1; // Ensure > 0

    if (logger_) {
        logger_->info("IsochDCLManager::createDCLProgram (Kernel Style):");
        logger_->info("  NumGroups={}, PacketsPerGroup={}, PacketDataSize={}, CallbackInterval={}",
                      numGroups, packetsPerGroup, packetDataSize, callbackInterval);
    }

    if (numGroups == 0 || packetsPerGroup == 0) {
         return std::unexpected(IOKitError::BadArgument);
    }

    groupInfos_.resize(numGroups); // Allocate space for group metadata
    NuDCLRef previousDCL = nullptr;

    // --- Loop through groups and packets ---
    for (uint32_t groupIdx = 0; groupIdx < numGroups; ++groupIdx) {
        // Set up metadata for this group
        groupInfos_[groupIdx].manager = this;
        groupInfos_[groupIdx].groupIndex = groupIdx;

        for (uint32_t packetIdx = 0; packetIdx < packetsPerGroup; ++packetIdx) {
            uint32_t globalPacketIdx = groupIdx * packetsPerGroup + packetIdx;

            // Get pointers for this packet's sections from BufferManager
            auto isochHdrPtrExp = bufferManager_.getPacketIsochHeaderPtr(groupIdx, packetIdx);
            auto cipHdrPtrExp = bufferManager_.getPacketCIPHeaderPtr(groupIdx, packetIdx);
            auto dataPtrExp = bufferManager_.getPacketDataPtr(groupIdx, packetIdx);
            auto tsPtrExp = bufferManager_.getPacketTimestampPtr(groupIdx, packetIdx);

            if (!isochHdrPtrExp || !cipHdrPtrExp || !dataPtrExp || !tsPtrExp) {
                 if (logger_) logger_->error("Failed to get buffer pointers for packet G:{} P:{}", groupIdx, packetIdx);
                 reset();
                 return std::unexpected(IOKitError::NoMemory); // Or appropriate error
            }

            // Prepare the 3 ranges for AllocateReceivePacket
            IOVirtualRange ranges[3];
            // Range 0: Isoch Header
            ranges[0].address = reinterpret_cast<IOVirtualAddress>(isochHdrPtrExp.value());
            ranges[0].length = kIsochHeaderSize;
            // Range 1: CIP Header
            ranges[1].address = reinterpret_cast<IOVirtualAddress>(cipHdrPtrExp.value());
            ranges[1].length = kCIPHeaderSize;
            // Range 2: Packet Data
            ranges[2].address = reinterpret_cast<IOVirtualAddress>(dataPtrExp.value());
            ranges[2].length = packetDataSize;

            // Log detailed buffer information
            if (logger_ && logger_->should_log(spdlog::level::trace)) {
                logger_->trace("createDCLProgram G:{} P:{} - Packet buffer ranges:", groupIdx, packetIdx);
                logger_->trace("  IsochHdr: Addr={:p}, Len={}", (void*)ranges[0].address, ranges[0].length);
                logger_->trace("  CIP Hdr:  Addr={:p}, Len={}", (void*)ranges[1].address, ranges[1].length);
                logger_->trace("  Data:     Addr={:p}, Len={}", (void*)ranges[2].address, ranges[2].length);
                logger_->trace("  TimestampPtr: {:p}", (void*)tsPtrExp.value());
                
                // Verify buffer alignment and proximity
                logger_->trace("  Buffer proximity checks:");
                logger_->trace("    IsochHdr→CIPHdr distance: {}", 
                             (uint8_t*)ranges[1].address - (uint8_t*)ranges[0].address);
                logger_->trace("    CIPHdr→Data distance: {}", 
                             (uint8_t*)ranges[2].address - (uint8_t*)ranges[1].address);
                
                // Check for expected layout (should be sequential within each packet's data area)
                bool sequential = ((uint8_t*)ranges[1].address == (uint8_t*)ranges[0].address + ranges[0].length) &&
                                 ((uint8_t*)ranges[2].address == (uint8_t*)ranges[1].address + ranges[1].length);
                if (!sequential) {
                    logger_->warn("  Buffer layout is NOT sequential within packet - unexpected arrangement!");
                }
            }
            
            // Allocate the DCL for this packet
            NuDCLRef currentDCL = (*nuDCLPool_)->AllocateReceivePacket(
                nuDCLPool_,
                nullptr, // Update bag not used in this simpler model
                4,       // Header size
                3,       // Number of ranges
                (::IOVirtualRange*)ranges); // Cast to system type

            if (!currentDCL) {
                if (logger_) logger_->error("Failed to allocate DCL for packet G:{} P:{}", groupIdx, packetIdx);
                reset(); // Clean up allocated DCLs
                return std::unexpected(IOKitError::NoMemory);
            }

            // Set timestamp pointer for *this* DCL
            (*nuDCLPool_)->SetDCLTimeStampPtr(currentDCL, tsPtrExp.value());

            // Set common flags and refcon (refcon could point to packet info if needed)
            (*nuDCLPool_)->SetDCLFlags(currentDCL, kNuDCLDynamic | kNuDCLUpdateBeforeCallback);
            (*nuDCLPool_)->SetDCLRefcon(currentDCL, this); // Could refine refcon later

            // Link previous DCL to this one
            if (previousDCL) {
                (*nuDCLPool_)->SetDCLBranch(previousDCL, currentDCL);
            }

            // Store the very first DCL
            if (groupIdx == 0 && packetIdx == 0) {
                firstDCLRef_ = currentDCL;
            }

            // Check if this is the last packet of a callback group
            if (packetIdx == packetsPerGroup - 1 && ((groupIdx + 1) % callbackInterval == 0)) {
                if (logger_) logger_->debug("Setting callback for Group: {}, Last Packet DCL: {:p}", groupIdx, (void*)currentDCL);
                (*nuDCLPool_)->SetDCLCallback(currentDCL, DCLComplete_Helper);
                // Set refcon specifically for the callback DCL to point to its group info
                (*nuDCLPool_)->SetDCLRefcon(currentDCL, &groupInfos_[groupIdx]);
            }

            previousDCL = currentDCL; // Update previous DCL for next iteration
        } // End packet loop
    } // End group loop

    // Store the very last DCL created
    lastDCLRef_ = previousDCL;

    // Don't fixup jumps here, do it separately after local port is known
    dclProgramCreated_ = true;

    // Get the program handle recognized by the system
    DCLCommand* programHandle = (*nuDCLPool_)->GetProgram(nuDCLPool_);
     if (!programHandle) {
        if (logger_) logger_->error("IsochDCLManager::createDCLProgram: GetProgram returned null after creating DCLs");
        reset();
        return std::unexpected(IOKitError::Error);
    }

    if (logger_) logger_->info("IsochDCLManager::createDCLProgram successful. FirstDCL={:p}, LastDCL={:p}", (void*)firstDCLRef_, (void*)lastDCLRef_);
    return programHandle; // Return handle from GetProgram
}

std::expected<void, IOKitError> IsochDCLManager::fixupDCLJumpTargets(IOFireWireLibLocalIsochPortRef localPort) {
     std::lock_guard<std::mutex> lock(stateMutex_);
    if (!dclProgramCreated_ || !firstDCLRef_ || !lastDCLRef_) {
         if (logger_) logger_->error("IsochDCLManager::fixupDCLJumpTargets: DCL program not fully created.");
         return std::unexpected(IOKitError::NotReady);
    }
     if (!localPort) {
         if (logger_) logger_->error("IsochDCLManager::fixupDCLJumpTargets: Local port is null.");
         return std::unexpected(IOKitError::BadArgument);
     }

    // Make the program circular: last DCL branches to first DCL
    (*nuDCLPool_)->SetDCLBranch(lastDCLRef_, firstDCLRef_);
    if (logger_) logger_->info("IsochDCLManager::fixupDCLJumpTargets: Set branch LastDCL ({:p}) -> FirstDCL ({:p})", (void*)lastDCLRef_, (void*)firstDCLRef_);

    // Notify the port about the jump update on the *last* DCL
    IOReturn result = notifyJumpUpdate(localPort, &lastDCLRef_); // Pass address of the variable storing the ref
    if (result != kIOReturnSuccess) {
        // Log error but don't fail the whole operation
        logger_->error("IsochDCLManager::fixupDCLJumpTargets: Notify failed for last DCL jump: 0x{:08X}", result);
    } else {
        logger_->debug("IsochDCLManager::fixupDCLJumpTargets: Notify successful for last DCL jump");
    }

    // No explicit overrun DCL in this model, so no separate jump for it.

    currentSegment_ = 0; // Reset conceptual 'segment' counter (might rename this)
    logger_->info("IsochDCLManager::fixupDCLJumpTargets successful.");
    return {};
}

IOReturn IsochDCLManager::notifyJumpUpdate(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef* dclRefPtr) {
    // Helper to notify port about jump changes
     if (!localPort || !dclRefPtr || !*dclRefPtr) {
        return kIOReturnBadArgument;
    }
    // Pass the address of the NuDCLRef variable
    return (*localPort)->Notify(
        localPort,
        kFWNuDCLModifyJumpNotification,
        (void**)dclRefPtr, // Pass address of the variable holding the NuDCLRef
        1);
}


std::expected<DCLCommandPtr, IOKitError> IsochDCLManager::getProgram() const {
    // GetProgram from NuDCLPool should return the DCLCommand* compatible handle
     if (!nuDCLPool_) return std::unexpected(IOKitError::NotReady);
     DCLCommand* program = (*nuDCLPool_)->GetProgram(nuDCLPool_);
     if (!program) return std::unexpected(IOKitError::Error);
     return reinterpret_cast<DCLCommandPtr>(program); // Cast to DCLCommandPtr
}

// --- Callbacks ---
void IsochDCLManager::setDCLCompleteCallback(DCLCompleteCallback callback, void* refCon) {
    dclCompleteCallback_ = callback;
    dclCompleteRefCon_ = refCon;
}

void IsochDCLManager::setDCLOverrunCallback(DCLOverrunCallback callback, void* refCon) {
    dclOverrunCallback_ = callback;
    dclOverrunRefCon_ = refCon;
}

void IsochDCLManager::handleDCLComplete(NuDCLRef dcl, BufferGroupInfo* groupInfo) {
    if (!groupInfo) {
         if(logger_) logger_->error("handleDCLComplete: Received NULL groupInfo!");
         return;
    }

    // if (logger_) logger_->debug("handleDCLComplete: Group {} completed (DCL: {:p})", groupInfo->groupIndex, (void*)dcl);

    // Call the client's callback
    if (dclCompleteCallback_) {
        // The client callback expects a single 'groupIndex' index. We provide the group index.
        dclCompleteCallback_(groupInfo->groupIndex, dclCompleteRefCon_);
    }
}

void IsochDCLManager::handleDCLOverrun(NuDCLRef dcl) {
     if (logger_) logger_->warn("handleDCLOverrun: DCL overrun detected (DCL: {:p})", (void*)dcl);
    if (dclOverrunCallback_) {
        dclOverrunCallback_(dclOverrunRefCon_);
    }
}

// Static Helpers
void IsochDCLManager::DCLComplete_Helper(void* refcon, NuDCLRef dcl) {
    // refcon here is BufferGroupInfo*
    auto groupInfo = static_cast<BufferGroupInfo*>(refcon);
    if (groupInfo && groupInfo->manager) {
        groupInfo->manager->handleDCLComplete(dcl, groupInfo);
    } else if (auto logger = spdlog::default_logger()) { // Fallback logger
         logger->error("DCLComplete_Helper: Invalid refcon or manager pointer!");
    }
}

void IsochDCLManager::DCLOverrun_Helper(void* refcon, NuDCLRef dcl) {
     // refcon here is IsochDCLManager*
     auto manager = static_cast<IsochDCLManager*>(refcon);
     if (manager) {
         manager->handleDCLOverrun(dcl);
     } else if (auto logger = spdlog::default_logger()) {
         logger->error("DCLOverrun_Helper: Invalid manager refcon!");
     }
}

} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochBufferManager.cpp ===
#include "Isoch/core/IsochBufferManager.hpp"
#include <mach/mach.h>
#include <spdlog/spdlog.h>
#include <cstring> // For bzero

namespace FWA {
namespace Isoch {

IsochBufferManager::IsochBufferManager(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)) {
    if (logger_) {
        logger_->debug("IsochBufferManager created");
    }
}

IsochBufferManager::~IsochBufferManager() {
    cleanup();
    
    if (logger_) {
        logger_->debug("IsochBufferManager destroyed");
    }
}

void IsochBufferManager::cleanup() noexcept {
    if (mainBuffer_) {
        // Free the memory using vm_deallocate
        vm_deallocate(mach_task_self(),
                     reinterpret_cast<vm_address_t>(mainBuffer_),
                     totalBufferSize_);
        
        // Reset pointers
        mainBuffer_ = nullptr;
        isochHeaderArea_ = nullptr;
        cipHeaderArea_ = nullptr;
        packetDataArea_ = nullptr;
        timestampArea_ = nullptr;
        
        // Reset buffer range
        bufferRange_ = IOVirtualRange{};
        totalBufferSize_ = 0;
        
        if (logger_) {
            logger_->debug("IsochBufferManager::cleanup: Released buffer");
        }
    }
}

void IsochBufferManager::calculateBufferLayout() {
    totalPackets_ = config_.numGroups * config_.packetsPerGroup;

    // Calculate size needed for each section based on total packets
    isochHeaderTotalSize_ = totalPackets_ * kIsochHeaderSize;
    cipHeaderTotalSize_ = totalPackets_ * kCIPHeaderSize;
    packetDataTotalSize_ = totalPackets_ * config_.packetDataSize;
    timestampTotalSize_ = totalPackets_ * sizeof(uint32_t);

    // Total size is the sum of all sections
    totalBufferSize_ = isochHeaderTotalSize_ + cipHeaderTotalSize_ + packetDataTotalSize_ + timestampTotalSize_;

    // Align total size to page boundary for vm_allocate efficiency
    totalBufferSize_ = (totalBufferSize_ + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

    if (logger_) {
        logger_->debug("IsochBufferManager::calculateBufferLayout:");
        logger_->debug("  NumGroups: {}, PacketsPerGroup: {}, TotalPackets: {}", 
                      config_.numGroups, config_.packetsPerGroup, totalPackets_);
        logger_->debug("  PacketDataSize: {}", config_.packetDataSize);
        logger_->debug("  IsochHdr Area Size: {}", isochHeaderTotalSize_);
        logger_->debug("  CIP Hdr Area Size: {}", cipHeaderTotalSize_);
        logger_->debug("  Data Area Size: {}", packetDataTotalSize_);
        logger_->debug("  Timestamp Area Size: {}", timestampTotalSize_);
        logger_->debug("  Total Buffer Size (Aligned): {}", totalBufferSize_);
    }
}

std::expected<void, IOKitError> IsochBufferManager::setupBuffers(const Config& config) {
    cleanup();
    config_ = config;
    
    if (config_.numGroups == 0 || config_.packetsPerGroup == 0 || config_.packetDataSize == 0) {
        if (logger_) logger_->error("IsochBufferManager: Invalid configuration parameters (zeros)");
        return std::unexpected(IOKitError::BadArgument);
    }

    calculateBufferLayout();

    // Allocate memory using vm_allocate for page alignment
    vm_address_t buffer = 0;
    kern_return_t result = vm_allocate(mach_task_self(), &buffer, totalBufferSize_, VM_FLAGS_ANYWHERE);
    if (result != KERN_SUCCESS) {
        if (logger_) {
            logger_->error("IsochBufferManager: Failed to allocate memory: size={}, error={}", 
                          totalBufferSize_, result);
        }
        return std::unexpected(IOKitError::NoMemory);
    }

    mainBuffer_ = reinterpret_cast<uint8_t*>(buffer);
    bzero(mainBuffer_, totalBufferSize_);

    // Set section pointers within the contiguous buffer
    isochHeaderArea_ = mainBuffer_;
    cipHeaderArea_ = isochHeaderArea_ + isochHeaderTotalSize_;
    packetDataArea_ = cipHeaderArea_ + cipHeaderTotalSize_;
    timestampArea_ = reinterpret_cast<uint32_t*>(packetDataArea_ + packetDataTotalSize_);

    bufferRange_.address = reinterpret_cast<IOVirtualAddress>(mainBuffer_);
    bufferRange_.length = totalBufferSize_; // The range covers the entire allocation

    if (logger_) {
        logger_->info("IsochBufferManager::setupBuffers: Allocated buffer at {:p} size {}", 
                     (void*)mainBuffer_, totalBufferSize_);
        logger_->debug("  IsochHdr Area: {:p}", (void*)isochHeaderArea_);
        logger_->debug("  CIP Hdr Area: {:p}", (void*)cipHeaderArea_);
        logger_->debug("  Data Area: {:p}", (void*)packetDataArea_);
        logger_->debug("  Timestamp Area: {:p}", (void*)timestampArea_);
    }
    return {};
}

// --- Implementation of getters for packet components ---

std::expected<uint32_t*, IOKitError> IsochBufferManager::getPacketTimestampPtr(
    uint32_t groupIndex, uint32_t packetIndexInGroup) const
{
    if (!mainBuffer_) {
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (groupIndex >= config_.numGroups || packetIndexInGroup >= config_.packetsPerGroup) {
        if (logger_) logger_->error("getPacketTimestampPtr: Invalid indices G:{} P:{}, limits G:{} P:{}",
                                  groupIndex, packetIndexInGroup, config_.numGroups, config_.packetsPerGroup);
        return std::unexpected(IOKitError::BadArgument);
    }
    
    uint32_t globalPacketIndex = groupIndex * config_.packetsPerGroup + packetIndexInGroup;
    uint32_t* ptr = &timestampArea_[globalPacketIndex];
    
    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        logger_->trace("getPacketTimestampPtr(G:{}, P:{}): Base={:p}, Idx={}, Result={:p}",
                      groupIndex, packetIndexInGroup, 
                      (void*)timestampArea_, globalPacketIndex, (void*)ptr);
    }
    
    return ptr;
}

std::expected<uint8_t*, IOKitError> IsochBufferManager::getPacketIsochHeaderPtr(
    uint32_t groupIndex, uint32_t packetIndexInGroup) const
{
    if (!mainBuffer_) {
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (groupIndex >= config_.numGroups || packetIndexInGroup >= config_.packetsPerGroup) {
        if (logger_) logger_->error("getPacketIsochHeaderPtr: Invalid indices G:{} P:{}, limits G:{} P:{}",
                                  groupIndex, packetIndexInGroup, config_.numGroups, config_.packetsPerGroup);
        return std::unexpected(IOKitError::BadArgument);
    }
    
    uint32_t globalPacketIndex = groupIndex * config_.packetsPerGroup + packetIndexInGroup;
    size_t offset = globalPacketIndex * kIsochHeaderSize;
    uint8_t* ptr = isochHeaderArea_ + offset;
    
    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        logger_->trace("getPacketIsochHeaderPtr(G:{}, P:{}): Base={:p}, Idx={}, Offset={}, Result={:p}",
                      groupIndex, packetIndexInGroup, (void*)isochHeaderArea_, 
                      globalPacketIndex, offset, (void*)ptr);
    }
    
    return ptr;
}

std::expected<uint8_t*, IOKitError> IsochBufferManager::getPacketCIPHeaderPtr(
    uint32_t groupIndex, uint32_t packetIndexInGroup) const
{
    if (!mainBuffer_) {
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (groupIndex >= config_.numGroups || packetIndexInGroup >= config_.packetsPerGroup) {
        if (logger_) logger_->error("getPacketCIPHeaderPtr: Invalid indices G:{} P:{}, limits G:{} P:{}",
                                  groupIndex, packetIndexInGroup, config_.numGroups, config_.packetsPerGroup);
        return std::unexpected(IOKitError::BadArgument);
    }
    
    uint32_t globalPacketIndex = groupIndex * config_.packetsPerGroup + packetIndexInGroup;
    size_t offset = globalPacketIndex * kCIPHeaderSize;
    uint8_t* ptr = cipHeaderArea_ + offset;
    
    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        logger_->trace("getPacketCIPHeaderPtr(G:{}, P:{}): Base={:p}, Idx={}, Offset={}, Result={:p}",
                      groupIndex, packetIndexInGroup, (void*)cipHeaderArea_, 
                      globalPacketIndex, offset, (void*)ptr);
    }
    
    return ptr;
}

std::expected<uint8_t*, IOKitError> IsochBufferManager::getPacketDataPtr(
    uint32_t groupIndex, uint32_t packetIndexInGroup) const
{
    if (!mainBuffer_) {
        return std::unexpected(IOKitError::NotReady);
    }
    
    if (groupIndex >= config_.numGroups || packetIndexInGroup >= config_.packetsPerGroup) {
        if (logger_) logger_->error("getPacketDataPtr: Invalid indices G:{} P:{}, limits G:{} P:{}",
                                  groupIndex, packetIndexInGroup, config_.numGroups, config_.packetsPerGroup);
        return std::unexpected(IOKitError::BadArgument);
    }
    
    uint32_t globalPacketIndex = groupIndex * config_.packetsPerGroup + packetIndexInGroup;
    size_t offset = globalPacketIndex * config_.packetDataSize;
    uint8_t* ptr = packetDataArea_ + offset;
    
    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        logger_->trace("getPacketDataPtr(G:{}, P:{}): Base={:p}, Idx={}, Offset={}, Size={}, Result={:p}",
                      groupIndex, packetIndexInGroup, (void*)packetDataArea_, 
                      globalPacketIndex, offset, config_.packetDataSize, (void*)ptr);
    }
    
    return ptr;
}

std::expected<uint8_t*, IOKitError> IsochBufferManager::getRawPacketSlotPtr(
    uint32_t groupIndex, uint32_t packetIndexInGroup) const
{
     if (!mainBuffer_) {
        return std::unexpected(IOKitError::NotReady);
    }
    if (groupIndex >= config_.numGroups || packetIndexInGroup >= config_.packetsPerGroup) {
        if (logger_) logger_->error("getRawPacketSlotPtr: Invalid indices G:{} P:{}, limits G:{} P:{}",
                                  groupIndex, packetIndexInGroup, config_.numGroups, config_.packetsPerGroup);
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // This calculates the offset based on the assumption that Isoch headers
    // are stored contiguously at the beginning.
    uint32_t globalPacketIndex = groupIndex * config_.packetsPerGroup + packetIndexInGroup;
    size_t offset = globalPacketIndex * kIsochHeaderSize;
    uint8_t* ptr = isochHeaderArea_ + offset;
    
    if (logger_ && logger_->should_log(spdlog::level::trace)) {
        logger_->trace("getRawPacketSlotPtr(G:{}, P:{}): Base={:p}, Idx={}, Offset={}, Result={:p}",
                      groupIndex, packetIndexInGroup, (void*)isochHeaderArea_, 
                      globalPacketIndex, offset, (void*)ptr);
    }
    
    return ptr;
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochTransmitDCLManager.cpp ===
#include "Isoch/core/IsochTransmitDCLManager.hpp"
#include "Isoch/interfaces/ITransmitBufferManager.hpp" // Full definition needed now
#include <vector>
#include <stdexcept> // For potential exceptions if needed
#include <cstring> // For bzero
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <IOKit/firewire/IOFireWireLib.h>   

namespace FWA {
namespace Isoch {

IsochTransmitDCLManager::IsochTransmitDCLManager(std::shared_ptr<spdlog::logger> logger)
 : logger_(std::move(logger)) {
    if (logger_) logger_->debug("IsochTransmitDCLManager created");
}

IsochTransmitDCLManager::~IsochTransmitDCLManager() {
    reset();
    if (logger_) logger_->debug("IsochTransmitDCLManager destroyed");
}

void IsochTransmitDCLManager::reset() {
     std::lock_guard<std::mutex> lock(mutex_);
     // DCLs are owned by the pool, just clear refs
     dclProgramRefs_.clear();
     callbackInfos_.clear();
      for (CFMutableSetRef bag : updateBags_) {
         if (bag) CFRelease(bag);
     }
     updateBags_.clear();
     firstDCLRef_ = nullptr;
     lastDCLRef_ = nullptr;
     overrunDCL_ = nullptr;
     nuDCLPool_ = nullptr; // Clear non-owning ref
     dclProgramCreated_ = false;
      if (logger_) logger_->debug("IsochTransmitDCLManager reset");
}

// Basic implementations - returning errors or default values
std::expected<DCLCommand*, IOKitError> IsochTransmitDCLManager::createDCLProgram(
    const TransmitterConfig& config,
    IOFireWireLibNuDCLPoolRef nuDCLPool,
    const ITransmitBufferManager& bufferManager) // Use const ref to Buffer Manager
{
     std::lock_guard<std::mutex> lock(mutex_);
     if (dclProgramCreated_) {
         logger_->warn("createDCLProgram called when already created.");
         return std::unexpected(IOKitError::Busy);
     }
     if (!nuDCLPool) {
          logger_->error("createDCLProgram: NuDCL pool is null.");
         return std::unexpected(IOKitError::BadArgument);
     }

     logger_->info("IsochTransmitDCLManager::createDCLProgram starting...");

     // Store config and pool reference
     config_ = config;
     nuDCLPool_ = nuDCLPool; // Store non-owning ref

     // --- Basic Input Validation ---
     if (config_.numGroups == 0 || config_.packetsPerGroup == 0) {
         logger_->error("createDCLProgram: numGroups or packetsPerGroup is zero.");
         return std::unexpected(IOKitError::BadArgument);
     }
     uint32_t totalPackets = config_.numGroups * config_.packetsPerGroup;
     logger_->debug("  Total packets to create: {}", totalPackets);

     // --- Prepare Internal Structures ---
     try {
        dclProgramRefs_.resize(totalPackets);
        callbackInfos_.resize(config_.numGroups);
        // updateBags_.resize(config_.numGroups); // Not using update bags for now
     } catch (const std::bad_alloc& e) {
         logger_->error("Failed to allocate internal DCL storage: {}", e.what());
         reset();
         return std::unexpected(IOKitError::NoMemory);
     }

     NuDCLSendPacketRef previousDCL = nullptr;

     // --- DCL Allocation Loop ---
     for (uint32_t g = 0; g < config_.numGroups; ++g) {
         // Prepare callback info for this group (even if callback isn't set on all DCLs)
         callbackInfos_[g].manager = this;
         callbackInfos_[g].groupIndex = g;
         // updateBags_[g] = CFSetCreateMutable(nullptr, 0, nullptr); // If using update bags

         for (uint32_t p = 0; p < config_.packetsPerGroup; ++p) {
             uint32_t globalPacketIdx = g * config_.packetsPerGroup + p;

             // --- 1. Get Buffer Pointers for this Packet ---
             auto isochHdrPtrExp = bufferManager.getPacketIsochHeaderPtr(g, p);
             auto cipHdrPtrExp = bufferManager.getPacketCIPHeaderPtr(g, p);
             // For Send DCL, the *source* of audio data is the client buffer area
             uint8_t* audioDataPtr = bufferManager.getClientAudioBufferPtr()
                                   + (globalPacketIdx * bufferManager.getAudioPayloadSizePerPacket()) % bufferManager.getClientAudioBufferSize(); // Cycle through client buffer
             auto timestampPtrExp = bufferManager.getGroupTimestampPtr(g);

             if (!isochHdrPtrExp || !cipHdrPtrExp || !timestampPtrExp || !audioDataPtr) {
                 logger_->error("Failed to get buffer pointers for G={}, P={}", g, p);
                 reset(); // Cleanup partially created DCLs
                 return std::unexpected(IOKitError::NoMemory); // Or more specific error
             }
             uint8_t* isochHdrTemplatePtr = isochHdrPtrExp.value();
             uint8_t* cipHdrPtr = cipHdrPtrExp.value();
             uint32_t* timestampPtr = timestampPtrExp.value();
             size_t audioPayloadSize = bufferManager.getAudioPayloadSizePerPacket();

             // --- 2. Prepare Initial Memory Content (Optional but good practice) ---
             // Isoch Header Template (Minimal: Tag=1, TCode=A. Channel set later?)
             IsochHeaderData* isochHdr = reinterpret_cast<IsochHeaderData*>(isochHdrTemplatePtr);
             isochHdr->data_length = 0; // Hardware fills this
             isochHdr->tag_channel = (1 << 6) | (config_.initialChannel & 0x3F); // Tag=1
             isochHdr->tcode_sy = (0xA << 4) | 0; // TCode=A, Sy=0

             // CIP Header (Initial safe state: NO_DATA)
             CIPHeader* cipHdr = reinterpret_cast<CIPHeader*>(cipHdrPtr);
             bzero(cipHdr, kTransmitCIPHeaderSize);
             cipHdr->fmt_eoh1 = (0x10 << 2) | 0x01; // FMT=0x10 (AM824), EOH=1
             cipHdr->fdf = 0xFF; // NO_DATA
             cipHdr->syt = OSSwapHostToBigInt16(0xFFFF); // NO_INFO

             // Audio Payload (Zero it out initially)
             // bzero(audioDataPtr, audioPayloadSize); // Provider should handle initial silence

             // --- 3. Prepare IOVirtualRange Array ---
             IOVirtualRange ranges[2];
             uint32_t numRanges = 2; // Assume CIP + Payload initially

             // Range 0: CIP Header
             ranges[0].address = reinterpret_cast<IOVirtualAddress>(cipHdrPtr);
             ranges[0].length = kTransmitCIPHeaderSize;

             // Range 1: Audio Payload
             ranges[1].address = reinterpret_cast<IOVirtualAddress>(audioDataPtr);
             ranges[1].length = audioPayloadSize;

             // --- 4. Allocate Send Packet DCL ---
             NuDCLSendPacketRef currentDCL = (*nuDCLPool_)->AllocateSendPacket(
                 nuDCLPool_,
                 nullptr, // updateBag - not using for now
                 numRanges,
                 (::IOVirtualRange*)ranges // Cast to system type
             );

             if (!currentDCL) {
                 logger_->error("Failed to allocate NuDCLSendPacketRef for G={}, P={}", g, p);
                 reset();
                 return std::unexpected(IOKitError::NoMemory);
             }
             dclProgramRefs_[globalPacketIdx] = currentDCL; // Store the reference

             // --- 5. Configure the Allocated DCL ---
             UInt32 dclFlags = kNuDCLDynamic |         // DCL might change (ranges, branch)
                                kNuDCLUpdateBeforeCallback; // Update status/TS before callback

             // Set Isoch Header Template Pointer
             (*nuDCLPool_)->SetDCLUserHeaderPtr(currentDCL, reinterpret_cast<UInt32*>(isochHdrTemplatePtr), nullptr); // Mask is null

             // Set Timestamp Pointer (where hardware WRITES completion time)
             (*nuDCLPool_)->SetDCLTimeStampPtr(currentDCL, timestampPtr);
             // NOTE: Setting a non-NULL timestamp pointer might automatically set kFWNuDCLFlag_TimeStamp

             // Set Callback (Conditional)
             bool isLastPacketInGroup = (p == config_.packetsPerGroup - 1);
             bool isCallbackGroup = ((g + 1) % config_.callbackGroupInterval == 0);

             if (isLastPacketInGroup && isCallbackGroup) {
                 (*nuDCLPool_)->SetDCLCallback(currentDCL, DCLComplete_Helper);
                 (*nuDCLPool_)->SetDCLRefcon(currentDCL, &callbackInfos_[g]); // Pass group info struct addr
                 logger_->trace("  Set callback for G={}, P={} (DCL {:p})", g, p, (void*)currentDCL);
             } else {
                 (*nuDCLPool_)->SetDCLRefcon(currentDCL, this); // Default refcon
             }

             // Set Final Flags
             (*nuDCLPool_)->SetDCLFlags(currentDCL, dclFlags);

             // --- 6. Link Previous DCL to Current ---
             if (previousDCL) {
                 (*nuDCLPool_)->SetDCLBranch(previousDCL, currentDCL);
             }

             // --- 7. Store First/Update Previous ---
             if (globalPacketIdx == 0) {
                 firstDCLRef_ = currentDCL;
                 logger_->debug("  Stored first DCL: {:p}", (void*)firstDCLRef_);
             }
             previousDCL = currentDCL;

         } // End packet loop (p)
     } // End group loop (g)

     // --- 8. Store Last DCL ---
     lastDCLRef_ = previousDCL; // Should be the last one allocated
     if(lastDCLRef_) logger_->debug("  Stored last DCL: {:p}", (void*)lastDCLRef_); else logger_->error("  Last DCL is NULL after loop!");


     // --- 9. Get Program Handle ---
     // The handle is needed for CreateLocalIsochPort
     DCLCommand* programHandle = (*nuDCLPool_)->GetProgram(nuDCLPool_);
     if (!programHandle) {
        logger_->error("GetProgram returned null after creating DCLs");
        reset();
        return std::unexpected(IOKitError::Error);
    }

     dclProgramCreated_ = true;
     logger_->info("IsochTransmitDCLManager::createDCLProgram finished successfully.");
     return programHandle; // Return the system-compatible handle
}

std::expected<void, IOKitError> IsochTransmitDCLManager::fixupDCLJumpTargets(
    IOFireWireLibLocalIsochPortRef localPort)
{
    std::lock_guard<std::mutex> lock(mutex_); // Ensure thread safety

    // 1. Check Preconditions
    if (!dclProgramCreated_) {
        logger_->error("fixupDCLJumpTargets: DCL program not created yet");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!nuDCLPool_) {
        logger_->error("fixupDCLJumpTargets: nuDCLPool_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!firstDCLRef_) {
        logger_->error("fixupDCLJumpTargets: firstDCLRef_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!lastDCLRef_) {
        logger_->error("fixupDCLJumpTargets: lastDCLRef_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!localPort) {
        logger_->error("fixupDCLJumpTargets: localPort is null");
        return std::unexpected(IOKitError::BadArgument);
    }

    // 2. Link Last DCL to First DCL
    logger_->debug("Linking last DCL ({:p}) to first DCL ({:p})", (void*)lastDCLRef_, (void*)firstDCLRef_);
    IOReturn result = (*nuDCLPool_)->SetDCLBranch(lastDCLRef_, firstDCLRef_);
    if (result != kIOReturnSuccess) {
        logger_->error("fixupDCLJumpTargets: SetDCLBranch failed with error: 0x{:08X}", result);
        return std::unexpected(IOKitError(result));
    }

    // 3. Notify the Port using the helper function
    logger_->debug("Notifying port about jump update for last DCL ({:p})", (void*)lastDCLRef_);
    NuDCLRef* dclRefPtr = &lastDCLRef_; // Get address of the variable
    result = notifyJumpUpdate(localPort, dclRefPtr); // Call the helper
    if (result != kIOReturnSuccess) {
        logger_->error("fixupDCLJumpTargets: notifyJumpUpdate failed with error: 0x{:08X}", result);
        return std::unexpected(IOKitError(result));
    } else {
        logger_->debug("Successfully notified port about last DCL jump update.");
    }

    logger_->info("IsochTransmitDCLManager::fixupDCLJumpTargets completed successfully.");
    return {};
}

void IsochTransmitDCLManager::setDCLCompleteCallback(TransmitDCLCompleteCallback callback, void* refCon) {
    dclCompleteCallback_ = callback;
    dclCompleteRefCon_ = refCon;
}

void IsochTransmitDCLManager::setDCLOverrunCallback(TransmitDCLOverrunCallback callback, void* refCon) {
    dclOverrunCallback_ = callback;
    dclOverrunRefCon_ = refCon;
}

std::expected<void, IOKitError> IsochTransmitDCLManager::updateDCLPacket(
    uint32_t groupIndex, uint32_t packetIndexInGroup,
    const IOVirtualRange ranges[], uint32_t numRanges,
    const IsochHeaderData* isochHeaderTemplate)
{
     // Remove the lock - DCL access is safe at the driver level
     if (!dclProgramCreated_) return std::unexpected(IOKitError::NotReady);
     if (!nuDCLPool_) return std::unexpected(IOKitError::NotReady); // Should not happen

     NuDCLSendPacketRef dclRef = getDCLRef(groupIndex, packetIndexInGroup);
     if (!dclRef) {
          logger_->error("updateDCLPacket: Could not get DCL Ref for G={}, P={}", groupIndex, packetIndexInGroup);
         return std::unexpected(IOKitError::BadArgument);
     }

     // Update the ranges (data source pointers and lengths)
     // This is the most common update needed.
     IOReturn result = (*nuDCLPool_)->SetDCLRanges(dclRef, numRanges, (::IOVirtualRange*)ranges);
     if (result != kIOReturnSuccess) {
         logger_->error("SetDCLRanges failed for G={}, P={}: 0x{:08X}", groupIndex, packetIndexInGroup, result);
         return std::unexpected(IOKitError(result));
     }
     
     // Update Isoch Header Template Content (if template itself changes, rarely needed)
     if (isochHeaderTemplate) {
          // Note: This requires that the caller has already obtained the correct
          // template pointer location for this DCL's isoch header.
          // The proper way to handle this would be:
          // 1. Get the current header pointer via GetDCLUserHeaderPtr from NuDCLPool
          // 2. Modify its contents
          // Here we just log that this should happen via buffer manager
          logger_->trace("isochHeaderTemplate updates should be handled via buffer manager directly");
     }

     return {};
}

std::expected<void, IOKitError> IsochTransmitDCLManager::notifySegmentUpdate(
     IOFireWireLibLocalIsochPortRef localPort, uint32_t groupIndexToNotify)
{
     // std::lock_guard<std::mutex> lock(mutex_); // May not need lock if dclProgramRefs_ isn't modified
     if (!dclProgramCreated_) return std::unexpected(IOKitError::NotReady);
     if (!localPort) return std::unexpected(IOKitError::BadArgument);
     if (groupIndexToNotify >= config_.numGroups) return std::unexpected(IOKitError::BadArgument);

     // Prepare the list of DCLs in the segment to notify
     uint32_t startIndex = groupIndexToNotify * config_.packetsPerGroup;
     uint32_t count = config_.packetsPerGroup;
     std::vector<NuDCLRef> dclsInSegment;
     dclsInSegment.reserve(count);
     for (uint32_t i = 0; i < count; ++i) {
          if (startIndex + i < dclProgramRefs_.size()) {
              dclsInSegment.push_back(dclProgramRefs_[startIndex + i]);
          } else {
               logger_->error("notifySegmentUpdate: Calculated index out of bounds!");
               return std::unexpected(IOKitError::BadArgument); // Should not happen
          }
     }

     if (dclsInSegment.empty()) {
          logger_->warn("notifySegmentUpdate: No DCLs found for group {}", groupIndexToNotify);
          return {}; // Not an error, but nothing to do
     }

     // Call the helper to notify
     IOReturn result = notifyDCLUpdates(localPort, dclsInSegment.data(), dclsInSegment.size());
     if (result != kIOReturnSuccess) {
          logger_->error("notifyDCLUpdates failed for group {}: 0x{:08X}", groupIndexToNotify, result);
          return std::unexpected(IOKitError(result));
     }
     // logger_->trace("Notified DCL updates for group {}", groupIndexToNotify);
     return {};
}

// updateJumpTargets method removed - we now use a static circular DCL program
// The fixupDCLJumpTargets method handles the circular loop setup during initialization


DCLCommand* IsochTransmitDCLManager::getProgramHandle() const {
    if (!dclProgramCreated_ || !nuDCLPool_) return nullptr;
    return (*nuDCLPool_)->GetProgram(nuDCLPool_);
}

// --- Static Callbacks & Instance Handlers ---
void IsochTransmitDCLManager::DCLComplete_Helper(void* refcon, NuDCLRef dcl) {
     auto* info = static_cast<DCLCallbackInfo*>(refcon);
     if (info && info->manager && info->manager->dclCompleteCallback_) {
          info->manager->dclCompleteCallback_(info->groupIndex, info->manager->dclCompleteRefCon_);
     }
}

void IsochTransmitDCLManager::DCLOverrun_Helper(void* refcon, NuDCLRef dcl) {
    auto* manager = static_cast<IsochTransmitDCLManager*>(refcon);
     if (manager && manager->dclOverrunCallback_) {
         manager->dclOverrunCallback_(manager->dclOverrunRefCon_);
     }
}

void IsochTransmitDCLManager::handleDCLComplete(uint32_t groupIndex, NuDCLRef dcl) {
     // This instance method could do internal state updates if needed before calling client
     if (dclCompleteCallback_) {
        dclCompleteCallback_(groupIndex, dclCompleteRefCon_);
    }
}
void IsochTransmitDCLManager::handleDCLOverrun(NuDCLRef dcl) {
     // This instance method could do internal state updates if needed before calling client
     if (dclOverrunCallback_) {
        dclOverrunCallback_(dclOverrunRefCon_);
    }
}

// --- Private Helpers ---
// Remove const qualifier to match header declaration
NuDCLSendPacketRef IsochTransmitDCLManager::getDCLRef(uint32_t g, uint32_t p) {
     // Remove the lock - read access is safe once program is created
     if (!dclProgramCreated_ || dclProgramRefs_.empty()) return nullptr;
     uint32_t index = g * config_.packetsPerGroup + p;
     if (index >= dclProgramRefs_.size()) return nullptr;
     return dclProgramRefs_[index];
}

IOReturn IsochTransmitDCLManager::notifyDCLUpdates(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef dcls[], uint32_t count) {
     if (!localPort || !dcls || count == 0) return kIOReturnBadArgument;
     
     // Need to pass array of DCLRefs cast to void*
     std::vector<void*> dclPtrList(count);
     for(uint32_t i = 0; i < count; ++i) {
         // --- FIX: Cast the DCLRef *itself* to void*, not its address ---
         dclPtrList[i] = static_cast<void*>(dcls[i]);    // Correct
         
         // Add a check for NULL DCLs just in case
         if (dclPtrList[i] == nullptr) {
             logger_->error("notifyDCLUpdates: Encountered NULL DCLRef at index {}", i);
             return kIOReturnBadArgument; // Safer to return error
         }
     }

     // Call Notify with the array of DCLRefs cast to void*
     return (*localPort)->Notify(
         localPort,
         kFWNuDCLModifyNotification,  // For content/range updates
         dclPtrList.data(),           // Array of pointers to DCLRefs
         count);
}
IOReturn IsochTransmitDCLManager::notifyJumpUpdate(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef* dclRefPtr) {
     if (!localPort || !dclRefPtr || !*dclRefPtr) return kIOReturnBadArgument;
     return (*localPort)->Notify(localPort, kFWNuDCLModifyJumpNotification, (void**)dclRefPtr, 1);
}


} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochMonitoringManager.cpp ===
#include "Isoch/core/IsochMonitoringManager.hpp"
#include <spdlog/spdlog.h>

namespace FWA {
namespace Isoch {

IsochMonitoringManager::IsochMonitoringManager(
    std::shared_ptr<spdlog::logger> logger,
    CFRunLoopRef runLoop)
    : logger_(std::move(logger))
    , runLoop_(runLoop ? runLoop : CFRunLoopGetCurrent()) {
    
    if (logger_) {
        logger_->debug("IsochMonitoringManager created with RunLoop={:p}", (void*)runLoop_);
    }
}

IsochMonitoringManager::~IsochMonitoringManager() {
    stopMonitoring();
    
    if (logger_) {
        logger_->debug("IsochMonitoringManager destroyed");
    }
}

void IsochMonitoringManager::internalStopAndReleaseTimer() {
    if (timer_) {
        // if (logger_) {
        //     logger_->debug("IsochMonitoringManager::internalStopAndReleaseTimer: Stopping monitoring");
        // }
        CFRunLoopTimerInvalidate(timer_);
        CFRelease(timer_);
        timer_ = nullptr;
    }
}

std::expected<void, IOKitError> IsochMonitoringManager::startMonitoring(uint32_t timeoutMs) {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(timerMutex_);
    
    // Stop and release existing timer *before* creating new one
    internalStopAndReleaseTimer(); // Call the non-locking helper
    
    // Store timeout value
    timeoutMs_ = timeoutMs;
    
    // if (logger_) {
    //     logger_->debug("IsochMonitoringManager::startMonitoring: Starting with timeout={}ms", timeoutMs_);
    // }
    
    // Create timer context
    CFRunLoopTimerContext context = {
        0, this, nullptr, nullptr, nullptr
    };
    
    // Calculate the absolute time for the timer
    CFAbsoluteTime fireTime = CFAbsoluteTimeGetCurrent() + (timeoutMs_ / 1000.0);
    
    // Create the timer
    timer_ = CFRunLoopTimerCreate(
        kCFAllocatorDefault,
        fireTime,
        0, // interval (0 = one-shot timer)
        0, 0, // flags, order
        timerCallback,
        &context);
    
    if (!timer_) {
        if (logger_) {
            logger_->error("IsochMonitoringManager::startMonitoring: Failed to create timer");
        }
        return std::unexpected(IOKitError::NoMemory);
    }
    
    // Add the timer to the run loop
    CFRunLoopAddTimer(runLoop_, timer_, kCFRunLoopDefaultMode);
    
    // if (logger_) {
    //     logger_->debug("IsochMonitoringManager::startMonitoring: Monitoring started");
    // }
    
    return {};
}

void IsochMonitoringManager::stopMonitoring() {
    // Acquire lock for thread safety
    std::lock_guard<std::mutex> lock(timerMutex_);
    internalStopAndReleaseTimer(); // Call the non-locking helper
}

void IsochMonitoringManager::resetTimer() {
    if (timeoutMs_ == 0) {
        return; // No monitoring
    }
    
    // No lock needed here, startMonitoring handles locking
    startMonitoring(timeoutMs_);
}

void IsochMonitoringManager::handleTimeout() {
    if (logger_) {
        logger_->warn("IsochMonitoringManager::handleTimeout: No data received before timeout");
    }
    
    // Call the no-data callback with the last cycle and refcon
    if (noDataCallback_) {
        noDataCallback_(lastCycle_, noDataCallbackRefCon_);
    }
    
    // Reset the timer to continue monitoring
    resetTimer();
}

void IsochMonitoringManager::timerCallback(CFRunLoopTimerRef timer, void* info) {
    // Get the IsochMonitoringManager instance from the info pointer
    auto manager = static_cast<IsochMonitoringManager*>(info);
    if (manager) {
        manager->handleTimeout();
    }
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/AudioDeviceStream.cpp ===
#include "Isoch/AudioDeviceStream.hpp"
#include "FWA/CommandInterface.h"
#include "Isoch/core/AmdtpTransmitter.hpp" 
#include "Isoch/interfaces/ITransmitPacketProvider.hpp" 
#include <spdlog/spdlog.h>
#include <pthread.h>
#include <mach/mach_time.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <mach/thread_policy.h>
#include <mach/thread_act.h>
#include "Isoch/utils/RunLoopHelper.hpp"

namespace FWA {

AudioDeviceStream::AudioDeviceStream(
                                     std::shared_ptr<AudioDevice> audioDevice,
                                     StreamType streamType,
                                     uint8_t devicePlugNumber,
                                     std::shared_ptr<spdlog::logger> logger,
                                     Isoch::PacketCallback dataPushCallback,
                                     void* dataPushRefCon,
                                     Isoch::MessageCallback messageCallback,
                                     void* messageRefCon,
                                     unsigned int cyclesPerSegment,
                                     unsigned int numSegments,
                                     unsigned int bufferSize,
                                     IOFWSpeed speed,
                                     IOFireWireLibDeviceRef interface
                                     )
: m_audioDevice(std::move(audioDevice)),
m_logger(std::move(logger)),
m_streamType(streamType),
m_devicePlugNumber(devicePlugNumber),
m_cyclesPerSegment(cyclesPerSegment),
m_numSegments(numSegments),
m_bufferSize(bufferSize),
m_isochSpeed(speed),
m_interface(interface),
m_packetCallback(dataPushCallback),
m_packetCallbackRefCon(dataPushRefCon),
m_messageCallback(messageCallback),
m_messageCallbackRefCon(messageRefCon)
{
    if (!m_logger) {
        m_logger = spdlog::default_logger();
    }
    
    m_logger->info("AudioDeviceStream: Created for plug {} with type {}",
                   m_devicePlugNumber, static_cast<int>(m_streamType));
}

AudioDeviceStream::~AudioDeviceStream() {
    // Ensure the stream is stopped and disconnected before destruction
    if (m_isActive) {
        stop();
    }
    
    if (m_isPlugConnected) {
        disconnectPlug();
    }
    
    // Remove dispatchers from RunLoop if needed
    if (m_interface && m_runLoop) {
        (*m_interface)->RemoveIsochCallbackDispatcherFromRunLoop(m_interface);
        (*m_interface)->RemoveCallbackDispatcherFromRunLoop(m_interface);
    }
    
    m_logger->info("AudioDeviceStream: Destroyed for plug {}", m_devicePlugNumber);
}

std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> AudioDeviceStream::create(
                                                                                        std::shared_ptr<AudioDevice> audioDevice,
                                                                                        StreamType streamType,
                                                                                        uint8_t devicePlugNumber,
                                                                                        std::shared_ptr<spdlog::logger> logger,
                                                                                        Isoch::PacketCallback dataPushCallback,
                                                                                        void* dataPushRefCon,
                                                                                        Isoch::MessageCallback messageCallback,
                                                                                        void* messageRefCon,
                                                                                        unsigned int cyclesPerSegment,
                                                                                        unsigned int numSegments,
                                                                                        unsigned int bufferSize,
                                                                                        IOFWSpeed speed,
                                                                                        IOFireWireLibDeviceRef interface
                                                                                        )
{
    if (!audioDevice) {
        return std::unexpected(IOKitError::BadArgument);
    }
    
    // Create the stream object
    auto stream = std::shared_ptr<AudioDeviceStream>(new AudioDeviceStream(
                                                                           std::move(audioDevice),
                                                                           streamType,
                                                                           devicePlugNumber,
                                                                           std::move(logger),
                                                                           dataPushCallback,
                                                                           dataPushRefCon,
                                                                           messageCallback,
                                                                           messageRefCon,
                                                                           cyclesPerSegment,
                                                                           numSegments,
                                                                           bufferSize,
                                                                           speed,
                                                                           interface
                                                                           ));
    
    // Initialize the RunLoop thread
    auto runLoopResult = stream->initializeRunLoop();
    if (!runLoopResult) {
        stream->m_logger->error("AudioDeviceStream: Failed to initialize RunLoop: {}",
                                iokit_error_category().message(static_cast<int>(runLoopResult.error())));
        return std::unexpected(runLoopResult.error());
    }

    logRunLoopInfo("AudioDeviceStream", "create", stream->m_runLoop);
    
    // Create appropriate stream implementation based on type
    switch (streamType) {
        case StreamType::AmdtpReceiver: {
            // Create AmdtpReceiver
            try {
                // Configure the receiver with the new packet-based parameters
                Isoch::ReceiverConfig config;
                config.logger = stream->m_logger;
                
                // Convert from old cycle-based config to new packet-based config
                // Typical parameters conversion: assume each cycle contained 1 packet
                config.numGroups = stream->m_numSegments;
                config.packetsPerGroup = stream->m_cyclesPerSegment;
                config.packetDataSize = stream->m_bufferSize;
                config.callbackGroupInterval = 1; // Default to callback every group
                
                // Create a component factory for the receiver
                auto receiver = Isoch::ReceiverFactory::createStandardReceiver(config);
                
                // Initialize the receiver with the device interface
                stream->m_logger->info("AudioDeviceStream: Initializing AmdtpReceiver for plug {}", devicePlugNumber);
                auto initResult = receiver->initialize(interface);
                if (!initResult.has_value()) {
                    stream->m_logger->error("AudioDeviceStream: Failed to initialize AmdtpReceiver: {}",
                                            iokit_error_category().message(static_cast<int>(initResult.error())));
                    return std::unexpected(initResult.error());
                }
                
                // Store the implementation first, then set up callbacks
                stream->m_streamImpl = receiver;
                
                // Set up callbacks with proper refcon handling
                stream->setupReceiverCallbacks(receiver);
                
                stream->m_logger->info("AudioDeviceStream: Created AmdtpReceiver for plug {}", devicePlugNumber);
            }
            catch (const std::exception& ex) {
                stream->m_logger->error("AudioDeviceStream: Exception creating AmdtpReceiver: {}", ex.what());
                return std::unexpected(IOKitError::Error);
            }
            break;
        }
            
        case StreamType::AmdtpTransmitter: {
            try {
                // Configure the transmitter with the packet-based parameters
                Isoch::TransmitterConfig txConfig;
                txConfig.logger = stream->m_logger;
                
                // Set transmitter parameters
                txConfig.numGroups = stream->m_numSegments;
                txConfig.packetsPerGroup = stream->m_cyclesPerSegment;
                txConfig.clientBufferSize = stream->m_bufferSize;
                txConfig.sampleRate = 44100.0; // Default sample rate
                txConfig.numChannels = 2;      // Default stereo
                txConfig.initialSpeed = speed;
                
                // Create the transmitter
                auto transmitter = Isoch::AmdtpTransmitter::create(txConfig);
                
                // Initialize the transmitter with the device interface
                stream->m_logger->info("AudioDeviceStream: Initializing AmdtpTransmitter for plug {}", devicePlugNumber);
                auto initResult = transmitter->initialize(interface);
                if (!initResult.has_value()) {
                    stream->m_logger->error("AudioDeviceStream: Failed to initialize AmdtpTransmitter: {}",
                                           iokit_error_category().message(static_cast<int>(initResult.error())));
                    return std::unexpected(initResult.error());
                }
                
                // Store the implementation
                stream->m_streamImpl = transmitter;
                
                // Set up message callback
                if (messageCallback) {
                    transmitter->setMessageCallback(messageCallback, messageRefCon);
                }
                
                stream->m_logger->info("AudioDeviceStream: Created AmdtpTransmitter for plug {}", devicePlugNumber);
            }
            catch (const std::exception& ex) {
                stream->m_logger->error("AudioDeviceStream: Exception creating AmdtpTransmitter: {}", ex.what());
                return std::unexpected(IOKitError::Error);
            }
            break;
        }
            
        case StreamType::UniversalReceiver:
        case StreamType::UniversalTransmitter:
            stream->m_logger->error("AudioDeviceStream: Legacy stream types not supported");
            return std::unexpected(IOKitError::Unsupported);
            
        default:
            return std::unexpected(IOKitError::BadArgument);
    }
    
    return stream;
}

std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> AudioDeviceStream::createReceiverForDevicePlug(
                                                                                                             std::shared_ptr<AudioDevice> audioDevice,
                                                                                                             uint8_t devicePlugNumber,
                                                                                                             Isoch::PacketCallback dataPushCallback,
                                                                                                             void* dataPushRefCon,
                                                                                                             Isoch::MessageCallback messageCallback,
                                                                                                             void* messageRefCon,
                                                                                                             std::shared_ptr<spdlog::logger> logger,
                                                                                                             unsigned int cyclesPerSegment,
                                                                                                             unsigned int numSegments,
                                                                                                             unsigned int cycleBufferSize,
                                                                                                             IOFireWireLibDeviceRef interface
                                                                                                             )
{
    // Use the general create method with specific parameters for a receiver
    return create(
                  std::move(audioDevice),
                  StreamType::AmdtpReceiver,
                  devicePlugNumber,
                  std::move(logger),
                  dataPushCallback,
                  dataPushRefCon,
                  messageCallback,
                  messageRefCon,
                  cyclesPerSegment,
                  numSegments,
                  cycleBufferSize,
                  kFWSpeed100MBit,  // Default speed, can be changed later
                  interface
                  );
}

std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> AudioDeviceStream::createTransmitterForDevicePlug(
                                                                                                                std::shared_ptr<AudioDevice> audioDevice,
                                                                                                                uint8_t devicePlugNumber,
                                                                                                                Isoch::PacketCallback dataPullCallback,
                                                                                                                void* dataPullRefCon,
                                                                                                                Isoch::MessageCallback messageCallback,
                                                                                                                void* messageRefCon,
                                                                                                                std::shared_ptr<spdlog::logger> logger,
                                                                                                                unsigned int cyclesPerSegment,
                                                                                                                unsigned int numSegments,
                                                                                                                unsigned int transmitBufferSize,
                                                                                                                IOFireWireLibDeviceRef interface
                                                                                                                )
{
    // Use the general create method with specific parameters for a transmitter
    return create(
                  std::move(audioDevice),
                  StreamType::AmdtpTransmitter,
                  devicePlugNumber,
                  std::move(logger),
                  nullptr,                // No data push callback for transmitter
                  nullptr,                // No refCon for data push
                  messageCallback,
                  messageRefCon,
                  cyclesPerSegment,
                  numSegments,
                  transmitBufferSize,
                  kFWSpeed100MBit,        // Default speed, can be changed later
                  interface
                  );
}

std::expected<void, IOKitError> AudioDeviceStream::start()
{
    if (m_isActive) {
        return {};  // Already active, nothing to do
    }
    
    // Ensure we have a connection to the device plug
    if (!m_isPlugConnected) {
        auto connectResult = connectPlug();
        if (!connectResult) {
            return std::unexpected(connectResult.error());
        }
    }
    
    // Handle different stream types
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        
        auto result = receiver->startReceive();
        if (!result.has_value()) {
            m_logger->error("AudioDeviceStream: Failed to start AmdtpReceiver: {}",
                            iokit_error_category().message(static_cast<int>(result.error())));
            return std::unexpected(result.error());
        }
    }
    else if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        auto transmitter = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        
        auto result = transmitter->startTransmit();
        if (!result.has_value()) {
            m_logger->error("AudioDeviceStream: Failed to start AmdtpTransmitter: {}",
                           iokit_error_category().message(static_cast<int>(result.error())));
            return std::unexpected(result.error());
        }
    }
    else {
        m_logger->warn("AudioDeviceStream: Unsupported stream type");
        return std::unexpected(IOKitError::Unsupported);
    }
    
    m_isActive = true;
    m_logger->info("AudioDeviceStream: Started stream for plug {}", m_devicePlugNumber);
    return {};
}

std::expected<void, IOKitError> AudioDeviceStream::stop()
{
    if (!m_isActive) {
        return {};  // Already stopped, nothing to do
    }
    
    // Handle different stream types
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        
        auto result = receiver->stopReceive();
        if (!result.has_value()) {
            m_logger->error("AudioDeviceStream: Failed to stop AmdtpReceiver: {}",
                            iokit_error_category().message(static_cast<int>(result.error())));
            return std::unexpected(result.error());
        }
    }
    else if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        auto transmitter = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        
        auto result = transmitter->stopTransmit();
        if (!result.has_value()) {
            m_logger->error("AudioDeviceStream: Failed to stop AmdtpTransmitter: {}",
                           iokit_error_category().message(static_cast<int>(result.error())));
            return std::unexpected(result.error());
        }
    }
    else {
        m_logger->warn("AudioDeviceStream: Unsupported stream type");
        return std::unexpected(IOKitError::Unsupported);
    }
    
    m_isActive = false;
    m_logger->info("AudioDeviceStream: Stopped stream for plug {}", m_devicePlugNumber);
    return {};
}

void AudioDeviceStream::setMessageCallback(Isoch::MessageCallback callback, void* refCon)
{
    m_messageCallback = callback;
    m_messageCallbackRefCon = refCon;
    
    // Update the callback in the stream implementation if it exists
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        setupReceiverCallbacks(receiver);  // Use the helper to set up callbacks properly
        m_logger->info("AudioDeviceStream: Updated message callback for AmdtpReceiver");
    }
    else {
        m_logger->warn("AudioDeviceStream: Cannot update message callback for this stream type");
    }
}

void AudioDeviceStream::setPacketCallback(Isoch::PacketCallback callback, void* refCon)
{
//    logCallbackThreadInfo("AudioDeviceStream", "setPacketCallback", this);
    m_packetCallback = callback;
    m_packetCallbackRefCon = refCon;
    
    // Update the callback in the stream implementation if it exists
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        setupReceiverCallbacks(receiver);  // Use the helper to set up callbacks properly
        m_logger->info("AudioDeviceStream: Updated packet callback for AmdtpReceiver");
    }
    else {
        m_logger->warn("AudioDeviceStream: Cannot update packet callback for this stream type");
    }
}

void AudioDeviceStream::setPacketPullCallback(Isoch::PacketCallback callback, void* refCon)
{
    m_packetPullCallback = callback;
    m_packetPullCallbackRefCon = refCon;
    
    // Transmitter not yet implemented
    m_logger->warn("AudioDeviceStream: Cannot update packet pull callback, transmitter not implemented");
}

std::expected<void, IOKitError> AudioDeviceStream::initializeRunLoop() {
    // Just use the current thread's RunLoop - no need for a separate thread
    m_runLoop = CFRunLoopGetCurrent();
    
    if (m_logger) {
        m_logger->info("AudioDeviceStream: Using RunLoop={:p} from thread {}",
                     (void*)m_runLoop,
                     static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())));
    }
    
    // Add FireWire dispatchers directly to this thread's RunLoop
    if (m_interface) {
        IOReturn ret = (*m_interface)->AddCallbackDispatcherToRunLoop(m_interface, m_runLoop);
        if (ret != kIOReturnSuccess) {
            m_logger->error("AudioDeviceStream: Failed to add callback dispatcher: 0x{:08X}", ret);
            return std::unexpected(static_cast<IOKitError>(ret));
        }
        
        ret = (*m_interface)->AddIsochCallbackDispatcherToRunLoop(m_interface, m_runLoop);
        if (ret != kIOReturnSuccess) {
            m_logger->error("AudioDeviceStream: Failed to add isoch callback dispatcher: 0x{:08X}", ret);
            return std::unexpected(static_cast<IOKitError>(ret));
        }
        
        m_logger->info("AudioDeviceStream: Added FireWire dispatchers to current thread's RunLoop");
    }
    
    // make thread real-time
    makeRunLoopThreadRealTime();
    
    return {};
}

// void AudioDeviceStream::runLoopThreadFunc()
// {
//     // Create the RunLoop for this thread
//     m_runLoop = CFRunLoopGetCurrent();
//     m_logger->info("AudioDeviceStream: RunLoop created in thread {}",
//                    static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())));
    
//     // Log RunLoop creation using RunLoopHelper
//     logRunLoopInfo("AudioDeviceStream", "runLoopThreadFunc", m_runLoop);
    
//     // Add the necessary callback dispatchers for FireWire
//     if (m_interface) {
//         // Add the regular callback dispatcher
//         IOReturn ret = (*m_interface)->AddCallbackDispatcherToRunLoop(m_interface, m_runLoop);
//         if (ret != kIOReturnSuccess) {
//             m_logger->error("AudioDeviceStream: Failed to add callback dispatcher to RunLoop: 0x{:08X}", ret);
//             return;
//         }
        
//         // Add the isoch callback dispatcher
//         ret = (*m_interface)->AddIsochCallbackDispatcherToRunLoop(m_interface, m_runLoop);
//         if (ret != kIOReturnSuccess) {
//             m_logger->error("AudioDeviceStream: Failed to add isoch callback dispatcher to RunLoop: 0x{:08X}", ret);
//             return;
//         }
        
//         m_logger->info("AudioDeviceStream: Added FireWire callback dispatchers to RunLoop");
//     }
    
//     // Run the loop until told to stop
//     while (m_runLoopActive) {
//         // Run with a timeout so we can periodically check if we should stop
//         CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
//     }
    
//     m_logger->info("AudioDeviceStream: RunLoop thread exiting");
// }

//void AudioDeviceStream::runLoopThreadFunc() {
//    // Create the RunLoop for this thread
//    m_runLoop = CFRunLoopGetCurrent();
//    
//    if (logger_) {
//        logger_->info("AudioDeviceStream: RunLoop created in thread {}", 
//                     static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())));
//    }
    
//    // Log RunLoop creation using RunLoopHelper
//    logRunLoopInfo("AudioDeviceStream", "runLoopThreadFunc", m_runLoop);
//    
//    // Add the necessary callback dispatchers for FireWire
//    if (m_interface) {
//        // Add the regular callback dispatcher
//        IOReturn ret = (*m_interface)->AddCallbackDispatcherToRunLoop(m_interface, m_runLoop);
//        if (ret != kIOReturnSuccess) {
//            logger_->error("AudioDeviceStream: Failed to add callback dispatcher: 0x{:08X}", ret);
//        }
//        
//        // CRITICAL CHANGE: For isoch callbacks, set returnAfterRegistering to true
//        // This allows FireWire isoch callbacks to bypass the RunLoop for better responsiveness
//        ret = (*m_interface)->AddIsochCallbackDispatcherToRunLoop(m_interface, m_runLoop);
//        if (ret != kIOReturnSuccess) {
//            logger_->error("AudioDeviceStream: Failed to add isoch callback dispatcher: 0x{:08X}", ret);
//        }
//        
//        logger_->info("AudioDeviceStream: Added FireWire callback dispatchers to RunLoop");
//    }
    
//    // CRITICAL CHANGE: Run the loop with returnAfterSourceHandled = TRUE
//    while (m_runLoopActive) {
//        // Run with short timeout and IMMEDIATELY return after source handled
//        CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.001, true);
//    }
//    
//    logger_->info("AudioDeviceStream: RunLoop thread exiting");
//}

void AudioDeviceStream::makeRunLoopThreadRealTime()
{
    // Set real-time priority for the RunLoop thread
    thread_time_constraint_policy_data_t policy;
    mach_port_t thread = pthread_mach_thread_np(m_runLoopThread.native_handle());
    
    // Configure the real-time constraints
    // These values need to be tuned for your specific audio requirements
    policy.period = 1000000;      // 1ms in absolute time units
    policy.computation = 500000;  // 0.5ms of computation time
    policy.constraint = 1000000;  // 1ms hard deadline
    policy.preemptible = 1;
    
    // Apply the policy
    kern_return_t result = thread_policy_set(
                                             thread,
                                             THREAD_TIME_CONSTRAINT_POLICY,
                                             (thread_policy_t)&policy,
                                             THREAD_TIME_CONSTRAINT_POLICY_COUNT
                                             );
    
    if (result == KERN_SUCCESS) {
        m_logger->info("AudioDeviceStream: Successfully set thread to real-time priority");
    } else {
        m_logger->warn("AudioDeviceStream: Failed to set thread to real-time priority, error: {}", result);
    }
}

std::expected<void, IOKitError> AudioDeviceStream::connectPlug()
{
    if (m_isPlugConnected) {
        return {};  // Already connected
    }
    
    // Implementation depends on stream type and plug direction
    switch (m_streamType) {
        case StreamType::AmdtpReceiver: {
            // For receiver, connect to output plug on device
            auto device = m_audioDevice;
            if (!device) {
                return std::unexpected(IOKitError::NoDevice);
            }
            
            auto cmdInterface = device->getCommandInterface();
            if (!cmdInterface) {
                return std::unexpected(IOKitError::NotReady);
            }
            
            // Access the avcInterface using the getter method
            auto avcInterface = cmdInterface->getAVCInterface();
            if (!avcInterface) {
                return std::unexpected(IOKitError::NotReady);
            }
            
            m_logger->info("AudioDeviceStream: Connecting to device output plug {} on channel {}",
                           m_devicePlugNumber, m_isochChannel);
            
            // Connect to the device's output plug using the built-in makeP2POutputConnection
            IOReturn result = (*avcInterface)->makeP2POutputConnection(
                                                                       avcInterface,
                                                                       m_devicePlugNumber,  // The device plug number
                                                                       m_isochChannel,      // The isochronous channel to use
                                                                       m_isochSpeed         // The speed to use
                                                                       );
            
            if (result != kIOReturnSuccess) {
                m_logger->error("AudioDeviceStream: Failed to connect to device output plug {}: 0x{:x}",
                                m_devicePlugNumber, result);
                // Convert IOReturn to our IOKitError enum
                return std::unexpected(static_cast<IOKitError>(result));
            }
            
            m_logger->info("AudioDeviceStream: Connected to device output plug {} on channel {}",
                           m_devicePlugNumber, m_isochChannel);
            m_isPlugConnected = true;
            break;
        }
            
        case StreamType::AmdtpTransmitter: {
            auto device = m_audioDevice;
            if (!device) return std::unexpected(IOKitError::NoDevice);
            auto cmdInterface = device->getCommandInterface();
            if (!cmdInterface) return std::unexpected(IOKitError::NotReady);
            auto avcInterface = cmdInterface->getAVCInterface();
            if (!avcInterface) return std::unexpected(IOKitError::NotReady);

            m_logger->info("AudioDeviceStream: Connecting to device INPUT plug {} on channel {}",
                       m_devicePlugNumber, m_isochChannel);

            // Connect to the device's *input* plug for transmitting
            IOReturn result = (*avcInterface)->makeP2PInputConnection(
                avcInterface,
                m_devicePlugNumber,  // The device *input* plug number
                m_isochChannel      // The isochronous channel to use
            );

            if (result != kIOReturnSuccess) {
                m_logger->error("AudioDeviceStream: Failed to connect to device input plug {}: 0x{:x}",
                            m_devicePlugNumber, result);
                return std::unexpected(static_cast<IOKitError>(result));
            }

            m_logger->info("AudioDeviceStream: Connected to device input plug {} on channel {}",
                       m_devicePlugNumber, m_isochChannel);
            m_isPlugConnected = true;
            break;
        }
            
        default:
            return std::unexpected(IOKitError::Unsupported);
    }
    
    return {};
}

std::expected<void, IOKitError> AudioDeviceStream::disconnectPlug()
{
    if (!m_isPlugConnected) {
        return {};  // Already disconnected
    }
    
    // Implementation depends on stream type and plug direction
    switch (m_streamType) {
        case StreamType::AmdtpReceiver: {
            // For receiver, disconnect from output plug on device
            auto device = m_audioDevice;
            if (!device) {
                return std::unexpected(IOKitError::NoDevice);
            }
            
            auto cmdInterface = device->getCommandInterface();
            if (!cmdInterface) {
                return std::unexpected(IOKitError::NotReady);
            }
            
            // Access the avcInterface using the getter method
            auto avcInterface = cmdInterface->getAVCInterface();
            if (!avcInterface) {
                return std::unexpected(IOKitError::NotReady);
            }
            
            // Disconnect from the device's output plug using the built-in breakP2POutputConnection
            IOReturn result = (*avcInterface)->breakP2POutputConnection(
                                                                        avcInterface,
                                                                        m_devicePlugNumber  // The device plug number
                                                                        );
            
            if (result != kIOReturnSuccess) {
                m_logger->error("AudioDeviceStream: Failed to disconnect from device output plug {}: 0x{:x}",
                                m_devicePlugNumber, result);
                // Convert IOReturn to our IOKitError enum
                return std::unexpected(static_cast<IOKitError>(result));
            }
            
            m_logger->info("AudioDeviceStream: Disconnected from device output plug {}", m_devicePlugNumber);
            m_isPlugConnected = false;
            break;
        }
            
        case StreamType::AmdtpTransmitter: {
            auto device = m_audioDevice;
            if (!device) return std::unexpected(IOKitError::NoDevice);
            auto cmdInterface = device->getCommandInterface();
            if (!cmdInterface) return std::unexpected(IOKitError::NotReady);
            auto avcInterface = cmdInterface->getAVCInterface();
            if (!avcInterface) return std::unexpected(IOKitError::NotReady);

            m_logger->info("AudioDeviceStream: Disconnecting from device input plug {}", m_devicePlugNumber);

            // Disconnect from the device's *input* plug
            IOReturn result = (*avcInterface)->breakP2PInputConnection(
                avcInterface,
                m_devicePlugNumber  // The device input plug number
            );

            if (result != kIOReturnSuccess) {
                m_logger->error("AudioDeviceStream: Failed to disconnect from device input plug {}: 0x{:x}",
                            m_devicePlugNumber, result);
                return std::unexpected(static_cast<IOKitError>(result));
            }

            m_logger->info("AudioDeviceStream: Disconnected from device input plug {}", m_devicePlugNumber);
            m_isPlugConnected = false;
            break;
        }
            
        default:
            return std::unexpected(IOKitError::Unsupported);
    }
    
    return {};
}

// Static callback handler implementations with correct signatures
void AudioDeviceStream::handlePacketReceived(const uint8_t* data, size_t length, void* refCon)
{
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("AudioDeviceStream", "handlePacketReceived", refCon);
    
    // Cast refCon to AudioDeviceStream
    auto* self = static_cast<AudioDeviceStream*>(refCon);
    
    // Call the user-provided callback with the RefCon
    if (self && self->m_packetCallback) {
        self->m_packetCallback(data, length, self->m_packetCallbackRefCon);
    }
}

// New static handler for processed data
void AudioDeviceStream::handleProcessedDataStatic(
    const std::vector<Isoch::ProcessedSample>& samples,
    const Isoch::PacketTimingInfo& timing,
    void* refCon)
{
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("AudioDeviceStream", "handleProcessedDataStatic", refCon);
    
    // Cast refCon to AudioDeviceStream
    auto* self = static_cast<AudioDeviceStream*>(refCon);
    
    // Forward to instance method
    if (self) {
        self->handleProcessedDataImpl(samples, timing);
    }
}

// New instance method to handle processed data
void AudioDeviceStream::handleProcessedDataImpl(
    const std::vector<Isoch::ProcessedSample>& samples,
    const Isoch::PacketTimingInfo& timing)
{
    // For backward compatibility with clients expecting raw packets:
    // Call the legacy packet callback with nullptr to signal data arrival
    // The client should eventually transition to reading from ring buffer directly
    if (m_packetCallback) {
        m_logger->trace("Forwarding processed data arrival ({} samples) to legacy packet callback",
                      samples.size());
        m_packetCallback(nullptr, 0, m_packetCallbackRefCon);
    }
}

void AudioDeviceStream::handleMessageReceived(uint32_t message, uint32_t param1, uint32_t param2, void* refCon)
{
    // Log callback using RunLoopHelper
    logCallbackThreadInfo("AudioDeviceStream", "handleMessageReceived", refCon);
    
    // Cast refCon to AudioDeviceStream
    auto* self = static_cast<AudioDeviceStream*>(refCon);
    
    // Call the user-provided callback with the RefCon
    if (self && self->m_messageCallback) {
        self->m_messageCallback(message, param1, param2, self->m_messageCallbackRefCon);
    }
}

// Modified implementation to use the new callback mechanism
void AudioDeviceStream::setupReceiverCallbacks(std::shared_ptr<Isoch::AmdtpReceiver> receiver)
{
    if (!receiver) {
        m_logger->error("Cannot setup callbacks for null receiver");
        return;
    }
    
    // Set up the processed data callback with this instance as refCon
    receiver->setProcessedDataCallback(handleProcessedDataStatic, this);
    m_logger->info("[AudioDeviceStream] Receiver processed data callback set up with refCon: {}", (void*)this);
    
    // Set up the message callback with this instance as refCon
    receiver->setMessageCallback(handleMessageReceived, this);
    
    m_logger->info("Receiver callbacks set up successfully");
}

std::expected<void, IOKitError> AudioDeviceStream::setIsochChannel(uint32_t channel)
{
    if (m_isActive) {
        m_logger->error("AudioDeviceStream: Cannot change channel while stream is active");
        return std::unexpected(IOKitError::Busy);
    }
    
    m_isochChannel = channel;
    m_logger->info("AudioDeviceStream: Set isochronous channel to {}", channel);
    
    // Configure the channel in the stream implementation
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        return receiver->configure(m_isochSpeed, channel);
    }
    else if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        auto transmitter = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        return transmitter->configure(m_isochSpeed, channel);
    }
    else {
        m_logger->warn("AudioDeviceStream: Cannot set channel for this stream type");
        return std::unexpected(IOKitError::Unsupported);
    }
}

std::expected<void, IOKitError> AudioDeviceStream::setIsochSpeed(IOFWSpeed speed)
{
    if (m_isActive) {
        m_logger->error("AudioDeviceStream: Cannot change speed while stream is active");
        return std::unexpected(IOKitError::Busy);
    }
    
    m_isochSpeed = speed;
    m_logger->info("AudioDeviceStream: Set isochronous speed to {}", static_cast<int>(speed));
    
    // Configure the speed in the stream implementation
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        return receiver->configure(speed, m_isochChannel);
    }
    else if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        auto transmitter = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        return transmitter->configure(speed, m_isochChannel);
    }
    else {
        m_logger->warn("AudioDeviceStream: Cannot set speed for this stream type");
        return std::unexpected(IOKitError::Unsupported);
    }
}

std::expected<void, IOKitError> AudioDeviceStream::checkIOReturn(IOReturn result)
{
    if (result != kIOReturnSuccess) {
        return std::unexpected(static_cast<IOKitError>(result));
    }
    return {};
}

raul::RingBuffer* AudioDeviceStream::getReceiverRingBuffer() const {
    // Check if the variant holds an AmdtpReceiver
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl)) {
        // Get the receiver shared_ptr
        auto receiver = std::get<std::shared_ptr<Isoch::AmdtpReceiver>>(m_streamImpl);
        if (receiver) {
            // Call the receiver's accessor method
            return receiver->getAppRingBuffer();
        } else {
            // Log if receiver pointer is somehow null (shouldn't happen if variant holds it)
            if(m_logger) m_logger->error("AudioDeviceStream::getReceiverRingBuffer: Held receiver pointer is null!");
            return nullptr;
        }
    } else {
        // This stream is not an AmdtpReceiver type
        // if(m_logger) m_logger->trace("AudioDeviceStream::getReceiverRingBuffer: Stream is not an AmdtpReceiver.");
        return nullptr;
    }
}

bool AudioDeviceStream::pushTransmitData(const void* buffer, size_t bufferSizeInBytes) {
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        auto transmitter = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        if (transmitter) {
            return transmitter->pushAudioData(buffer, bufferSizeInBytes);
        }
    }
    if (m_logger) m_logger->warn("pushTransmitData called on non-transmitter stream");
    return false;
}

Isoch::ITransmitPacketProvider* AudioDeviceStream::getTransmitPacketProvider() const {
    if (std::holds_alternative<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl)) {
        // Get the underlying transmitter object
        const auto& transmitter_ptr = std::get<std::shared_ptr<Isoch::AmdtpTransmitter>>(m_streamImpl);
        if (transmitter_ptr) {
            // Call the transmitter's getter
            return transmitter_ptr->getPacketProvider();
        } else {
             if (m_logger) m_logger->error("getTransmitPacketProvider: Transmitter pointer in variant is null!");
        }
    } else {
         if (m_logger) m_logger->trace("getTransmitPacketProvider: Stream is not a transmitter.");
    }
    return nullptr; // Return null if not a transmitter or not initialized
}

} // namespace FWA



=== src/Isoch/utils/RunLoopHelper.cpp ===
#include "Isoch/utils/RunLoopHelper.hpp"
#include <spdlog/spdlog.h>
#include <pthread.h>

void logRunLoopInfo(const char* className, const char* functionName, CFRunLoopRef runLoop) {
    spdlog::info("[RunLoop] Class: {} | Function: {} | CFRunLoopRef: {} | Thread ID: {}",
                 className, functionName, (void*)runLoop, (unsigned long)pthread_self());
}

void logCallbackThreadInfo(const char* className, const char* callbackName, void* refcon) {
    spdlog::info("[Callback] Class: {} | Function: {} | Thread ID: {} | refcon: {}",
                 className, callbackName, (unsigned long)pthread_self(), (void*)refcon);
}



=== src/Isoch/IsoStreamHandler.cpp ===
#include "Isoch/IsoStreamHandler.hpp"
#include <cstdio>
#include <cmath>
#include <unistd.h>
#include <iostream>
#include "FWA/XPC/XPCBridge.h"
#include <spdlog/spdlog.h>
#include <mach/mach_time.h>
#include <mach/thread_policy.h>
#include <mach/mach.h>
#include <pthread.h>
#include "Isoch/utils/RunLoopHelper.hpp"
#include <fstream> // For file output
#include <string>  // For filename
#include <vector>  // To buffer samples before writing
#include <chrono>  // For sleep_for & time points
#include <ctime>   // For std::time
#include "Isoch/interfaces/ITransmitPacketProvider.hpp" // Include for the packet provider interface

// Define stream direction enable/disable flags
#define RECEIVE 0  // Set to 0 to disable receiver (input stream)
#define TRANSMIT 1 // Set to 0 to disable transmitter (output stream)

// Define RECORD macro - Set to 0 to disable recording
#define RECORD 0

namespace FWA {

IsoStreamHandler::IsoStreamHandler(std::shared_ptr<AudioDevice> device,
                                   std::shared_ptr<spdlog::logger> logger,
                                   std::shared_ptr<CommandInterface> commandInterface,
                                   IOFireWireLibDeviceRef interface)
: m_audioDevice(std::move(device))
, m_logger(std::move(logger))
, m_commandInterface(std::move(commandInterface))
, m_lastTimestamp(std::chrono::steady_clock::now())
, m_lastTransmitterTimestamp(std::chrono::steady_clock::now())
, m_interface(interface)
, m_processingRunning(false)
, m_inputStream(nullptr) // Initialize stream pointers
, m_outputStream(nullptr)
#ifdef __OBJC__
, m_xpcClient(nil)
#endif
{
    if (!m_logger) {
        m_logger = spdlog::default_logger();
    }

    m_logger->info("IsoStreamHandler: Initialized");

    UInt32 outGeneration = 0;

    // Get the generation count for the device
    auto result = (*interface)->GetBusGeneration(interface, &outGeneration);

    UInt16 nodeId = 0;
    result = (*interface)->GetRemoteNodeID(interface, outGeneration, &nodeId);
    if (result != kIOReturnSuccess) {
        m_logger->error("IsoStreamHandler: Failed to get node ID");
    } else {
        m_nodeId = nodeId;
        m_logger->info("IsoStreamHandler: Node ID: {}", m_nodeId);
    }

    // --- Initialize XPC Bridge HERE ---
#if TRANSMIT
    m_logger->info("IsoStreamHandler Constructor: Initializing XPC Bridge...");
    try {
        // Initialize XPC Bridge without a specific processor
        m_logger->info("IsoStreamHandler Constructor: Initializing XPC Bridge...");
        XPCBridgeInitialize(nullptr); // Pass null for now, this interface needs to be updated
        m_logger->info("IsoStreamHandler Constructor: XPC Bridge initialized.");

    } catch (const std::exception& e) {
        m_logger->error("IsoStreamHandler Constructor: Exception creating processor/XPC: {}", e.what());
        // Handle error state
        return;
    } catch (...) {
        m_logger->error("IsoStreamHandler Constructor: Unknown exception creating processor/XPC.");
        // Handle error state
        return;
    }
#else
    // Even if transmitter is disabled, initialize XPC bridge, but pass nullptr
    m_logger->info("IsoStreamHandler Constructor: Transmitter disabled, initializing XPC bridge with null processor.");
    XPCBridgeInitialize(nullptr);
#endif
    // --- End Processor and XPC Init ---
}

IsoStreamHandler::~IsoStreamHandler() {
    stop();

#ifdef __OBJC__
    @autoreleasepool {
        if (m_xpcClient) {
            [m_xpcClient release];
            m_xpcClient = nil;
        }
    }
#endif

    m_logger->info("IsoStreamHandler: Destroyed");
}

std::expected<void, IOKitError> IsoStreamHandler::start() {
    std::lock_guard<std::mutex> lock(m_streamMutex);
    m_logger->info("IsoStreamHandler: Starting streams (RECEIVE={}, TRANSMIT={})", RECEIVE, TRANSMIT);

    // Update bus generation
    UInt32 outGeneration = 0;

    m_logger->debug("IsoStreamHandler: Getting bus generation");
    auto result = (*m_interface)->GetBusGeneration(m_interface, &outGeneration);

    if (result != kIOReturnSuccess) {
        m_logger->error("IsoStreamHandler: Failed to get bus generation");
        return std::unexpected(IOKitError::InternalError);
    }

    // Get FW speed
    m_logger->debug("IsoStreamHandler: Getting speed");
    result = (*m_interface)->GetSpeedToNode(m_interface, outGeneration, &m_speed);

    if (result != kIOReturnSuccess) {
        // Set minimum speed as fallback
        m_speed = kFWSpeed100MBit;
        m_logger->warn("IsoStreamHandler: Failed to get speed, defaulting to 100Mbps");
    }

    switch (m_speed) {
        case kFWSpeed100MBit: m_logger->info("IsoStreamHandler: Speed: 100Mbps"); break;
        case kFWSpeed200MBit: m_logger->info("IsoStreamHandler: Speed: 200Mbps"); break;
        case kFWSpeed400MBit: m_logger->info("IsoStreamHandler: Speed: 400Mbps"); break;
        case kFWSpeed800MBit: m_logger->info("IsoStreamHandler: Speed: 800Mbps"); break;
        default: m_logger->info("IsoStreamHandler: Unknown speed ({}), defaulting to 100Mbps", static_cast<int>(m_speed)); m_speed = kFWSpeed100MBit; break;
    }

#if RECEIVE
    // --- Create Input Stream (Receiver) ---
    // Common parameters (can be adjusted)
    const unsigned int rxPacketsPerGroup = 16;
    const unsigned int rxNumGroups = 2;
    const unsigned int rxPacketDataSize = 64; // Expected audio payload size per packet

    m_logger->info("IsoStreamHandler: Creating receiver stream with: packetsPerGroup={}, numGroups={}, packetDataSize={}",
                   rxPacketsPerGroup, rxNumGroups, rxPacketDataSize);

    // Assume device OUTPUT plug 0 for receiving audio FROM device
    uint8_t receivePlugNum = 0;

    auto inputStreamResult = AudioDeviceStream::createReceiverForDevicePlug(
        m_audioDevice,
        receivePlugNum,
        &IsoStreamHandler::handleDataPush, // Static callback
        this, // RefCon for data callback is 'this' pointer
        &IsoStreamHandler::handleMessage,  // Static callback
        this, // RefCon for message callback is 'this' pointer
        m_logger,
        rxPacketsPerGroup, // cyclesPerSegment equivalent
        rxNumGroups,       // numSegments equivalent
        rxPacketDataSize,  // Size of each *packet's* data area
        m_interface
    );

    if (!inputStreamResult) {
        m_logger->error("IsoStreamHandler: Failed to create input stream: {}",
                       iokit_error_category().message(static_cast<int>(inputStreamResult.error())));
        return std::unexpected(inputStreamResult.error());
    }

    m_inputStream = inputStreamResult.value();
    m_logger->info("IsoStreamHandler: Input stream created successfully");

    // Configure the input stream speed
    auto rxSpeedResult = m_inputStream->setIsochSpeed(m_speed);
    if (!rxSpeedResult) {
        m_logger->error("IsoStreamHandler: Failed to set input stream speed: {}",
                       iokit_error_category().message(static_cast<int>(rxSpeedResult.error())));
        m_inputStream.reset(); // Clean up partially configured stream
        return std::unexpected(rxSpeedResult.error());
    }

    // Start the input stream
    auto rxStartResult = m_inputStream->start();
    if (!rxStartResult) {
        m_logger->error("IsoStreamHandler: Failed to start input stream: {}",
                       iokit_error_category().message(static_cast<int>(rxStartResult.error())));
        m_inputStream.reset(); // Clean up
        return std::unexpected(rxStartResult.error());
    }
    m_logger->info("IsoStreamHandler: Input stream started");
#else // RECEIVE == 0
    m_logger->info("IsoStreamHandler: Receiver disabled by build configuration.");
#endif // RECEIVE


#if TRANSMIT
    // --- Create Output Stream (Transmitter) ---
    m_logger->info("IsoStreamHandler: Creating transmitter stream...");

    // Use potentially different/appropriate config for transmitter if needed
    const unsigned int txPacketsPerGroup = 16;
    const unsigned int txNumGroups = 2;
    const unsigned int txPacketDataSize = 64; // Audio payload size per packet
    unsigned int transmitProviderBufferSize = 2 * txNumGroups * txPacketsPerGroup * txPacketDataSize; // Example buffer size

    m_logger->info("IsoStreamHandler: Creating transmitter stream with: packetsPerGroup={}, numGroups={}, transmitProviderBufferSize={}",
                   txPacketsPerGroup, txNumGroups, transmitProviderBufferSize);

    // --- REMOVED check for m_amdtpTxProcessor ---
    // The check for m_amdtpTxProcessor has been removed as it's no longer a member variable
    // We don't need to check for this processor anymore before creating the output stream

    // Assume device INPUT plug 0 for transmitting audio TO device
    uint8_t transmitPlugNum = 0;

    auto outputStreamResult = AudioDeviceStream::createTransmitterForDevicePlug(
        m_audioDevice,
        transmitPlugNum,
        nullptr, // No data pull callback needed from handler side
        nullptr, // Refcon for pull callback
        &IsoStreamHandler::handleMessage, // Reuse message handler for errors/status
        this, // RefCon for message handler
        m_logger,
        txPacketsPerGroup, // Use same cycle/segment config for DCL structure
        txNumGroups,
        transmitProviderBufferSize, // Buffer size for the internal provider
        m_interface
    );

    if (!outputStreamResult) {
        m_logger->error("IsoStreamHandler: Failed to create output stream: {}",
                       iokit_error_category().message(static_cast<int>(outputStreamResult.error())));
        // Clean up input stream if output stream creation fails
#if RECEIVE
        if (m_inputStream) m_inputStream->stop();
        m_inputStream.reset();
#endif
        return std::unexpected(outputStreamResult.error());
    }

    m_outputStream = outputStreamResult.value();
    m_logger->info("IsoStreamHandler: Output stream created successfully");

    // Configure the output stream speed
    auto txSpeedResult = m_outputStream->setIsochSpeed(m_speed);
    if (!txSpeedResult) {
        m_logger->error("IsoStreamHandler: Failed to set output stream speed: {}",
                       iokit_error_category().message(static_cast<int>(txSpeedResult.error())));
#if RECEIVE
        if (m_inputStream) m_inputStream->stop(); m_inputStream.reset();
#endif
        m_outputStream.reset(); // Clean up output stream too
        return std::unexpected(txSpeedResult.error());
    }

    // Start the output stream
    auto txStartResult = m_outputStream->start();
    if (!txStartResult) {
        m_logger->error("IsoStreamHandler: Failed to start output stream: {}",
                       iokit_error_category().message(static_cast<int>(txStartResult.error())));
#if RECEIVE
        if (m_inputStream) m_inputStream->stop(); m_inputStream.reset();
#endif
        m_outputStream.reset();
        return std::unexpected(txStartResult.error());
    }
    m_logger->info("IsoStreamHandler: Output stream started");

    // --- Initialize XPC Bridge AFTER output stream is created ---
    m_logger->info("IsoStreamHandler: Initializing XPC Bridge...");
    Isoch::ITransmitPacketProvider* provider = getTransmitPacketProvider(); // Call the corrected getter
    if (provider) {
        XPCBridgeInitialize(static_cast<void*>(provider)); // Pass the provider pointer
        m_logger->info("IsoStreamHandler: XPC Bridge initialized with Packet Provider.");
    } else {
        m_logger->error("IsoStreamHandler: Failed to get Packet Provider from output stream! XPC will not work.");
        XPCBridgeInitialize(nullptr);
    }
    // ---------------------------------------------------------

#else // TRANSMIT == 0
    m_logger->info("IsoStreamHandler: Transmitter disabled by build configuration.");
    XPCBridgeInitialize(nullptr);
#endif // TRANSMIT


    // --- Start Background Threads ---
#if RECEIVE
    // Start the consumer thread AFTER input stream is started and buffer is available
    if (getInputStreamRingBuffer()) {
        m_consumerRunning = true;
        m_consumerThread = std::thread(&IsoStreamHandler::consumerLoop, this);
        makeThreadRealtime(m_consumerThread); // Make consumer high priority
        m_logger->info("IsoStreamHandler: Ring buffer consumer thread started.");
    } else {
        m_logger->error("IsoStreamHandler: Cannot start consumer thread, input stream ring buffer is null.");
        // Stop streams if we can't start the consumer
        if (m_inputStream) m_inputStream->stop(); m_inputStream.reset();
#if TRANSMIT
        if (m_outputStream) m_outputStream->stop(); m_outputStream.reset();
#endif
        return std::unexpected(IOKitError::NotReady);
    }
#endif // RECEIVE

    // Start the data processing thread (potentially common logic or adjusted based on defines)
    m_processingRunning = true;
    m_processingThread = std::thread(&IsoStreamHandler::processData, this);
    makeThreadRealtime(m_processingThread);
    m_logger->info("IsoStreamHandler: Data processing thread started");

    m_logger->info("IsoStreamHandler: Start sequence completed.");
    return {};
}

void IsoStreamHandler::stop() {
    std::lock_guard<std::mutex> lock(m_streamMutex);
    m_logger->info("IsoStreamHandler: Stopping streams...");

#if RECEIVE
    // Stop the consumer thread FIRST if receiver was enabled
    if (m_consumerRunning) {
        m_consumerRunning = false; // Signal the loop to stop
        if (m_consumerThread.joinable()) {
            m_consumerThread.join(); // Wait for it to finish
            m_logger->info("IsoStreamHandler: Ring buffer consumer thread stopped.");
        }
    }
#endif // RECEIVE

    // Stop the data processing thread
    if (m_processingRunning) {
        m_processingRunning = false;
        if (m_processingThread.joinable()) {
            m_processingThread.join();
            m_logger->info("IsoStreamHandler: Data processing thread stopped");
        }
    }

#if RECEIVE
    // Stop input stream if active
    if (m_inputStream) {
        auto result = m_inputStream->stop();
        if (!result) {
            m_logger->error("IsoStreamHandler: Error stopping input stream: {}",
                           iokit_error_category().message(static_cast<int>(result.error())));
        } else {
            m_logger->info("IsoStreamHandler: Input stream stopped");
        }
        m_inputStream.reset();
    }
#endif // RECEIVE

#if TRANSMIT
    // Stop output stream if active
    if (m_outputStream) {
        auto result = m_outputStream->stop();
        if (!result) {
            m_logger->error("IsoStreamHandler: Error stopping output stream: {}",
                           iokit_error_category().message(static_cast<int>(result.error())));
        } else {
            m_logger->info("IsoStreamHandler: Output stream stopped");
        }
        m_outputStream.reset();
    }
#endif // TRANSMIT

    // Release direct receiver reference if it was ever assigned
    m_directReceiver.reset();
    m_logger->info("IsoStreamHandler: All active streams stopped.");
}

// --- UPDATED getTransmitPacketProvider ---
Isoch::ITransmitPacketProvider* IsoStreamHandler::getTransmitPacketProvider() {
    if (m_outputStream) {
       // Delegate to AudioDeviceStream's getter
       return m_outputStream->getTransmitPacketProvider();
    }
    m_logger->warn("getTransmitPacketProvider: Output stream not available.");
    return nullptr;
}
// --- END getTransmitPacketProvider ---


// Static callback functions that forward to instance methods
void IsoStreamHandler::handleDataPush(const uint8_t* pPayload, size_t payloadLength, void* refCon) {
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("IsoStreamHandler", "handleDataPush", refCon);

    // Get the IsoStreamHandler instance from the refcon
    auto handler = static_cast<IsoStreamHandler*>(refCon);
    if (handler) {
        handler->handleDataPushImpl(pPayload, payloadLength);
    }
}

void IsoStreamHandler::handleMessage(uint32_t msg, uint32_t param1, uint32_t param2, void* refCon) {
    // Get the IsoStreamHandler instance from the refcon
    auto handler = static_cast<IsoStreamHandler*>(refCon);
    if (handler) {
        handler->handleMessageImpl(msg, param1, param2);
    }
}

void IsoStreamHandler::handleNoData(uint32_t lastCycle, void* refCon) {
    // Get the IsoStreamHandler instance from the refcon
    auto handler = static_cast<IsoStreamHandler*>(refCon);
    if (handler) {
        handler->handleNoDataImpl(lastCycle);
    }
}

void IsoStreamHandler::handleStructuredData(const Isoch::ReceivedCycleData& data, void* refCon) {
    // Get the IsoStreamHandler instance from the refcon
    auto handler = static_cast<IsoStreamHandler*>(refCon);
    if (handler) {
        handler->handleStructuredDataImpl(data);
    }
}

// Instance methods that handle the actual work
void IsoStreamHandler::handleDataPushImpl(const uint8_t* pPayload, size_t payloadLength) {
    // This callback is now mostly informational for legacy purposes.
    // The actual data processing happens in the consumerLoop reading the ring buffer.

    // Track packet rate (can keep this)
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - m_lastTimestamp).count();
    m_packetCounter++;
    if (elapsed >= 5) { // Log less frequently
        m_logger->debug("IsoStreamHandler: Received ~{} packets/sec (legacy callback trigger)", m_packetCounter/elapsed);
        m_packetCounter = 0;
        m_lastTimestamp = now;
    }

    // NOTE: Do NOT process pPayload here. It might be null or invalid
    // if the underlying callback (handleProcessedDataStatic in AudioDeviceStream)
    // is just signalling data arrival. Data should be read from the ring buffer.
}

void IsoStreamHandler::handleMessageImpl(uint32_t msg, uint32_t param1, uint32_t param2) {
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("IsoStreamHandler", "handleMessageImpl", this);

    // Check if message is from Receiver or Transmitter range
    if (msg >= static_cast<uint32_t>(Isoch::ReceiverMessage::BufferError) && msg <= static_cast<uint32_t>(Isoch::ReceiverMessage::DBCDiscontinuity)) {
        auto rxMsg = static_cast<Isoch::ReceiverMessage>(msg);
//        m_logger->info("IsoStreamHandler: Received RX message {:#x}, p1={}, p2={}", msg, param1, param2);
        switch (rxMsg) {
            case Isoch::ReceiverMessage::BufferError: m_logger->error("IsoStreamHandler: AMDTP RX Buffer error occurred"); break;
            case Isoch::ReceiverMessage::PacketError: m_logger->error("IsoStreamHandler: AMDTP RX Packet error occurred"); break;
            case Isoch::ReceiverMessage::OverrunError: m_logger->error("IsoStreamHandler: AMDTP RX Overrun error occurred"); break;
            case Isoch::ReceiverMessage::GroupError: m_logger->error("IsoStreamHandler: AMDTP RX Group error occurred"); break;
            case Isoch::ReceiverMessage::NoDataTimeout: m_logger->error("IsoStreamHandler: AMDTP RX No data timeout, last cycle: {}", param1); handleNoDataImpl(param1); break;
            case Isoch::ReceiverMessage::DBCDiscontinuity: m_logger->warn("IsoStreamHandler: AMDTP RX DBC Discontinuity detected"); break;
        }
    } else if (msg >= static_cast<uint32_t>(Isoch::TransmitterMessage::StreamStarted) && msg <= static_cast<uint32_t>(Isoch::TransmitterMessage::Error)) {
        auto txMsg = static_cast<Isoch::TransmitterMessage>(msg);
         // REMOVED magic_enum::enum_name
//        m_logger->info("IsoStreamHandler: Received TX message {:#x}, p1={}, p2={}", msg, param1, param2);
        switch (txMsg) {
            case Isoch::TransmitterMessage::StreamStarted: m_logger->info("IsoStreamHandler: AMDTP TX Stream Started"); break;
            case Isoch::TransmitterMessage::StreamStopped: m_logger->info("IsoStreamHandler: AMDTP TX Stream Stopped"); break;
//            case Isoch::TransmitterMessage::BufferUnderrun: m_logger->warn("IsoStreamHandler: AMDTP TX Buffer Underrun (Seg={}, Pkt={})", param1, param2); break;
            case Isoch::TransmitterMessage::OverrunError: m_logger->error("IsoStreamHandler: AMDTP TX DCL Overrun error occurred"); break;
            // Add cases for other transmitter messages as needed
            case Isoch::TransmitterMessage::Error: m_logger->error("IsoStreamHandler: AMDTP TX Generic Error occurred"); break;
            default: break; // Already logged as unknown TX message
        }
    } else {
        m_logger->warn("IsoStreamHandler: Unknown message type: {:#x}", msg);
    }
}

void IsoStreamHandler::handleNoDataImpl(uint32_t lastCycle) {
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("IsoStreamHandler", "handleNoDataImpl", this);

    m_logger->warn("IsoStreamHandler: No data received since cycle {}", lastCycle);
    m_packetCounterNoData++;

    // Handle no-data condition (could restart the stream, notify UI, etc.)
    // ...
}

void IsoStreamHandler::handleStructuredDataImpl(const Isoch::ReceivedCycleData& data) {
    // Log callback using RunLoopHelper
//    logCallbackThreadInfo("IsoStreamHandler", "handleStructuredDataImpl", this);

    if (!data.payload || data.payloadLength == 0) {
        return;
    }

    m_logger->debug("IsoStreamHandler: Structured data received: {} bytes at cycle {}",
                   data.payloadLength, data.fireWireTimeStamp);

    // Process structured data (e.g., extract audio samples, MIDI data, etc.)
    // ...
}

void IsoStreamHandler::processData() {
    m_logger->info("IsoStreamHandler: Data processing thread started");

    // Set thread name for debugging
    pthread_setname_np("FWA_DataProcessor");

    // Log the processing thread info
//    logCallbackThreadInfo("IsoStreamHandler", "processData", this);

    while (m_processingRunning) {
        // This thread will handle any asynchronous data processing
        // that shouldn't happen in the FireWire callback threads

        // Process any queued data
        // ...

        // Example: Check if XPC client exists and send data (if applicable)
#ifdef __OBJC__
        // if (m_xpcClient) {
        //    // Logic to get data (e.g., from a queue filled by consumerLoop)
        //    // and send via [m_xpcClient sendAudioData:...];
        // }
#endif

        // Sleep to avoid consuming CPU when idle
//        m_logger->debug("IsoStreamHandler: Data processing thread running");
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    m_logger->info("IsoStreamHandler: Data processing thread exiting");
}

void IsoStreamHandler::makeThreadRealtime(std::thread& th) {
    // Set thread priority using machport
    thread_time_constraint_policy_data_t policy;
    mach_port_t thread = pthread_mach_thread_np(th.native_handle());

    // Configure time constraints for audio processing
    // These values may need tuning based on your specific audio requirements
    policy.period = 2000000;      // 2ms period
    policy.computation = 600000;   // 0.6ms of computation time
    policy.constraint = 1200000;   // 1.2ms deadline
    policy.preemptible = 1;        // Allow preemption

    // Apply the policy
    kern_return_t result = thread_policy_set(
        thread,
        THREAD_TIME_CONSTRAINT_POLICY,
        (thread_policy_t)&policy,
        THREAD_TIME_CONSTRAINT_POLICY_COUNT
    );

    if (result == KERN_SUCCESS) {
        m_logger->info("IsoStreamHandler: Successfully set thread to real-time priority");
    } else {
        m_logger->warn("IsoStreamHandler: Failed to set thread to real-time priority, error: {}", result);

        // Fall back to POSIX thread scheduling
        struct sched_param param;
        param.sched_priority = sched_get_priority_max(SCHED_RR);

        if (pthread_setschedparam(th.native_handle(), SCHED_RR, &param) == 0) {
            m_logger->info("IsoStreamHandler: Successfully set thread to SCHED_RR priority");
        } else {
            m_logger->warn("IsoStreamHandler: Failed to set thread priority: {}", strerror(errno));
        }
    }
}

// Helper method to get ring buffer from AudioDeviceStream
raul::RingBuffer* IsoStreamHandler::getInputStreamRingBuffer() {
    if (m_inputStream) {
        return m_inputStream->getReceiverRingBuffer();
    }
    return nullptr;
}

void IsoStreamHandler::consumerLoop() {
#if RECORD
    m_logger->info("IsoStreamHandler: Consumer loop running - RECORDING TO PCM FILE...");
    pthread_setname_np("FWA_RingConsumerRec"); // Set thread name
#else
    m_logger->info("IsoStreamHandler: Consumer loop running - DISCARDING DATA...");
    pthread_setname_np("FWA_RingConsumerDiscard"); // Set thread name
#endif

    raul::RingBuffer* ringBuffer = getInputStreamRingBuffer();
    if (!ringBuffer) {
        m_logger->error("Consumer loop: Ring buffer is null. Exiting.");
        return;
    }

#if RECORD
    // --- File Output Setup ---
    std::string filename = "firewire_audio_capture_" + std::to_string(std::time(nullptr)) + ".pcm";
    std::ofstream outputFile(filename, std::ios::binary);
    if (!outputFile.is_open()) {
        m_logger->error("Consumer loop: Failed to open output file '{}'. Exiting.", filename);
        return;
    }
    m_logger->info("Consumer loop: Recording audio to '{}'", filename);
    // --- End File Output Setup ---

    // Temporary buffer for interleaved float samples before writing to file
    std::vector<float> fileWriteBuffer;
    // Reserve based on chunk size to minimize reallocations
    const size_t READ_CHUNK_FRAMES = 256; // How many ProcessedAudioFrames to read at once
    fileWriteBuffer.reserve(READ_CHUNK_FRAMES * 2); // Reserve space for L/R samples
#else
    // Define READ_CHUNK_FRAMES even if not recording, for the read buffer size
    const size_t READ_CHUNK_FRAMES = 256;
#endif

    // Buffer for reading from ring buffer
    Isoch::ProcessedAudioFrame frameBuffer[READ_CHUNK_FRAMES];
    const size_t frameSize = sizeof(Isoch::ProcessedAudioFrame);
    const size_t framesToRead = READ_CHUNK_FRAMES; // Read this many frames

    uint64_t totalFramesProcessed = 0; // Changed name for clarity
    auto lastLogTime = std::chrono::steady_clock::now();

    while (m_consumerRunning) {
        // Try to read a chunk of frames
        size_t bytesToRead = framesToRead * frameSize;
        size_t bytesRead = ringBuffer->read(bytesToRead, frameBuffer);

        if (bytesRead > 0) {
            if (bytesRead % frameSize != 0) {
                m_logger->error("Consumer loop: Read partial frame data ({} bytes)! Buffer corruption?", bytesRead);
                continue; // Skip corrupted chunk
            }

            size_t framesReadInChunk = bytesRead / frameSize;
            totalFramesProcessed += framesReadInChunk;

#if RECORD
            fileWriteBuffer.clear(); // Clear buffer for this chunk

            // --- Prepare data for file ---
            for (size_t i = 0; i < framesReadInChunk; ++i) {
                fileWriteBuffer.push_back(frameBuffer[i].sampleL);
                fileWriteBuffer.push_back(frameBuffer[i].sampleR);
            }

            // --- Write interleaved data to file ---
            if (!fileWriteBuffer.empty()) {
                outputFile.write(reinterpret_cast<const char*>(fileWriteBuffer.data()),
                                 fileWriteBuffer.size() * sizeof(float));
                if (!outputFile) {
                     m_logger->error("Consumer loop: Error writing to output file '{}'. Stopping recording.", filename);
                     m_consumerRunning = false; // Stop the loop on file error
                     break;
                }
            }
            // --- End Write ---
#endif // RECORD

            // Optional: Log rate periodically (Common to both modes)
            auto now = std::chrono::steady_clock::now();
            if (now - lastLogTime > std::chrono::seconds(5)) {
#if RECORD
                 m_logger->debug("Consumer loop: Wrote {} frames in last 5s. Total written: {}. Available read: {}",
                                framesReadInChunk, totalFramesProcessed, ringBuffer->read_space());
#else
                 m_logger->debug("Consumer loop: Discarded {} frames in last 5s. Total discarded: {}. Available read: {}",
                                framesReadInChunk, totalFramesProcessed, ringBuffer->read_space());
#endif
                 lastLogTime = now;
                 // Log timestamp of last frame in chunk
                 if (framesReadInChunk > 0) {
                    uint64_t lastTs = frameBuffer[framesReadInChunk - 1].presentationNanos;
                    m_logger->debug("Consumer loop: Last processed frame timestamp: {}", lastTs);
                 }
            }

        } else {
            // Buffer is empty, wait a bit
            std::this_thread::sleep_for(std::chrono::microseconds(500));
        }
    }

#if RECORD
    // --- Cleanup File ---
    if (outputFile.is_open()) {
        outputFile.close();
        m_logger->info("Consumer loop: Closed output file '{}'. Total frames written: {}", filename, totalFramesProcessed);
    } else if (m_consumerRunning == false) { // Only log if loop exited due to error, not normal stop
         m_logger->info("Consumer loop: Finished (file writing stopped due to error). Total frames written before error: {}", totalFramesProcessed);
    }
    // --- End Cleanup ---
#endif // RECORD

    m_logger->info("IsoStreamHandler: Consumer loop finished.");
}

} // namespace FWA



=== src/Isoch/SharedManagers.cpp ===
#include "Isoch/SharedManagers.hpp"
//#include "Isoch/components/AmdtpPortManager.hpp"
//#include "Isoch/components/AmdtpDCLManager.hpp"
//#include "Isoch/components/AmdtpTransportManager.hpp"

namespace FWA {
namespace Isoch {
// Note: AmdtpDCLManager implementation moved to core/AmdtpDCLManager.cpp
} // namespace Isoch
} // namespace FWA



=== include/Isoch/SharedManagers.hpp ===
// SharedManagers.hpp
#pragma once

#include <memory>
#include <expected>
#include "FWA/Error.h"
#include <spdlog/logger.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <functional>
//#include "Isoch/core/AmdtpDCLManager.hpp"

namespace FWA {
namespace Isoch {

// Forward declarations
class AmdtpPortManager;
class AmdtpTransportManager;

class AmdtpPortManager {
public:
    explicit AmdtpPortManager(std::shared_ptr<spdlog::logger> logger) : logger_(std::move(logger)) {}
    virtual ~AmdtpPortManager() = default;

    virtual std::expected<void, IOKitError> initialize(
        IOFireWireLibNubRef nubInterface,
        bool isTalker,
        DCLCommandPtr program,
        IOVirtualRange* bufferRange = nullptr,
        uint32_t numRanges = 0) = 0;

    virtual std::expected<void, IOKitError> configure(
        IOFWSpeed speed,
        uint32_t channel) = 0;

    virtual void resetPorts() = 0;

    // Get active channel configuration
    virtual std::expected<uint32_t, IOKitError> getActiveChannel() const = 0;

    // Get isoch channel interface - needed by transport manager
    virtual IOFireWireLibIsochChannelRef getIsochChannel() const = 0;

protected:
    virtual std::expected<void, IOKitError> createRemotePort() = 0;
    virtual std::expected<void, IOKitError> createLocalPort(DCLCommandPtr program) = 0;
    virtual std::expected<void, IOKitError> createIsochChannel() = 0;
    std::shared_ptr<spdlog::logger> logger_;
};

class AmdtpTransportManager {
public:
    enum class State {
        Stopped,
        Starting,
        Running,
        Stopping
    };

    using FinalizeCallback = std::function<void()>;

    explicit AmdtpTransportManager(std::shared_ptr<spdlog::logger> logger) 
        : logger_(std::move(logger)) {}
    virtual ~AmdtpTransportManager() = default;

    virtual std::expected<void, IOKitError> start(IOFireWireLibIsochChannelRef channel) = 0;
    virtual std::expected<void, IOKitError> stop(IOFireWireLibIsochChannelRef channel) = 0;
    virtual State getState() const noexcept = 0;
    virtual void handleFinalize() = 0;

protected:
    virtual std::expected<void, IOKitError> prepareStart() = 0;
    virtual std::expected<void, IOKitError> finishStop() = 0;
    std::shared_ptr<spdlog::logger> logger_;
};

} // namespace Isoch
} // namespace FWA



=== include/Isoch/core/IsochPacketProvider.hpp ===
#pragma once

#include "Isoch/interfaces/ITransmitPacketProvider.hpp"
#include "Isoch/utils/RingBuffer.hpp" // Include RingBuffer - WE OWN IT NOW
#include <atomic>
#include <chrono>
#include <spdlog/spdlog.h> // Use main spdlog header

namespace FWA {
namespace Isoch {

class IsochPacketProvider : public ITransmitPacketProvider {
public:
    // --- UPDATED Constructor: Takes buffer size ---
    explicit IsochPacketProvider(std::shared_ptr<spdlog::logger> logger,
                                 size_t ringBufferSize = 131072); // Default size
    ~IsochPacketProvider() override;

    // Prevent Copy
    IsochPacketProvider(const IsochPacketProvider&) = delete;
    IsochPacketProvider& operator=(const IsochPacketProvider&) = delete;

    // --- ADDED: Method for XPC Bridge to call ---
    bool pushAudioData(const void* buffer, size_t bufferSizeInBytes) override;
    // ------------------------------------------

    PreparedPacketData fillPacketData(
        uint8_t* targetBuffer,
        size_t targetBufferSize,
        const TransmitPacketInfo& info
    ) override;

    bool isReadyForStreaming() const override;
    void reset() override;

    // --- ADDED: Helper for XPC Bridge to get stats if needed ---
    [[nodiscard]] uint32_t getAvailableReadBytes() const {
        return audioBuffer_.read_space();
    }
    [[nodiscard]] uint32_t getAvailableWriteBytes() const {
        return audioBuffer_.write_space();
    }
    // -----------------------------------------------------------

private:
    void handleUnderrun(const TransmitPacketInfo& info);

    std::shared_ptr<spdlog::logger> logger_;
    // --- ADDED back: Own the RingBuffer ---
    raul::RingBuffer audioBuffer_;
    // -------------------------------------

    std::atomic<bool> isInitialized_{false};
    std::atomic<size_t> underrunCount_{0};

    // Configuration/Constants
    static constexpr size_t INITIAL_FILL_TARGET_PERCENT = 50;
    // Constants for AM824 conversion (Ensure these are defined/included correctly)
    static constexpr uint32_t AM824_LABEL = 0x40;
    static constexpr uint32_t LABEL_SHIFT = 24;

    // Stats counters (now internal to this class)
    std::chrono::steady_clock::time_point lastStatsTime_;
    std::atomic<uint64_t> totalPushedBytes_{0};
    std::atomic<uint64_t> totalPulledBytes_{0};
    std::atomic<size_t> overflowWriteAttempts_{0}; // For pushAudioData failures

};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/AudioProcessingThread.hpp ===
#pragma once

#include "Isoch/core/IsochDoubleBufferManager.hpp"

#include <atomic>
#include <condition_variable>
#include <functional>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>

namespace spdlog {
    class logger;
}

namespace FWA {
namespace Isoch {

// Define a distinct packet callback type to avoid collision with the one in ReceiverTypes.hpp
using ExtendedPacketCallback = void (*)(uint32_t segmentIndex, const uint8_t* data, size_t size, uint32_t timestamp, void* refCon);

/**
 * @class AudioProcessingThread
 * @brief Handles audio processing in a separate thread from FireWire callbacks.
 * 
 * This class runs a separate thread that processes audio data from the double buffer,
 * preventing deadlocks in the audio processing chain by decoupling it from the
 * FireWire interrupt context.
 */
class AudioProcessingThread {
public:
    /**
     * @brief Constructor
     * @param bufferManager Shared double buffer manager instance
     * @param logger Logger instance for debugging
     */
    AudioProcessingThread(std::shared_ptr<IsochDoubleBufferManager> bufferManager,
                         std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Destructor
     */
    ~AudioProcessingThread();
    
    /**
     * @brief Start the processing thread
     * @return True if thread started successfully, false otherwise
     */
    bool start();
    
    /**
     * @brief Stop the processing thread
     */
    void stop();
    
    /**
     * @brief Set the audio callback function
     * @param callback Function pointer to call with processed audio data
     * @param refCon User-provided reference constant passed to callback
     */
    void setAudioCallback(ExtendedPacketCallback callback, void* refCon);
    
    /**
     * @brief Check if processing thread is active
     * @return True if thread is running, false otherwise
     */
    bool isRunning() const { return running_.load(); }
    
    /**
     * @brief Signal that new data is available for processing
     * 
     * This method should be called from the IsochManager after completing a segment
     * to notify the processing thread that there's new data to process.
     */
    void notifyNewData();
    
    /**
     * @brief Set the timestamp for a segment
     * @param segment Segment index
     * @param timestamp FireWire timestamp value
     */
    void setSegmentTimestamp(uint32_t segment, uint32_t timestamp);
    
private:
    // Main processing thread function
    void processingLoop();
    
    // Process a single segment of audio data
    void processSegment(uint32_t segment);
    
    std::shared_ptr<IsochDoubleBufferManager> bufferManager_;
    std::shared_ptr<spdlog::logger> logger_;
    std::thread processingThread_;
    std::atomic<bool> running_{false};
    std::atomic<bool> shouldExit_{false};
    
    // Condition variable for signaling new data
    std::mutex condMutex_;
    std::condition_variable dataCond_;
    bool dataAvailable_{false};
    
    // Client callback
    ExtendedPacketCallback audioCallback_{nullptr};
    void* audioCallbackRefCon_{nullptr};
    
    // Timestamps for each segment
    std::vector<uint32_t> timestamps_;
    std::mutex timestampMutex_;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochDoubleBufferManager.hpp ===
#pragma once

#include <atomic>
#include <cstdint>
#include <memory>

namespace spdlog {
    class logger;
}

namespace FWA {
namespace Isoch {

/**
 * @class IsochDoubleBufferManager
 * @brief Manages double-buffering for isochronous data to separate reception from processing.
 * 
 * This class implements a double-buffering mechanism to prevent deadlocks in audio processing.
 * One buffer is used for writing incoming data from FireWire DCL callbacks, while the other
 * is used for reading/processing by the audio processing thread.
 */
class IsochDoubleBufferManager {
public:
    /**
     * @struct BufferSegment
     * @brief Represents a segment of audio data within a buffer.
     */
    struct BufferSegment {
        uint8_t* data;
        size_t size;
    };

    /**
     * @brief Constructor
     * @param logger Logger instance for debugging
     * @param numSegments Number of segments per buffer
     * @param cyclesPerSegment Number of FireWire cycles per segment
     * @param cycleBufferSize Size of each cycle buffer in bytes
     */
    IsochDoubleBufferManager(std::shared_ptr<spdlog::logger> logger,
                             uint32_t numSegments,
                             uint32_t cyclesPerSegment,
                             uint32_t cycleBufferSize);

    /**
     * @brief Destructor
     */
    ~IsochDoubleBufferManager();

    /**
     * @brief Initialize the buffer manager with actual memory
     * @param baseBuffer Pointer to pre-allocated memory for all buffers
     * @param totalSize Total size of the provided memory in bytes
     * @return True if initialization succeeded, false otherwise
     */
    bool initialize(uint8_t* baseBuffer, size_t totalSize);
    
    /**
     * @brief Get pointer to current write segment for specified segment index
     * @param segment Segment index
     * @return Pointer to segment data or nullptr if invalid
     */
    uint8_t* getWriteSegmentPtr(uint32_t segment);
    
    /**
     * @brief Get pointer to current read segment for specified segment index
     * @param segment Segment index
     * @return Pointer to segment data or nullptr if invalid
     */
    uint8_t* getReadSegmentPtr(uint32_t segment);
    
    /**
     * @brief Mark a segment in the write buffer as complete
     * @param segment Segment index
     */
    void markSegmentComplete(uint32_t segment);
    
    /**
     * @brief Mark a segment in the read buffer as processed
     * @param segment Segment index
     */
    void markSegmentProcessed(uint32_t segment);
    
    /**
     * @brief Check if a segment in the write buffer is complete
     * @param segment Segment index
     * @return True if the segment is complete
     */
    bool isSegmentComplete(uint32_t segment) const;
    
    /**
     * @brief Check if a segment in the read buffer is processed
     * @param segment Segment index
     * @return True if the segment is processed
     */
    bool isSegmentProcessed(uint32_t segment) const;
    
    /**
     * @brief Check if current write buffer is completely filled
     * @return True if all segments in the write buffer are complete
     */
    bool isWriteBufferFull() const;
    
    /**
     * @brief Check if current read buffer has all data processed
     * @return True if all segments in the read buffer are processed
     */
    bool isReadBufferEmpty() const;
    
    /**
     * @brief Try to swap the write buffer to become the read buffer
     * @return True if swap succeeded, false otherwise
     */
    bool trySwapBuffers();
    
    /**
     * @brief Get number of segments per buffer
     * @return Number of segments
     */
    uint32_t getNumSegments() const { return numSegments_; }
    
    /**
     * @brief Get segment size in bytes (total size per segment)
     * @return Segment size in bytes
     */
    size_t getSegmentSize() const { return segmentSize_; }
    
    /**
     * @brief Get active write buffer index
     * @return 0 for buffer A, 1 for buffer B
     */
    uint32_t getActiveWriteBufferIndex() const { return writeBufferIndex_.load(); }
    
    /**
     * @brief Get active read buffer index
     * @return 0 for buffer A, 1 for buffer B
     */
    uint32_t getActiveReadBufferIndex() const { return readBufferIndex_.load(); }

private:
    std::shared_ptr<spdlog::logger> logger_;
    
    // Buffer configuration
    uint32_t numSegments_;
    uint32_t cyclesPerSegment_;
    uint32_t cycleBufferSize_;
    size_t segmentSize_;  // Total bytes per segment = cyclesPerSegment * cycleBufferSize
    
    // Direct allocation of arrays for better control
    std::atomic<bool>* segmentCompleteA_;    // Completion flags for buffer A
    std::atomic<bool>* segmentProcessedA_;   // Processing flags for buffer A
    BufferSegment* segmentsA_;               // Segment data for buffer A
    
    std::atomic<bool>* segmentCompleteB_;    // Completion flags for buffer B
    std::atomic<bool>* segmentProcessedB_;   // Processing flags for buffer B
    BufferSegment* segmentsB_;               // Segment data for buffer B
    
    // Memory management
    uint8_t* mainBuffer_;     // All allocated memory (owned)
    size_t totalBufferSize_;  // Total buffer size in bytes
    
    // Current buffer state
    std::atomic<uint32_t> writeBufferIndex_{0};  // 0 = bufferA, 1 = bufferB
    std::atomic<uint32_t> readBufferIndex_{1};   // 1 = bufferB, 0 = bufferA
    
    // Buffer state tracking
    std::atomic<bool> bufferAReady_{false};
    std::atomic<bool> bufferBReady_{false};
    
    // Helpers for accessing the correct buffer based on current indices
    std::atomic<bool>* getWriteCompleteFlags() { return writeBufferIndex_.load() == 0 ? segmentCompleteA_ : segmentCompleteB_; }
    std::atomic<bool>* getReadCompleteFlags() { return readBufferIndex_.load() == 0 ? segmentCompleteA_ : segmentCompleteB_; }
    std::atomic<bool>* getWriteProcessedFlags() { return writeBufferIndex_.load() == 0 ? segmentProcessedA_ : segmentProcessedB_; }
    std::atomic<bool>* getReadProcessedFlags() { return readBufferIndex_.load() == 0 ? segmentProcessedA_ : segmentProcessedB_; }
    BufferSegment* getWriteSegments() { return writeBufferIndex_.load() == 0 ? segmentsA_ : segmentsB_; }
    BufferSegment* getReadSegments() { return readBufferIndex_.load() == 0 ? segmentsA_ : segmentsB_; }
    
    // Const versions of the accessors
    const std::atomic<bool>* getWriteCompleteFlags() const { return writeBufferIndex_.load() == 0 ? segmentCompleteA_ : segmentCompleteB_; }
    const std::atomic<bool>* getReadCompleteFlags() const { return readBufferIndex_.load() == 0 ? segmentCompleteA_ : segmentCompleteB_; }
    const std::atomic<bool>* getWriteProcessedFlags() const { return writeBufferIndex_.load() == 0 ? segmentProcessedA_ : segmentProcessedB_; }
    const std::atomic<bool>* getReadProcessedFlags() const { return readBufferIndex_.load() == 0 ? segmentProcessedA_ : segmentProcessedB_; }
    const BufferSegment* getWriteSegments() const { return writeBufferIndex_.load() == 0 ? segmentsA_ : segmentsB_; }
    const BufferSegment* getReadSegments() const { return readBufferIndex_.load() == 0 ? segmentsA_ : segmentsB_; }
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochBufferManager.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <cstdint>
#include <spdlog/logger.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include "FWA/Error.h"

namespace FWA {
namespace Isoch {

/**
 * @brief Manages buffer allocation and access for isochronous communication
 * 
 * This class handles allocation and management of memory buffers for 
 * isochronous transport, including packet data, headers, and timestamps.
 * It ensures proper structure and alignment for FireWire DMA operations.
 */
class IsochBufferManager {
public:
    /**
     * @brief Configuration for the buffer structure
     */
    struct Config {
        uint32_t numGroups{8};         // Total number of buffer groups
        uint32_t packetsPerGroup{16};  // Number of FW packets per group
        uint32_t packetDataSize{64};   // Bytes of audio data per FW packet
    };

    /**
     * @brief Construct a new IsochBufferManager
     * 
     * @param logger Logger for diagnostic information
     */
    explicit IsochBufferManager(std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Destructor - ensures proper cleanup of allocated memory
     */
    ~IsochBufferManager();
    
    // Prevent copying
    IsochBufferManager(const IsochBufferManager&) = delete;
    IsochBufferManager& operator=(const IsochBufferManager&) = delete;
    
    /**
     * @brief Setup buffers for isoch communication
     * 
     * @param config Buffer configuration
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> setupBuffers(const Config& config);
    
    /**
     * @brief Get pointer to timestamp for a specific packet
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @return std::expected<uint32_t*, IOKitError> Pointer to timestamp or error
     */
    std::expected<uint32_t*, IOKitError> getPacketTimestampPtr(
        uint32_t groupIndex, uint32_t packetIndexInGroup) const;
    
    /**
     * @brief Get pointer to isoch header for a specific packet
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @return std::expected<uint8_t*, IOKitError> Pointer to isoch header or error
     */
    std::expected<uint8_t*, IOKitError> getPacketIsochHeaderPtr(
        uint32_t groupIndex, uint32_t packetIndexInGroup) const;
    
    /**
     * @brief Get pointer to CIP header for a specific packet
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @return std::expected<uint8_t*, IOKitError> Pointer to CIP header or error
     */
    std::expected<uint8_t*, IOKitError> getPacketCIPHeaderPtr(
        uint32_t groupIndex, uint32_t packetIndexInGroup) const;
    
    /**
     * @brief Get pointer to packet data for a specific packet
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @return std::expected<uint8_t*, IOKitError> Pointer to packet data or error
     */
    std::expected<uint8_t*, IOKitError> getPacketDataPtr(
        uint32_t groupIndex, uint32_t packetIndexInGroup) const;
    
    /**
     * @brief TEMPORARY GETTER for the start of the raw packet slot
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @return std::expected<uint8_t*, IOKitError> Pointer to raw packet slot or error
     */
    std::expected<uint8_t*, IOKitError> getRawPacketSlotPtr(
        uint32_t groupIndex, uint32_t packetIndexInGroup) const;
    
    /**
     * @brief Get total size expected per packet (IsochHdr + CIPP Hdr + Data)
     * 
     * @return size_t Total size per packet in bytes
     */
    size_t getTotalPacketSize() const {
        return kIsochHeaderSize + kCIPHeaderSize + config_.packetDataSize;
    }
    
    /**
     * @brief Get buffer range for DMA operations
     * 
     * @return const IOVirtualRange& Buffer range
     */
    const IOVirtualRange& getBufferRange() const { return bufferRange_; }
    
    /**
     * @brief Get total size of allocated buffer
     * 
     * @return size_t Total buffer size in bytes
     */
    size_t getTotalBufferSize() const { return totalBufferSize_; }
    
    /**
     * @brief Get number of groups
     * 
     * @return uint32_t Number of buffer groups
     */
    uint32_t getNumGroups() const { return config_.numGroups; }
    
    /**
     * @brief Get packets per group
     * 
     * @return uint32_t Packets per group
     */
    uint32_t getPacketsPerGroup() const { return config_.packetsPerGroup; }
    
    /**
     * @brief Get packet data size
     * 
     * @return uint32_t Size of data part of each packet in bytes
     */
    uint32_t getPacketDataSize() const { return config_.packetDataSize; }
    
    /**
     * @brief Constants for header sizes
     */
    static constexpr size_t kIsochHeaderSize = 4;   // Size of isoch header in bytes
    static constexpr size_t kCIPHeaderSize = 8;     // Size of CIP header in bytes
    
private:
    void cleanup() noexcept;
    void calculateBufferLayout();
    
    std::shared_ptr<spdlog::logger> logger_;
    Config config_;
    uint32_t totalPackets_{0};
    
    // Buffer management
    uint8_t* mainBuffer_{nullptr};
    size_t totalBufferSize_{0};
    IOVirtualRange bufferRange_{};
    
    // Pointers into mainBuffer_
    uint8_t* isochHeaderArea_{nullptr};
    uint8_t* cipHeaderArea_{nullptr};
    uint8_t* packetDataArea_{nullptr};
    uint32_t* timestampArea_{nullptr};
    
    // Buffer section sizes
    size_t isochHeaderTotalSize_{0};
    size_t cipHeaderTotalSize_{0};
    size_t packetDataTotalSize_{0};
    size_t timestampTotalSize_{0};
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochDCLManager.hpp ===
#pragma once

#include <memory>
#include <vector>
#include <functional>
#include <expected>
#include <atomic>
#include <mutex>
#include <CoreFoundation/CoreFoundation.h> // For CFMutableSetRef
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/IsochBufferManager.hpp" // Include buffer manager directly

namespace FWA {
namespace Isoch {

/**
 * @brief Callback function for DCL completion events
 * @param groupIndex The group index that completed.
 * @param refCon User-provided context pointer.
 */
using DCLCompleteCallback = void(*)(uint32_t groupIndex, void* refCon);

/**
 * @brief Callback function for DCL overrun events
 * @param refCon User-provided context pointer.
 */
using DCLOverrunCallback = void(*)(void* refCon);

/**
 * @brief Manages the creation and lifecycle of a FireWire NuDCL program.
 *
 * This class focuses specifically on allocating NuDCL commands, linking them
 * into packet groups, handling buffer associations, managing jump targets,
 * and processing DCL-level callbacks (completion, overrun).
 */
class IsochDCLManager {
public:
    /**
     * @brief Configuration for the DCL Manager.
     */
    struct Config {
        uint32_t numGroups{8};             // Total number of buffer groups
        uint32_t packetsPerGroup{16};      // Number of FW packets per group
        uint32_t callbackGroupInterval{1}; // Callback after every N groups (1 = every group)
    };

    /**
     * @brief Structure to hold per-group metadata for callbacks
     */
    struct BufferGroupInfo {
        IsochDCLManager* manager{nullptr}; // Pointer back to the manager
        uint32_t groupIndex{0};            // Index of this group
        // Add any other relevant info needed by the callback handler
    };

    /**
     * @brief Construct a new IsochDCLManager instance.
     *
     * @param logger Logger for diagnostic information.
     * @param nuDCLPool The NuDCL pool provided by the Port/Channel Manager.
     * @param bufferManager Reference to the IsochBufferManager for buffer layout.
     * @param config DCL program configuration.
     */
    explicit IsochDCLManager(
        std::shared_ptr<spdlog::logger> logger,
        IOFireWireLibNuDCLPoolRef nuDCLPool, // Assumes pool is created elsewhere
        const IsochBufferManager& bufferManager, // Use const ref
        const Config& config);

    /**
     * @brief Destructor - handles cleanup of DCL resources.
     */
    ~IsochDCLManager();

    // Prevent copying
    IsochDCLManager(const IsochDCLManager&) = delete;
    IsochDCLManager& operator=(const IsochDCLManager&) = delete;

    /**
     * @brief Creates the full DCL program structure.
     * Does not fix jump targets initially.
     *
     * @return std::expected<DCLCommand*, IOKitError> The DCL program handle or an error.
     */
    std::expected<DCLCommand*, IOKitError> createDCLProgram();

    /**
     * @brief Fixes up the jump targets between the last and first DCL.
     * Notifies the local port.
     *
     * @param localPort The local port reference needed for notifications.
     * @return std::expected<void, IOKitError> Success or error code.
     */
    std::expected<void, IOKitError> fixupDCLJumpTargets(IOFireWireLibLocalIsochPortRef localPort);

    /**
     * @brief Sets the callback for DCL group completion events.
     *
     * @param callback Function to call when a group completes.
     * @param refCon Context pointer to pass to the callback.
     */
    void setDCLCompleteCallback(DCLCompleteCallback callback, void* refCon);

    /**
     * @brief Sets the callback for DCL overrun events.
     *
     * @param callback Function to call on DCL overrun.
     * @param refCon Context pointer to pass to the callback.
     */
    void setDCLOverrunCallback(DCLOverrunCallback callback, void* refCon);

    /**
     * @brief Gets the starting DCL command pointer of the created program.
     *
     * @return std::expected<DCLCommandPtr, IOKitError> DCL program start or error.
     */
    std::expected<DCLCommandPtr, IOKitError> getProgram() const;

    /**
     * @brief Resets the DCL manager state, releasing DCL resources.
     * Does not release the NuDCL pool itself (owned externally).
     */
    void reset();

private:
    // Internal helper to notify the port about jump updates
    IOReturn notifyJumpUpdate(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef* dclRefPtr);

    // Static callback handlers for FireWire DCL callbacks
    static void DCLComplete_Helper(void* refcon, NuDCLRef dcl);
    static void DCLOverrun_Helper(void* refcon, NuDCLRef dcl);

    // Instance methods called by the static helpers
    void handleDCLComplete(NuDCLRef dcl, BufferGroupInfo* groupInfo);
    void handleDCLOverrun(NuDCLRef dcl);

    // --- Member Variables ---
    std::shared_ptr<spdlog::logger> logger_;
    IOFireWireLibNuDCLPoolRef nuDCLPool_{nullptr}; // Non-owning reference
    const IsochBufferManager& bufferManager_;      // Reference to buffer info
    Config config_;
    uint32_t totalPackets_{0};

    // Store refs to the very first and very last DCLs created
    NuDCLRef firstDCLRef_{nullptr};
    NuDCLRef lastDCLRef_{nullptr};

    // Store per-group callback info
    std::vector<BufferGroupInfo> groupInfos_;

    // State
    std::atomic<uint32_t> currentSegment_{0}; // Rename this later
    bool dclProgramCreated_{false};

    // Callbacks
    DCLCompleteCallback dclCompleteCallback_{nullptr};
    void* dclCompleteRefCon_{nullptr};
    DCLOverrunCallback dclOverrunCallback_{nullptr};
    void* dclOverrunRefCon_{nullptr};

    // Synchronization
    std::mutex stateMutex_; // Protects DCL structure modification, callbacks
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochTransmitDCLManager.hpp ===
#pragma once

#include "Isoch/interfaces/ITransmitDCLManager.hpp"
#include "Isoch/interfaces/ITransmitBufferManager.hpp"
#include "Isoch/core/TransmitterTypes.hpp"
#include <vector>
#include <mutex>
#include <atomic>
#include <spdlog/spdlog.h> // Using main spdlog header instead of just logger.hpp
#include <CoreFoundation/CFSet.h> // For CFMutableSetRef

namespace FWA {
namespace Isoch {

class IsochTransmitDCLManager : public ITransmitDCLManager {
public:
    explicit IsochTransmitDCLManager(std::shared_ptr<spdlog::logger> logger);
    ~IsochTransmitDCLManager() override;

    // Prevent Copy
    IsochTransmitDCLManager(const IsochTransmitDCLManager&) = delete;
    IsochTransmitDCLManager& operator=(const IsochTransmitDCLManager&) = delete;


    std::expected<DCLCommand*, IOKitError> createDCLProgram(
        const TransmitterConfig& config,
        IOFireWireLibNuDCLPoolRef nuDCLPool,
        const ITransmitBufferManager& bufferManager) override;

    std::expected<void, IOKitError> fixupDCLJumpTargets(
        IOFireWireLibLocalIsochPortRef localPort) override;

    void setDCLCompleteCallback(TransmitDCLCompleteCallback callback, void* refCon) override;
    void setDCLOverrunCallback(TransmitDCLOverrunCallback callback, void* refCon) override;

    std::expected<void, IOKitError> updateDCLPacket(
        uint32_t groupIndex,
        uint32_t packetIndexInGroup,
        const IOVirtualRange ranges[],
        uint32_t numRanges,
        const IsochHeaderData* isochHeaderTemplate
    ) override;

     std::expected<void, IOKitError> notifySegmentUpdate(
         IOFireWireLibLocalIsochPortRef localPort,
         uint32_t groupIndexToNotify) override;

    DCLCommand* getProgramHandle() const override;
    void reset() override;

private:
    // Structure to hold info passed to static callbacks
     struct DCLCallbackInfo {
         IsochTransmitDCLManager* manager = nullptr;
         uint32_t groupIndex = 0;
     };

    // Static callbacks
    static void DCLComplete_Helper(void* refcon, NuDCLRef dcl);
    static void DCLOverrun_Helper(void* refcon, NuDCLRef dcl);

    // Instance handlers
    void handleDCLComplete(uint32_t groupIndex, NuDCLRef dcl);
    void handleDCLOverrun(NuDCLRef dcl);

    // Internal helpers
    NuDCLSendPacketRef getDCLRef(uint32_t groupIndex, uint32_t packetIndexInGroup); // Removed const qualifier
    IOReturn notifyDCLUpdates(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef dcls[], uint32_t count);
    IOReturn notifyJumpUpdate(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef* dclRefPtr);


    std::shared_ptr<spdlog::logger> logger_;
    TransmitterConfig config_; // Store config
    IOFireWireLibNuDCLPoolRef nuDCLPool_{nullptr}; // Non-owning

    // DCL Program Structure
    std::vector<NuDCLSendPacketRef> dclProgramRefs_; // Stores all DCLs
    NuDCLSendPacketRef firstDCLRef_{nullptr};
    NuDCLSendPacketRef lastDCLRef_{nullptr};
    NuDCLSendPacketRef overrunDCL_{nullptr};
    std::vector<DCLCallbackInfo> callbackInfos_; // Store refcon data for each group
     std::vector<CFMutableSetRef> updateBags_; // Update bags per segment completion DCL

    // State
    bool dclProgramCreated_{false};
    std::atomic<uint32_t> currentSegment_{0}; // Maybe needed for jump target logic

    // Callbacks
    TransmitDCLCompleteCallback dclCompleteCallback_{nullptr};
    void* dclCompleteRefCon_{nullptr};
    TransmitDCLOverrunCallback dclOverrunCallback_{nullptr};
    void* dclOverrunRefCon_{nullptr};

    std::mutex mutex_;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochMonitoringManager.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <mutex>
#include <atomic>
#include <CoreFoundation/CoreFoundation.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/ReceiverTypes.hpp"

namespace FWA {
namespace Isoch {

/**
 * @brief Manager for monitoring data flow in isochronous transport
 * 
 * This class handles monitoring for no-data conditions and timeouts
 * in isochronous transport.
 */
class IsochMonitoringManager {
public:
    /**
     * @brief Construct a new IsochMonitoringManager
     * 
     * @param logger Logger for diagnostic information
     * @param runLoop RunLoop for timer callbacks, or nullptr for current
     */
    IsochMonitoringManager(
        std::shared_ptr<spdlog::logger> logger,
        CFRunLoopRef runLoop = nullptr);
    
    /**
     * @brief Destructor - ensures proper cleanup of timers
     */
    ~IsochMonitoringManager();
    
    // Prevent copying
    IsochMonitoringManager(const IsochMonitoringManager&) = delete;
    IsochMonitoringManager& operator=(const IsochMonitoringManager&) = delete;
    
    /**
     * @brief Set callback for no-data condition
     * 
     * @param callback Function to call when no data is received
     * @param refCon Context pointer to pass to the callback
     */
    void setNoDataCallback(NoDataCallback callback, void* refCon) {
        noDataCallback_ = callback;
        noDataCallbackRefCon_ = refCon;
    }
    
    /**
     * @brief Start monitoring for no-data condition
     * 
     * @param timeoutMs Timeout in milliseconds
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> startMonitoring(uint32_t timeoutMs);
    
    /**
     * @brief Stop monitoring
     */
    void stopMonitoring();
    
    /**
     * @brief Reset timer on data reception
     */
    void resetTimer();
    
    /**
     * @brief Set CIP-only mode
     * 
     * In CIP-only mode, packets with only CIP headers (no payload)
     * are considered as "no data".
     * 
     * @param enable True to enable CIP-only mode, false otherwise
     */
    void setCIPOnlyMode(bool enable) {
        cipOnlyMode_ = enable;
    }
    
    /**
     * @brief Update the last received cycle
     * 
     * @param cycle Cycle number
     */
    void updateLastCycle(uint32_t cycle) {
        lastCycle_ = cycle;
    }
    
    /**
     * @brief Set the RunLoop for timer callbacks
     * 
     * @param runLoop The RunLoop to use
     */
    void setRunLoop(CFRunLoopRef runLoop) {
        runLoop_ = runLoop;
    }
    
private:
    /**
     * @brief Helper method to stop and release timer without locking
     * 
     * This method does the actual work of stopping the timer without
     * acquiring the mutex, to prevent potential deadlocks.
     */
    void internalStopAndReleaseTimer();

    /**
     * @brief Handle timer expiration
     */
    void handleTimeout();
    
    /**
     * @brief Static callback for CFRunLoopTimer
     */
    static void timerCallback(CFRunLoopTimerRef timer, void* info);
    
    std::shared_ptr<spdlog::logger> logger_;
    CFRunLoopRef runLoop_{nullptr};
    CFRunLoopTimerRef timer_{nullptr};
    NoDataCallback noDataCallback_{nullptr};
    void* noDataCallbackRefCon_{nullptr};
    uint32_t timeoutMs_{1000}; // Default timeout: 1 second
    std::atomic<uint32_t> lastCycle_{0};
    bool cipOnlyMode_{true};
    std::mutex timerMutex_;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/AmdtpTransmitStreamProcessor.hpp ===
#ifndef AMDTPTRANSMITSTREAMPROCESSOR_H
#define AMDTPTRANSMITSTREAMPROCESSOR_H

#include <cstdint>
#include <atomic>
#include <chrono>
#include <memory>
#include <spdlog/spdlog.h> // Use main header
#include "Isoch/utils/RingBuffer.hpp"  // RAUL RingBuffer header

// Configuration options
#define DEBUG_LOGGING 1          // Keep debug logging toggle

namespace AVS {

class AmdtpTransmitStreamProcessor {
public:
    AmdtpTransmitStreamProcessor(std::shared_ptr<spdlog::logger> logger);
    ~AmdtpTransmitStreamProcessor();

    // Push raw audio data (received via XPC) into the ring buffer.
    void pushAudioData(const void* buff, unsigned int buffBytesSize);

    void startSampleRateLogger();

    // ADDED: Method to access internal buffer state (needed for Phase 2 pump)
    [[nodiscard]] uint32_t getAvailableReadBytes() const {
        return audioBuffer_.read_space();
    }

    // ADDED: Method to read from internal buffer (needed for Phase 2 pump)
    uint32_t readData(uint32_t size, void* dst) {
         // This read is potentially called from a different thread (pump thread)
         // than pushAudioData (XPC queue). RingBuffer IS single-producer/single-consumer safe.
         uint32_t bytesRead = audioBuffer_.read(size, dst);
         if (bytesRead > 0) {
             samplesInBuffer_.fetch_sub(bytesRead / sizeof(int32_t), std::memory_order_release); // Assuming int32_t samples
         }
         return bytesRead;
    }

private:
    // Configuration constants (simplified)
    static constexpr size_t BYTES_PER_AUDIO_SAMPLE = 4; // Keep if assuming 32-bit PCM from XPC
    static constexpr size_t RING_BUFFER_SIZE = 4096; // 16 KB - Adjusted size

    // RAUL ring buffer instance.
    raul::RingBuffer audioBuffer_;

    // Simplified atomic counters for basic monitoring
    std::atomic<size_t> samplesInBuffer_{0}; // Keep for basic monitoring/debug
    std::atomic<uint64_t> totalPushedSamples_{0}; // Keep for basic monitoring/debug
    std::atomic<size_t> overflowWriteAttempts_{0}; // Renamed for clarity

    // Logger.
    std::shared_ptr<spdlog::logger> logger_;
};

} // namespace AVS

#endif // AMDTPTRANSMITSTREAMPROCESSOR_H



=== include/Isoch/core/IsochTransportManager.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <atomic>
#include <mutex>
#include <functional>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"

namespace FWA {
namespace Isoch {

/**
 * @brief Callback function for transport finalization
 */
using FinalizeCallback = void(*)(void* refCon);

/**
 * @brief Manager for FireWire isochronous transport operations
 * 
 * This class handles the lifecycle of isochronous transport, including
 * starting and stopping transmission, and managing transport state.
 */
class IsochTransportManager {
public:
    /**
     * @brief Transport state enumeration
     */
    enum class State {
        Stopped,    ///< Transport is stopped
        Starting,   ///< Transport is in the process of starting
        Running,    ///< Transport is running
        Stopping    ///< Transport is in the process of stopping
    };
    
    /**
     * @brief Construct a new IsochTransportManager
     * 
     * @param logger Logger for diagnostic information
     */
    explicit IsochTransportManager(std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Destructor
     */
    ~IsochTransportManager();
    
    // Prevent copying
    IsochTransportManager(const IsochTransportManager&) = delete;
    IsochTransportManager& operator=(const IsochTransportManager&) = delete;
    
    /**
     * @brief Start isochronous transport
     * 
     * @param channel FireWire isochronous channel
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> start(IOFireWireLibIsochChannelRef channel);
    
    /**
     * @brief Stop isochronous transport
     * 
     * @param channel FireWire isochronous channel
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> stop(IOFireWireLibIsochChannelRef channel);
    
    /**
     * @brief Get current transport state
     * 
     * @return State Current state
     */
    State getState() const noexcept { return state_; }
    
    /**
     * @brief Set finalize callback
     * 
     * @param callback Function to call when transport is finalized
     * @param refCon Context pointer to pass to the callback
     */
    void setFinalizeCallback(FinalizeCallback callback, void* refCon) {
        finalizeCallback_ = callback;
        finalizeRefCon_ = refCon;
    }
    
    /**
     * @brief Handle transport finalization
     * 
     * Called when the transport is finalized by FireWire
     */
    void handleFinalize();
    
private:
    /**
     * @brief Prepare for transport start
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> prepareStart();
    
    /**
     * @brief Finish transport stop
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> finishStop();
    
    std::shared_ptr<spdlog::logger> logger_;
    std::atomic<State> state_{State::Stopped};
    std::mutex stateMutex_;
    FinalizeCallback finalizeCallback_{nullptr};
    void* finalizeRefCon_{nullptr};
    std::atomic<bool> finalizeCallbackCalled_{false};
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/ReceiverFactory.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/AmdtpReceiver.hpp"
#include "Isoch/utils/RingBuffer.hpp"

namespace FWA {
namespace Isoch {

/**
 * @brief Factory for creating AMDTP receiver instances
 * 
 * This class provides factory methods for creating configured
 * AMDTP receiver instances with sensible defaults.
 */
class ReceiverFactory {
public:
    /**
     * @brief Create a standard AMDTP receiver with direct configuration
     * 
     * @param config Complete receiver configuration
     * @return std::shared_ptr<AmdtpReceiver> New receiver instance
     */
    static std::shared_ptr<AmdtpReceiver> createStandardReceiver(
        const ReceiverConfig& config);

    /**
     * @brief Create a standard AMDTP receiver (legacy interface)
     * 
     * @param logger Logger for diagnostics
     * @param cyclesPerSegment Number of cycles per segment (default: 8)
     * @param numSegments Number of segments (default: 4)
     * @param cycleBufferSize Size of each cycle buffer in bytes (default: 512)
     * @return std::shared_ptr<AmdtpReceiver> New receiver instance
     */
    static std::shared_ptr<AmdtpReceiver> createStandardReceiver(
        std::shared_ptr<spdlog::logger> logger,
        uint32_t cyclesPerSegment = 8,
        uint32_t numSegments = 4,
        uint32_t cycleBufferSize = 512);
    
    /**
     * @brief Create a high-performance AMDTP receiver
     * 
     * This creates a receiver with more buffer groups and packets
     * for high-bandwidth applications.
     * 
     * @param logger Logger for diagnostics
     * @return std::shared_ptr<AmdtpReceiver> New receiver instance
     */
    static std::shared_ptr<AmdtpReceiver> createHighPerformanceReceiver(
        std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Create a low-latency AMDTP receiver
     * 
     * This creates a receiver with fewer packets per group
     * for lower latency applications.
     * 
     * @param logger Logger for diagnostics
     * @return std::shared_ptr<AmdtpReceiver> New receiver instance
     */
    static std::shared_ptr<AmdtpReceiver> createLowLatencyReceiver(
        std::shared_ptr<spdlog::logger> logger);
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/AmdtpTypes.hpp ===
#pragma once

namespace FWA::Isoch {

enum AmdtpMessageType {
    kAmdtpReceiverAllocateIsochPort = 0x1000,
    kAmdtpReceiverReleaseIsochPort,
    kAmdtpReceiverStarted,
    kAmdtpReceiverStopped,
    kAmdtpReceiverError
};

} // namespace FWA::Isoch


=== include/Isoch/core/IsochTypes.hpp ===
#pragma once

#include <cstdint>
#include <IOKit/IOTypes.h>
#include <IOKit/firewire/IOFireWireLib.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>

namespace FWA {
namespace Isoch {

#include <IOKit/IOReturn.h>
#include <cstdint>

// Placeholder structs for legacy types
struct UniversalTransmitter;

struct CIPHeader {
    UInt32 header[2];
};

// Placeholder for UniversalTransmitterCycleInfo
struct UniversalTransmitterCycleInfo
{
    UInt32 index;                    // Cycle index within the transmission program

    UInt32 numRanges;                // Number of valid memory ranges
    IOVirtualRange ranges[5];        // Memory ranges for audio data (up to 5 ranges)
	// for FireWire Isochronous Header
	UInt8 sy;						// only low 4 bits valid!
	UInt8 tag;						// only low 2 bits valid!

    CIPHeader cipHeader;             // Precomputed CIP header for this cycle
    unsigned int nevents;            // Number of events (frames) generated for this cycle

    UInt16 nodeID;                   // Node ID for the FireWire device
    UInt32 expectedTransmitCycleTime; // Expected cycle time in FireWire clock ticks
    
    UInt64 transmitTimeInNanoSeconds; // Calculated transmission time in nanoseconds

	bool isBlocking;                 // Indicates blocking transmission for AM824 data

	UInt32 currentCycleTime;         // Current FireWire cycle time

    // Indicates if the DCL program is running:
    // - If true: "seconds field" in `expectedTransmitCycleTime` is valid.
    // - If false: "seconds field" in `expectedTransmitCycleTime` is not guaranteed.
    // Also, `transmitTimeInNanoSeconds` is valid only when true.
    bool dclProgramRunning;
};

// Other Isoch types will be added as needed

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochTransmitBufferManager.hpp ===
#pragma once

#include "Isoch/interfaces/ITransmitBufferManager.hpp"
#include <vector>
#include <mutex>

namespace FWA {
namespace Isoch {

class IsochTransmitBufferManager : public ITransmitBufferManager {
public:
    explicit IsochTransmitBufferManager(std::shared_ptr<spdlog::logger> logger);
    ~IsochTransmitBufferManager() override;

    // Prevent Copy
    IsochTransmitBufferManager(const IsochTransmitBufferManager&) = delete;
    IsochTransmitBufferManager& operator=(const IsochTransmitBufferManager&) = delete;

    std::expected<void, IOKitError> setupBuffers(const TransmitterConfig& config) override;
    void cleanup() noexcept override;

    std::expected<uint8_t*, IOKitError> getPacketIsochHeaderPtr(uint32_t groupIndex, uint32_t packetIndexInGroup) const override;
    std::expected<uint8_t*, IOKitError> getPacketCIPHeaderPtr(uint32_t groupIndex, uint32_t packetIndexInGroup) const override;
    std::expected<uint32_t*, IOKitError> getGroupTimestampPtr(uint32_t groupIndex) const override;

    uint8_t* getClientAudioBufferPtr() const override;
    size_t getClientAudioBufferSize() const override;
    size_t getAudioPayloadSizePerPacket() const override;

    const IOVirtualRange& getBufferRange() const override;
    size_t getTotalBufferSize() const override;

private:
    void calculateBufferLayout();

    std::shared_ptr<spdlog::logger> logger_;
    TransmitterConfig config_; // Store local copy
    uint32_t totalPackets_{0};
    size_t audioPayloadSizePerPacket_{0}; // Calculated based on channels/format

    // Buffer management
    uint8_t* mainBuffer_{nullptr};
    size_t totalBufferSize_{0};
    IOVirtualRange bufferRange_{};

    // Pointers into mainBuffer_
    uint8_t* clientAudioArea_{nullptr};
    uint8_t* isochHeaderArea_{nullptr}; // Template area
    uint8_t* cipHeaderArea_{nullptr};   // Pre-filled area
    uint32_t* timestampArea_{nullptr};  // HW writes here

    // Buffer section sizes (aligned)
    size_t clientBufferSize_aligned_{0};
    size_t isochHeaderTotalSize_aligned_{0};
    size_t cipHeaderTotalSize_aligned_{0};
    size_t timestampTotalSize_aligned_{0};

    mutable std::mutex mutex_; // For thread safety
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/ReceiverTypes.hpp ===
#pragma once

#include <cstdint>
#include <memory>
#include <vector> // Added for ProcessedSample vector
#include <spdlog/logger.h>

namespace FWA {
namespace Isoch {

// Forward declarations
class AmdtpReceiver;

/**
 * @brief Enumeration of receiver message types
 */
enum class ReceiverMessage : uint32_t {
    BufferError = 0x1000,     ///< Error accessing buffer
    PacketError,              ///< Error processing packet
    OverrunError,             ///< Buffer overrun occurred
    GroupError,               ///< Error with group completion
    NoDataTimeout,            ///< No data received within timeout
    DBCDiscontinuity          ///< DBC discontinuity detected
};

/**
 * @brief Structure containing received cycle data
 */
struct ReceivedCycleData {
    void* refCon{nullptr};           ///< Client reference data
    uint32_t payloadLength{0};       ///< Length of payload in bytes
    const uint8_t* payload{nullptr}; ///< Pointer to payload data
    uint32_t isochHeader{0};         ///< Original isochronous header
    uint32_t fireWireTimeStamp{0};   ///< FireWire cycle timestamp
    uint64_t nanoSecondsTimeStamp{0};///< Timestamp in nanoseconds
    uint32_t groupIndex{0};          ///< Group index
    uint32_t packetIndex{0};         ///< Packet index within group
    void* expansionData{nullptr};    ///< Reserved for future use
};

/**
 * @brief Callback for received packet data
 * 
 * @param data Pointer to packet data
 * @param length Length of packet data in bytes
 * @param refCon Client-provided reference context
 */
using PacketCallback = void(*)(const uint8_t* data, size_t length, void* refCon);

/**
 * @brief Callback for structured cycle data
 * 
 * @param data Structured cycle data
 * @param refCon Client-provided reference context
 */
using StructuredDataCallback = void(*)(const ReceivedCycleData& data, void* refCon);

/**
 * @brief Callback for no-data condition
 * 
 * @param lastCycle Last cycle number received
 * @param refCon Client-provided reference context
 */
using NoDataCallback = void(*)(uint32_t lastCycle, void* refCon);

/**
 * @brief Callback for messages from the receiver
 * 
 * @param message Message code
 * @param param1 First parameter (meaning depends on message)
 * @param param2 Second parameter (meaning depends on message)
 * @param refCon Client-provided reference context
 */
using MessageCallback = void(*)(uint32_t message, uint32_t param1, uint32_t param2, void* refCon);

/**
 * @brief Configuration for AMDTP receiver
 */
struct ReceiverConfig {
    uint32_t numGroups{8};           ///< Total number of buffer groups
    uint32_t packetsPerGroup{16};    ///< Number of FW packets per group
    uint32_t packetDataSize{64};     ///< Bytes of audio data per FW packet
    uint32_t callbackGroupInterval{1};///< Trigger callback every N groups
    uint32_t timeout{1000};           ///< Timeout for no-data detection in milliseconds
    bool doIRMAllocations{true};      ///< Whether to use IRM allocations
    uint32_t irmPacketSize{72};       ///< Packet size for IRM allocations
    std::shared_ptr<spdlog::logger> logger; ///< Logger for diagnostics
};

/**
 * @brief Callback for segment completion events (legacy)
 * 
 * @param segment Segment number that completed
 * @param timestamp FireWire timestamp for the segment
 * @param refCon Client-provided reference context
 */
using SegmentCompletionCallback = void(*)(uint32_t segment, uint32_t timestamp, void* refCon);

/**
 * @brief Callback for group completion events
 * 
 * @param groupIndex Group index that completed
 * @param timestamp FireWire timestamp for the group
 * @param refCon Client-provided reference context
 */
using GroupCompletionCallback = void(*)(uint32_t groupIndex, uint32_t timestamp, void* refCon);

/**
 * @brief Represents timing information extracted from a single packet
 */
struct PacketTimingInfo {
    uint32_t fwTimestamp{0};      ///< DCL completion timestamp for this packet's group/DCL
    uint16_t syt{0xFFFF};         ///< SYT field from CIP header (0xFFFF if invalid/no info)
    uint8_t firstDBC{0};          ///< DBC value of the first data block in this packet
    uint32_t numSamplesInPacket{0};///< Total number of valid audio samples extracted from this packet
    uint32_t fdf{0xFF};           ///< FDF field for context
    uint8_t sfc{0xFF};            ///< Sample Frequency Code extracted from FDF (if applicable)
    uint64_t firstAbsSampleIndex{0}; ///< Absolute sample index of the first sample in packet
};

/**
 * @brief Represents a single processed audio sample with its absolute index
 */
struct ProcessedSample {
    float sampleL{0.0f};          ///< Left channel sample value
    float sampleR{0.0f};          ///< Right channel sample value
    uint64_t absoluteSampleIndex{0}; ///< The index of this frame since stream start
};

/**
 * @brief New callback type for passing processed data + timing upstream
 *
 * @param samples Vector of samples from one packet
 * @param timing Timing info for that packet
 * @param refCon Client-provided reference context
 */
using ProcessedDataCallback = void(*)(
    const std::vector<ProcessedSample>& samples,
    const PacketTimingInfo& timing,
    void* refCon
);

/**
 * @brief Represents an audio frame with presentation timestamp for application consumption
 */
struct ProcessedAudioFrame {
    float sampleL{0.0f};          ///< Left channel sample value
    float sampleR{0.0f};          ///< Right channel sample value
    uint64_t presentationNanos{0};///< Host time (in nanoseconds) when this sample should be presented
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochManager.hpp ===
#pragma once

#include <memory>
#include <vector>
#include <functional>
#include <expected>
#include <atomic>
#include <mutex>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"

namespace FWA {
namespace Isoch {

/**
 * @brief Callback function for DCL completion events
 */
using DCLCompleteCallback = void(*)(uint32_t segment, void* refCon);

/**
 * @brief Callback function for DCL overrun events
 */
using DCLOverrunCallback = void(*)(void* refCon);

/**
 * @brief Manager for isoch operations combining DCL and port management
 * 
 * This class handles the FireWire isochronous communication infrastructure
 * including DCL program creation, port management, and channel configuration.
 */
class IsochManager {
public:
    /**
     * @brief Construct a new IsochManager instance
     * 
     * @param logger Logger for diagnostic information
     */
    explicit IsochManager(std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Destructor - handles cleanup of FireWire resources
     */
    ~IsochManager();
    
    // Prevent copying
    IsochManager(const IsochManager&) = delete;
    IsochManager& operator=(const IsochManager&) = delete;
    
    /**
     * @brief Initialize the IsochManager with a FireWire interface
     * 
     * @param interface The FireWire interface to use
     * @param isTalker Whether this is a talker (true) or listener (false)
     * @param runLoop The RunLoop to use for callbacks, or nullptr for current
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> initialize(
        IOFireWireLibNubRef interface,
        bool isTalker,
        CFRunLoopRef runLoop = nullptr);
    
    /**
     * @brief Create a DCL program for isochronous communication
     * 
     * @param cyclesPerSegment Number of cycles per segment
     * @param numSegments Number of segments in the DCL program
     * @param cycleBufferSize Size of each cycle buffer in bytes
     * @param bufferRange Memory range for the buffers
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> createDCLProgram(
        uint32_t cyclesPerSegment, 
        uint32_t numSegments, 
        uint32_t cycleBufferSize,
        IOVirtualRange& bufferRange);
    
    /**
     * @brief Configure the isochronous channel with speed and channel number
     * 
     * @param speed The FireWire speed to use
     * @param channel The channel number to use, or kAnyAvailableIsochChannel
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> configure(IOFWSpeed speed, uint32_t channel);
    
    /**
     * @brief Get the DCL program for use with local port
     * 
     * @return std::expected<DCLCommandPtr, IOKitError> DCL program or error code
     */
    std::expected<DCLCommandPtr, IOKitError> getProgram() const;
    
    /**
     * @brief Get the isoch channel
     * 
     * @return IOFireWireLibIsochChannelRef The FireWire isoch channel
     */
    IOFireWireLibIsochChannelRef getIsochChannel() const { return isochChannel_; }
    
    /**
     * @brief Get the active isoch channel number
     * 
     * @return std::expected<uint32_t, IOKitError> Active channel number or error
     */
    std::expected<uint32_t, IOKitError> getActiveChannel() const;
    
    /**
     * @brief Set the callback for DCL completion events
     * 
     * @param callback Function to call when a segment completes
     * @param refCon Context pointer to pass to the callback
     */
    void setDCLCompleteCallback(DCLCompleteCallback callback, void* refCon) {
        dclCompleteCallback_ = callback;
        dclCompleteRefCon_ = refCon;
    }
    
    /**
     * @brief Set the callback for DCL overrun events
     * 
     * @param callback Function to call on DCL overrun
     * @param refCon Context pointer to pass to the callback
     */
    void setDCLOverrunCallback(DCLOverrunCallback callback, void* refCon) {
        dclOverrunCallback_ = callback;
        dclOverrunRefCon_ = refCon;
    }
    
    /**
     * @brief Handle segment completion
     * 
     * @param segment Segment that completed
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> handleSegmentComplete(uint32_t segment);
    
    /**
     * @brief Fix up DCL jump targets
     * 
     * This updates the DCL branch instructions to maintain the proper flow
     * through the DCL program, especially after segment completion.
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> fixupDCLJumpTargets();
    
    /**
     * @brief Reset the IsochManager state
     */
    void reset();
    
    /**
     * @brief Special value for any available isoch channel
     */
    static constexpr uint32_t kAnyAvailableIsochChannel = 0xFFFFFFFF;
    
    /**
     * @brief Get the timestamps buffer address for a segment
     * 
     * @param segment Segment number
     * @return std::expected<uint32_t*, IOKitError> Pointer to timestamp or error
     */
    std::expected<uint32_t*, IOKitError> getTimestampPtr(uint32_t segment) const;

    /**
 * @brief Get the timestamp for a segment
 * 
 * @param segment Segment number
 * @return std::expected<uint32_t, IOKitError> Timestamp or error
 */
std::expected<uint32_t, IOKitError> getSegmentTimestamp(uint32_t segment) const;

// testing only
    // Methods to get segment info for data processing
    uint32_t getLastProcessedSegment() const {
        return processedSegments_.load(std::memory_order_acquire);
    }
    
    uint32_t getLastProcessedTimestamp() const {
        return processedTimestamps_.load(std::memory_order_acquire);
    }
    
private:

std::atomic<bool> hasReceivedData_{false};
bool hasReceivedData() const {
    return hasReceivedData_.load(std::memory_order_acquire);
}

void processSegmentData(uint32_t segment, uint32_t timestamp);

    // testing only
    // Just two simple atomics for segment tracking
    std::atomic<uint32_t> processedSegments_{0};
    std::atomic<uint32_t> processedTimestamps_{0};

    /**
     * @brief Structure for DCL segment information
     */
    struct SegmentInfo {
        NuDCLRef startDCL{nullptr};     ///< First DCL in segment
        NuDCLRef endDCL{nullptr};       ///< Last DCL in segment
        CFMutableSetRef updateBag{nullptr}; ///< Bag for DCL updates
        bool isActive{false};           ///< Whether this segment is active
    };
    
    // Setup methods
    std::expected<void, IOKitError> setupNuDCLPool();
    std::expected<void, IOKitError> createRemotePort();
    std::expected<void, IOKitError> createLocalPort(IOVirtualRange& bufferRange);
    std::expected<void, IOKitError> createIsochChannel();
    std::expected<void, IOKitError> createSegmentDCLs(IOVirtualRange& bufferRange);
    std::expected<void, IOKitError> createOverrunDCL(IOVirtualRange& bufferRange);
    
    // Static callback handlers for FireWire
    static IOReturn RemotePort_GetSupported_Helper(
        IOFireWireLibIsochPortRef interface,
        IOFWSpeed *outMaxSpeed,
        UInt64 *outChanSupported);
        
    static IOReturn RemotePort_AllocatePort_Helper(
        IOFireWireLibIsochPortRef interface,
        IOFWSpeed maxSpeed,
        UInt32 channel);
        
    static IOReturn RemotePort_ReleasePort_Helper(
        IOFireWireLibIsochPortRef interface);
        
    static IOReturn RemotePort_Start_Helper(
        IOFireWireLibIsochPortRef interface);
        
    static IOReturn RemotePort_Stop_Helper(
        IOFireWireLibIsochPortRef interface);
        
    static IOReturn PortFinalize_Helper(void* refcon);
    
    static void DCLComplete_Helper(void* refcon, NuDCLRef dcl);
    static void DCLOverrun_Helper(void* refcon, NuDCLRef dcl);
    
    // Instance callback handlers
    void handleDCLComplete(NuDCLRef dcl);
    void handleDCLOverrun();
    void handlePortFinalize();
    
    // Helper methods
    bool isValidSegment(uint32_t segment) const;
    NuDCLRef getDCLForSegment(uint32_t segment, uint32_t cycle) const;
    IOReturn notifyJumpUpdate(NuDCLRef dcl);
    
    // FireWire resources
    IOFireWireLibNubRef interface_{nullptr};
    IOFireWireLibNuDCLPoolRef nuDCLPool_{nullptr};
    IOFireWireLibRemoteIsochPortRef remotePort_{nullptr};
    IOFireWireLibLocalIsochPortRef localPort_{nullptr};
    IOFireWireLibIsochChannelRef isochChannel_{nullptr};
    
    // DCL program state
    std::vector<SegmentInfo> segments_;
    NuDCLRef overrunDCL_{nullptr};
    std::atomic<uint32_t> currentSegment_{0};
    uint32_t cyclesPerSegment_{0};
    uint32_t numSegments_{0};
    uint32_t cycleBufferSize_{0};
    
    // Buffer and timestamp tracking
    uint8_t* baseBuffer_{nullptr};
    uint32_t* timestampBuffer_{nullptr};
    
    // Configuration state
    std::shared_ptr<spdlog::logger> logger_;
    CFRunLoopRef runLoop_{nullptr};
    bool isTalker_{false};
    bool initialized_{false};
    bool finalized_{false};
    std::atomic<bool> running_{false};
    IOFWSpeed configuredSpeed_{kFWSpeed100MBit};
    uint32_t configuredChannel_{kAnyAvailableIsochChannel};
    uint32_t activeChannel_{kAnyAvailableIsochChannel};
    
    // Callbacks with refcons
    DCLCompleteCallback dclCompleteCallback_{nullptr};
    void* dclCompleteRefCon_{nullptr};
    DCLOverrunCallback dclOverrunCallback_{nullptr};
    void* dclOverrunRefCon_{nullptr};
    
    // Thread synchronization
    std::mutex stateMutex_;
};

} // namespace Isoch
} // namespace FWA





=== include/Isoch/core/AmdtpReceiver.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <atomic>
#include <vector>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/ReceiverTypes.hpp"
#include "Isoch/utils/RingBuffer.hpp"

namespace FWA {
namespace Isoch {

// Forward declarations
class IsochDCLManager;
class IsochPortChannelManager;
class IsochBufferManager;
class IsochTransportManager;
class IsochPacketProcessor;
class IsochMonitoringManager;
class AudioClockPLL;

// namespace raul { class RingBuffer; }

/**
 * @brief AMDTP receiver for FireWire isochronous data reception
 */
class AmdtpReceiver : public std::enable_shared_from_this<AmdtpReceiver> {
public:
    /**
     * @brief Factory method to create an AmdtpReceiver instance
     * 
     * @param config Configuration parameters
     * @return std::shared_ptr<AmdtpReceiver> New receiver instance
     */
    static std::shared_ptr<AmdtpReceiver> create(const ReceiverConfig& config);
    
    /**
     * @brief Destructor - ensures proper resource cleanup
     */
    ~AmdtpReceiver();
    
    // Prevent copying
    AmdtpReceiver(const AmdtpReceiver&) = delete;
    AmdtpReceiver& operator=(const AmdtpReceiver&) = delete;
    
    /**
     * @brief Initialize the receiver with a FireWire interface
     * 
     * @param interface FireWire interface to use
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> initialize(IOFireWireLibNubRef interface);
    
    /**
     * @brief Configure the receiver with speed and channel
     * 
     * @param speed FireWire speed to use
     * @param channel Channel number to use
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> configure(IOFWSpeed speed, uint32_t channel);
    
    /**
     * @brief Start receiving data
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> startReceive();
    
    /**
     * @brief Stop receiving data
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> stopReceive();
    
    /**
     * @brief Set processed data callback for received samples
     * 
     * @param callback Function to call with processed sample data
     * @param refCon Context pointer to pass to the callback
     */
    void setProcessedDataCallback(ProcessedDataCallback callback, void* refCon);
    
    /**
     * @brief Set structured data callback for cycle data
     * 
     * @param callback Function to call with structured data
     * @param refCon Context pointer to pass to the callback
     */
    void setStructuredCallback(StructuredDataCallback callback, void* refCon);
    
    /**
     * @brief Set no-data callback for timeout conditions
     * 
     * @param callback Function to call on timeout
     * @param refCon Context pointer to pass to the callback
     * @param timeoutMs Timeout in milliseconds
     * @param cipOnlyMode True to consider CIP-only packets as no data
     */
    void setNoDataCallback(NoDataCallback callback, void* refCon, uint32_t timeoutMs, bool cipOnlyMode = true);
    
    /**
     * @brief Set message callback for status messages
     * 
     * @param callback Function to call with messages
     * @param refCon Context pointer to pass to the callback
     */
    void setMessageCallback(MessageCallback callback, void* refCon);
    
    /**
     * @brief Set group completion callback
     * 
     * @param callback Function to call when a group completes
     * @param refCon Context pointer to pass to the callback
     */
    void setGroupCompletionCallback(GroupCompletionCallback callback, void* refCon);
    
    /**
     * @brief Handle buffer group completion
     * 
     * @param groupIndex Group index that completed
     */
    void handleBufferGroupComplete(uint32_t groupIndex);
    
    /**
     * @brief Handle buffer overrun
     */
    void handleOverrun();
    
    /**
     * @brief Get the RunLoop used by the receiver
     * 
     * @return CFRunLoopRef The RunLoop
     */
    CFRunLoopRef getRunLoopRef() const { return runLoopRef_; }

    /**
     * @brief Get a pointer to the application ring buffer.
     * @return Pointer to the raul::RingBuffer, or nullptr if not initialized.
     */
    raul::RingBuffer* getAppRingBuffer() const; // <<< Declaration Added Here
    
private:
    /**
     * @brief Constructor - use create() factory method instead
     * 
     * @param config Configuration parameters
     */
    explicit AmdtpReceiver(const ReceiverConfig& config);
    
    /**
     * @brief Set up components
     * 
     * @param interface FireWire interface to use
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> setupComponents(IOFireWireLibNubRef interface);
    
    /**
     * @brief Clean up resources
     */
    void cleanup() noexcept;
    
    /**
     * @brief Synchronize host and FireWire clocks and initialize the PLL
     * 
     * Uses the FireWire device's GetCycleTimeAndUpTime function to get a 
     * precise correlation between host time and FireWire cycle time
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> synchronizeAndInitializePLL();
    
    /**
     * @brief Send message to client
     * 
     * @param msg Message code
     * @param param1 First parameter
     * @param param2 Second parameter
     */
    void notifyMessage(uint32_t msg, uint32_t param1 = 0, uint32_t param2 = 0);
    
    /**
     * @brief Handle overrun recovery
     * 
     * Stops the channel, fixes DCL targets, and restarts to recover from overrun
     */
    std::expected<void, IOKitError> handleOverrunRecovery();
    
    // Static callbacks with proper refcon passing
    static void handleDCLComplete(uint32_t groupIndex, void* refCon);
    static void handleDCLOverrun(void* refCon);
    static void handleTransportFinalize(void* refCon);
    
    // NEW static helper for processed data
    static void handleProcessedDataStatic(const std::vector<ProcessedSample>& samples,
                                         const PacketTimingInfo& timing,
                                         void* refCon);
    
    // Instance method for processed data
    void handleProcessedData(const std::vector<ProcessedSample>& samples,
                            const PacketTimingInfo& timing);
    
    // For structured callback forwarding
    static void handleStructuredCallback(const ReceivedCycleData& data, void* refCon);
    
    // For no-data callback forwarding
    static void handleNoDataCallback(uint32_t lastCycle, void* refCon);
    
    // Configuration
    ReceiverConfig config_;
    std::shared_ptr<spdlog::logger> logger_;
    
    // Components
    std::unique_ptr<IsochDCLManager> dclManager_;
    std::unique_ptr<IsochPortChannelManager> portChannelManager_;
    std::unique_ptr<IsochBufferManager> bufferManager_;
    std::unique_ptr<IsochTransportManager> transportManager_;
    std::unique_ptr<IsochPacketProcessor> packetProcessor_;
    std::unique_ptr<IsochMonitoringManager> monitoringManager_;
    
    // Future components (placeholders)
    std::unique_ptr<AudioClockPLL> pll_{nullptr};
    std::unique_ptr<class raul::RingBuffer> appRingBuffer_{nullptr};
    
    // RunLoop reference
    CFRunLoopRef runLoopRef_{nullptr};
    
    // Callbacks with proper refcons
    ProcessedDataCallback processedDataCallback_{nullptr};
    void* processedDataCallbackRefCon_{nullptr};
    
    StructuredDataCallback structuredCallback_{nullptr};
    void* structuredCallbackRefCon_{nullptr};
    
    NoDataCallback noDataCallback_{nullptr};
    void* noDataCallbackRefCon_{nullptr};
    
    MessageCallback messageCallback_{nullptr};
    void* messageCallbackRefCon_{nullptr};
    
    GroupCompletionCallback groupCompletionCallback_{nullptr};
    void* groupCompletionRefCon_{nullptr};
    
    // State
    std::atomic<bool> initialized_{false};
    std::atomic<bool> running_{false};
    
    // Callback forwarding structures
    struct CallbackData {
        AmdtpReceiver* receiver;
        void* clientRefCon;
    };
    
    // To store callback data on heap
    std::vector<std::unique_ptr<CallbackData>> callbackDataStore_;
};

} // namespace Isoch
} // namespace FWA





=== include/Isoch/core/AudioClockPLL.hpp ===
#pragma once

#include <memory>
#include <cstdint>
#include <atomic> // For atomic boolean 'initialized_'
#include <spdlog/logger.h>
#include <mach/mach_time.h> // For mach_timebase_info_data_t
#include "Isoch/core/ReceiverTypes.hpp" // For PacketTimingInfo

namespace FWA {
namespace Isoch {

class AudioClockPLL {
public:
    explicit AudioClockPLL(std::shared_ptr<spdlog::logger> logger);
    ~AudioClockPLL();

    // Initialize the PLL with initial timing correlation
    void initialize(uint64_t initialHostTimeAbs, uint32_t initialFwTimestamp);

    // Update PLL state based on new timing info from a packet
    void update(const PacketTimingInfo& timing, uint64_t currentHostTimeAbs);

    // Calculate the estimated presentation time for a given absolute sample index
    uint64_t getPresentationTimeNs(uint64_t absoluteSampleIndex);
    
    // Set target sample rate
    void setSampleRate(double rate);
    
    // Allow tuning gains
    void setPllGains(double kp, double ki);
    
    // Reset PLL state
    void resetState();
    
    // Use atomic getter
    bool isInitialized() const { return initialized_.load(); }
    
    // Helper to be called when the first valid SYT is received AFTER initialize
    void updateInitialSYT(uint16_t firstSyt, uint32_t firstSytFwTimestamp, uint64_t firstSytAbsSampleIndex);

private:
    std::shared_ptr<spdlog::logger> logger_;
    std::atomic<bool> initialized_{false}; // Use atomic for thread safety

    // Host and device clock constants
    double targetSampleRate_ = 44100.0;
    const uint64_t fwClock_NominalRate_ = 24576000; // Ticks per second
    const double fwClock_NominalRateHz_ = 24576000.0; // Double version for calculations

    // Host timebase info
    mach_timebase_info_data_t timebaseInfo_{}; // For host clock info
    uint64_t hostTicksPerSecond_ = 0;          // Approx host ticks/sec

    // Anchor points for timing correlation
    uint64_t initialHostTimeNano_ = 0;
    uint64_t initialHostTimeAbs_ = 0;          // Initial host time in mach_absolute_time units
    uint32_t initialFwTimestamp_ = 0;

    // Last known packet info
    uint64_t lastHostTimeNano_ = 0;
    uint64_t lastHostTimeAbs_ = 0;         // Last host time (absolute ticks) PLL was updated
    uint32_t lastFwTimestamp_ = 0;         // Last FW timestamp used in update
    uint16_t lastSYT_ = 0xFFFF;            // Last valid SYT value received
    
    // For SYT-based timing correlation
    uint32_t lastSYT_FWTimestamp_ = 0;     // FW timestamp when lastSYT_ arrived
    uint64_t lastSYT_AbsSampleIndex_ = 0;  // Sample index corresponding to lastSYT_
    uint64_t lastSYT_HostTimeAbs_ = 0;     // Host time (absolute ticks) when lastSYT_ arrived/processed
    uint64_t lastAbsSampleIndex_ = 0;
    uint64_t lastPacketEndAbsSampleIndex_ = 0; // Sample index after the last processed packet

    // PLL filter state
    double currentRatio_ = 1.0;                // Ratio of FW ticks to Host ticks
    double phaseErrorAccumulator_ = 0.0;       // PI controller integral term
    double frequencyAdjustment_ = 0.0;         // PI controller output

    // PLL constants
    double pllProportionalGain_ = 0.01;
    double pllIntegralGain_ = 0.0005;
    double integralMax_ = 0.001;       // Max accumulator value (prevents windup)
    double integralMin_ = -0.001;      // Min accumulator value

    // Helper methods
    void initializeHostClockInfo();
    uint64_t absolute_to_nanoseconds(uint64_t mach_time) const;
    uint64_t nanoseconds_to_absolute(uint64_t nano_time) const;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/AmdtpTransmitter.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <atomic>
#include <mutex>
#include <vector>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>

#include "FWA/Error.h"
#include "Isoch/core/TransmitterTypes.hpp"
#include "Isoch/interfaces/ITransmitBufferManager.hpp"
#include "Isoch/interfaces/ITransmitDCLManager.hpp"
#include "Isoch/interfaces/ITransmitPacketProvider.hpp"

// Forward declarations
namespace FWA {
namespace Isoch {
class IsochPortChannelManager; // Assume reusable
class IsochTransportManager; // Assume reusable
} }

namespace FWA {
namespace Isoch {

class AmdtpTransmitter : public std::enable_shared_from_this<AmdtpTransmitter> {
public:
    // Factory method
    static std::shared_ptr<AmdtpTransmitter> create(const TransmitterConfig& config);

    ~AmdtpTransmitter();

    // Prevent copy
    AmdtpTransmitter(const AmdtpTransmitter&) = delete;
    AmdtpTransmitter& operator=(const AmdtpTransmitter&) = delete;

    // Core lifecycle methods
    std::expected<void, IOKitError> initialize(IOFireWireLibNubRef interface);
    std::expected<void, IOKitError> configure(IOFWSpeed speed, uint32_t channel);
    std::expected<void, IOKitError> startTransmit();
    std::expected<void, IOKitError> stopTransmit();

    // Method for client to push data into the transmitter's provider
    bool pushAudioData(const void* buffer, size_t bufferSizeInBytes);

    // Set message callback
    void setMessageCallback(MessageCallback callback, void* refCon);

    // Get underlying runloop
    CFRunLoopRef getRunLoopRef() const { return runLoopRef_; }

    ITransmitPacketProvider* getPacketProvider() const;


private:
    // Private constructor for factory
    explicit AmdtpTransmitter(const TransmitterConfig& config);

    // Setup and cleanup
    std::expected<void, IOKitError> setupComponents(IOFireWireLibNubRef interface);
    void cleanup() noexcept;

    // Internal DCL callback handlers (instance methods)
    void handleDCLComplete(uint32_t completedGroupIndex);
    void handleDCLOverrun();

    // Static callback helpers (forward to instance methods)
    static void DCLCompleteCallback_Helper(uint32_t completedGroupIndex, void* refCon);
    static void DCLOverrunCallback_Helper(void* refCon);
    static void TransportFinalize_Helper(void* refCon); // If needed

     // CIP Header/Timing generation logic
     void initializeCIPState();
     void prepareCIPHeader(CIPHeader* outHeader); // Fills header based on state
     
     // Helper to send messages to the client
     void notifyMessage(TransmitterMessage msg, uint32_t p1 = 0, uint32_t p2 = 0);

    // Configuration & Logger
    TransmitterConfig config_;
    std::shared_ptr<spdlog::logger> logger_;

    // Manager Components
    std::unique_ptr<ITransmitBufferManager> bufferManager_;
    std::unique_ptr<IsochPortChannelManager> portChannelManager_; // Reusable
    std::unique_ptr<ITransmitDCLManager> dclManager_;
    std::unique_ptr<IsochTransportManager> transportManager_;     // Reusable
    std::unique_ptr<ITransmitPacketProvider> packetProvider_;

    // RunLoop
    CFRunLoopRef runLoopRef_{nullptr};

    // State
    std::atomic<bool> initialized_{false};
    std::atomic<bool> running_{false};
    std::mutex stateMutex_;

     // CIP Header State
     uint8_t dbc_count_{0};
     bool wasNoData_{true}; // Start assuming previous was NoData
     uint16_t sytOffset_{0};
     uint32_t sytPhase_{0}; // For 44.1kHz calculation
     bool firstDCLCallbackOccurred_{false};
     uint32_t expectedTimeStampCycle_{0}; // For timestamp checking

    // Client Callbacks
    MessageCallback messageCallback_{nullptr};
    void* messageCallbackRefCon_{nullptr};

    // Static constants for SYT calc (example for 44.1)
    static constexpr uint32_t SYT_PHASE_MOD = 147;
    static constexpr uint32_t SYT_PHASE_RESET = 1470;
    static constexpr uint32_t BASE_TICKS = 1386; // ~1/8 of TICKS_PER_CYCLE
    static constexpr uint32_t TICKS_PER_CYCLE = 3072;
};

} // namespace Isoch
} // namespace FWA



=== include/Isoch/core/Types.hpp ===
#pragma once

#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

namespace FWA {
namespace Isoch {

// Use the system's IOVirtualRange instead of defining our own
// This prevents type conflicts with system FireWire libraries
using IOVirtualRange = ::IOVirtualRange;

// Common DCL-related type definitions
using DCLCommandPtr = NuDCLRef;  // Changed to use NuDCLRef which is the correct type
using SendPacketRef = NuDCLSendPacketRef;

// Common struct for cycle information
struct CycleInfo {
    IOVirtualRange ranges[2];  // One for CIP header, one for data
    uint32_t numRanges{0};
    bool isEventPending{false};
};

// Message types for AMDTP communication
enum class AmdtpMessageType : uint32_t {
    DataPull = 1,
    TimeStampAdjust,
    DCLOverrunAutoRestartFailed,
    AllocateIsochPort,
    ReleaseIsochPort
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/SharedTypes.hpp ===
#pragma once
#include <cstdint>
#include <functional>

namespace FWA {
namespace Isoch {

// Common callback types shared between transmitter and receiver
using PacketCallbackConst = std::function<void(const uint8_t* data, size_t size)>;
using PacketCallbackMutable = std::function<void(uint8_t* data, size_t size)>;
using MessageCallback = std::function<void(uint32_t msg, uint32_t param1, uint32_t param2)>;

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochPacketProcessor.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <functional>
#include <atomic>   // For atomic state variables
#include <vector>   // For ProcessedSample vector
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/ReceiverTypes.hpp"
#include "Isoch/core/IsochBufferManager.hpp" // Include buffer manager for constants

namespace FWA {
namespace Isoch {

/**
 * @brief Processor for FireWire isochronous packets
 * 
 * This class handles processing received packets, extracting data,
 * and forwarding to client code with proper refcon preservation.
 */
class IsochPacketProcessor {
public:
    /**
     * @brief Set callback for overrun events
     * 
     * @param callback Function to call on overrun
     * @param refCon Context pointer to pass to the callback
     */
    using OverrunCallback = void(*)(void* refCon);
    
    /**
     * @brief Construct a new IsochPacketProcessor
     * 
     * @param logger Logger for diagnostic information
     */
    explicit IsochPacketProcessor(std::shared_ptr<spdlog::logger> logger);
    
    /**
     * @brief Destructor
     */
    ~IsochPacketProcessor() = default;
    
    // Prevent copying
    IsochPacketProcessor(const IsochPacketProcessor&) = delete;
    IsochPacketProcessor& operator=(const IsochPacketProcessor&) = delete;
    
    /**
     * @brief Set callback for processed data
     * 
     * @param callback Function to call with processed sample data
     * @param refCon Context pointer to pass to the callback
     */
    void setProcessedDataCallback(ProcessedDataCallback callback, void* refCon);

    /**
     * @brief Set callback for overrun events
     * 
     * @param callback Function to call on overrun
     * @param refCon Context pointer to pass to the callback
     */
    void setOverrunCallback(OverrunCallback callback, void* refCon);
    
    /**
     * @brief Process a received packet with separate pointers for headers and data
     * 
     * @param groupIndex Group index
     * @param packetIndexInGroup Packet index within the group
     * @param isochHeader Pointer to 4-byte Isoch Header
     * @param cipHeader Pointer to 8-byte CIP Header
     * @param packetData Pointer to actual audio data payload
     * @param packetDataLength Length of packetData
     * @param timestamp Timestamp value for this packet
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> processPacket(
        uint32_t groupIndex,
        uint32_t packetIndexInGroup,
        const uint8_t* isochHeader,
        const uint8_t* cipHeader,
        const uint8_t* packetData,
        size_t packetDataLength,
        uint32_t timestamp);
    
    /**
     * @brief Legacy method for backwards compatibility
     * 
     * @deprecated Use the new processPacket with separate pointers instead
     */
    std::expected<void, IOKitError> processPacket(
        uint32_t segment,
        uint32_t cycle,
        const uint8_t* data,
        size_t length);
    
    /**
     * @brief Handle packet overrun condition
     * 
     * @return std::expected<void, IOKitError> Success or error code
     */
    std::expected<void, IOKitError> handleOverrun();
    
private:
    // Callback info
    ProcessedDataCallback processedDataCallback_{nullptr};
    void* processedDataCallbackRefCon_{nullptr};
    OverrunCallback overrunCallback_{nullptr};
    void* overrunCallbackRefCon_{nullptr};

    // Internal State
    std::shared_ptr<spdlog::logger> logger_;
    uint8_t expectedDBC_{0}; 
    bool dbcInitialized_{false};
    uint64_t currentAbsSampleIndex_{0};
    bool sampleIndexInitialized_{false};
    uint32_t lastPacketNumDataBlocks_{0}; // Track number of blocks in the previous packet
    bool lastPacketWasNoData_{false}; // Track if the *immediately preceding* processed packet was NO_DATA
    
    /**
     * @brief Extract SFC (Sample Frequency Code) from FDF field
     * 
     * @param fdf Format Dependent Field from CIP header
     * @return uint8_t Sample Frequency Code
     */
    static uint8_t getSFCFromFDF(uint8_t fdf) {
        // Basic FDF for AM824: lower 3 bits are SFC
        return fdf & 0x07;
    }
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/IsochPortChannelManager.hpp ===
#pragma once

#include <memory>
#include <functional>
#include <expected>
#include <atomic>
#include <mutex>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLib.h> // For NubRef
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>
#include "FWA/Error.h"
#include "Isoch/core/Types.hpp" // For DCLCommandPtr, IOVirtualRange

namespace FWA {
namespace Isoch {

/**
 * @brief Manages FireWire Isochronous Ports (Local & Remote) and the Isoch Channel.
 *
 * This class handles the creation, configuration, and lifecycle of the
 * FireWire components responsible for establishing the isochronous connection
 * (ports and channel). It manages interactions with the remote peer via
 * remote port callbacks and interacts with the RunLoop for dispatching.
 */
class IsochPortChannelManager {
public:
    /**
     * @brief Special value indicating any available isochronous channel.
     */
    static constexpr uint32_t kAnyAvailableIsochChannel = 0xFFFFFFFF;

    /**
     * @brief Construct a new IsochPortChannelManager instance.
     *
     * @param logger Logger for diagnostic information.
     * @param interface The IOFireWireLibNubRef for the device interface.
     * @param runLoop The RunLoop to use for callbacks.
     * @param isTalker True if this endpoint is the talker, false for listener.
     */
    explicit IsochPortChannelManager(
        std::shared_ptr<spdlog::logger> logger,
        IOFireWireLibNubRef interface, // Takes ownership (AddRef/Release)
        CFRunLoopRef runLoop,
        bool isTalker);

    /**
     * @brief Destructor - handles cleanup of ports, channel, pool, and dispatchers.
     */
    ~IsochPortChannelManager();

    // Prevent copying
    IsochPortChannelManager(const IsochPortChannelManager&) = delete;
    IsochPortChannelManager& operator=(const IsochPortChannelManager&) = delete;

    /**
     * @brief Initializes the manager: adds dispatchers to RunLoop, creates NuDCL Pool,
     *        and creates the Remote Port.
     *
     * @return std::expected<void, IOKitError> Success or error code.
     */
    std::expected<void, IOKitError> initialize();

    /**
     * @brief Creates the Local Port and Isoch Channel, connecting them based on role.
     * Requires `initialize()` to have been called successfully.
     *
     * @param program The DCL program handle (DCLCommand*) from IsochDCLManager::GetProgram.
     * @param bufferRange The memory range used by the DCL program.
     * @return std::expected<void, IOKitError> Success or error code.
     */
    std::expected<void, IOKitError> setupLocalPortAndChannel(
        DCLCommand* program,
        const IOVirtualRange& bufferRange);

    /**
     * @brief Configures the desired speed and channel for the connection.
     * This information is used when responding to remote port requests.
     * Must be called before the connection is established (e.g., before `start` on TransportManager).
     *
     * @param speed The desired FireWire speed.
     * @param channel The desired channel number (or kAnyAvailableIsochChannel).
     * @return std::expected<void, IOKitError> Success or error code.
     */
    std::expected<void, IOKitError> configure(IOFWSpeed speed, uint32_t channel);

    /**
     * @brief Gets the NuDCL Pool reference created during initialization.
     *
     * @return IOFireWireLibNuDCLPoolRef The NuDCL pool, or nullptr if not initialized.
     */
    IOFireWireLibNuDCLPoolRef getNuDCLPool() const;

    /**
     * @brief Gets the Local Isoch Port reference.
     *
     * @return IOFireWireLibLocalIsochPortRef The local port, or nullptr if not created.
     */
    IOFireWireLibLocalIsochPortRef getLocalPort() const;

    /**
     * @brief Gets the Isoch Channel reference.
     *
     * @return IOFireWireLibIsochChannelRef The isoch channel, or nullptr if not created.
     */
    IOFireWireLibIsochChannelRef getIsochChannel() const;

    /**
     * @brief Gets the FireWire Nub interface reference.
     *
     * @return IOFireWireLibNubRef The nub interface used by this manager, or nullptr if not available.
     */
    IOFireWireLibNubRef getNubInterface() const { return interface_; }

    /**
     * @brief Gets the currently active isochronous channel number (negotiated).
     *
     * @return std::expected<uint32_t, IOKitError> Active channel or error code.
     */
    std::expected<uint32_t, IOKitError> getActiveChannel() const;

    /**
     * @brief Gets the local node ID for this device.
     *
     * @return std::expected<uint16_t, IOKitError> The node ID or error code.
     */
    std::expected<uint16_t, IOKitError> getLocalNodeID() const;

    /**
     * @brief Resets the manager state, releasing ports, channel, pool,
     *        and removing dispatchers from the RunLoop.
     */
    void reset();

    // Optional: Add a finalize callback if external notification is needed
    // using PortFinalizeCallback = void(*)(void* refCon);
    // void setFinalizeCallback(PortFinalizeCallback callback, void* refCon);

private:
    // Internal setup helpers
    std::expected<void, IOKitError> setupDispatchers();
    std::expected<void, IOKitError> setupNuDCLPool();
    std::expected<void, IOKitError> createRemotePort();
    std::expected<void, IOKitError> createLocalPort(DCLCommand* program, const IOVirtualRange& bufferRange);
    std::expected<void, IOKitError> createIsochChannel();

    // Internal cleanup helper
    void cleanupDispatchers() noexcept;
    void cleanupResources() noexcept;

    // Static callback handlers for FireWire Port callbacks
    static IOReturn RemotePort_GetSupported_Helper(
        IOFireWireLibIsochPortRef interface, IOFWSpeed *outMaxSpeed, UInt64 *outChanSupported);
    static IOReturn RemotePort_AllocatePort_Helper(
        IOFireWireLibIsochPortRef interface, IOFWSpeed maxSpeed, UInt32 channel);
    static IOReturn RemotePort_ReleasePort_Helper(
        IOFireWireLibIsochPortRef interface);
    static IOReturn RemotePort_Start_Helper(
        IOFireWireLibIsochPortRef interface);
    static IOReturn RemotePort_Stop_Helper(
        IOFireWireLibIsochPortRef interface);
    static IOReturn PortFinalize_Helper(void* refcon); // RefCon is IsochPortChannelManager*

    // Instance methods called by the static helpers
    IOReturn handleRemotePortGetSupported(IOFWSpeed *outMaxSpeed, UInt64 *outChanSupported);
    IOReturn handleRemotePortAllocatePort(IOFWSpeed maxSpeed, UInt32 channel);
    IOReturn handleRemotePortReleasePort();
    IOReturn handleRemotePortStart();
    IOReturn handleRemotePortStop();
    void handlePortFinalize();

    // --- Member Variables ---
    std::shared_ptr<spdlog::logger> logger_;
    IOFireWireLibNubRef interface_{nullptr}; // Owning reference
    CFRunLoopRef runLoop_{nullptr};          // Non-owning reference

    IOFireWireLibNuDCLPoolRef nuDCLPool_{nullptr};
    IOFireWireLibRemoteIsochPortRef remotePort_{nullptr};
    IOFireWireLibLocalIsochPortRef localPort_{nullptr};
    IOFireWireLibIsochChannelRef isochChannel_{nullptr};

    // Configuration
    bool isTalker_{false};
    IOFWSpeed configuredSpeed_{kFWSpeed100MBit};
    uint32_t configuredChannel_{kAnyAvailableIsochChannel};
    uint32_t activeChannel_{kAnyAvailableIsochChannel}; // Negotiated channel

    // State
    bool initialized_{false};
    std::atomic<bool> running_{false}; // Controlled by remote start/stop
    bool finalized_{false};
    bool dispatchersAdded_{false};

    // Optional finalize callback forwarding
    // PortFinalizeCallback portFinalizeCallback_{nullptr};
    // void* portFinalizeRefCon_{nullptr};

    // Synchronization
    std::mutex stateMutex_; // Protects configuration and state during access/modification
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/core/TransmitterTypes.hpp ===
#pragma once

#include <cstdint>
#include <memory>
#include <functional> // For std::function if used later, though not for basic callbacks
#include <spdlog/logger.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h> // For IOFWSpeed

// Forward declare RingBuffer if needed, or include header
// Assumes RingBuffer lives in the raul namespace globally
namespace raul { class RingBuffer; }

namespace FWA {
namespace Isoch {

// --- Configuration ---

/**
 * @brief Configuration parameters for the AmdtpTransmitter.
 */
struct TransmitterConfig {
    std::shared_ptr<spdlog::logger> logger; ///< Shared pointer to the logger instance.

    // DCL Program & Buffer Structure (Mirroring Receiver for consistency)
    uint32_t numGroups{8};             ///< Number of buffer groups (segments) in the DCL ring.
    uint32_t packetsPerGroup{16};      ///< Number of FireWire packets per buffer group.
    uint32_t callbackGroupInterval{1}; ///< Trigger DCL completion callback every N groups (1 = every group).

    // Client Data Buffer (Area managed by IsochTransmitBufferManager for client interaction)
    uint32_t clientBufferSize{0};      ///< Size (in bytes) of the buffer area dedicated for client audio data.
                                       ///< Must be large enough for numGroups * packetsPerGroup * calculated_audio_payload_per_packet.

    // Audio Format & Rate
    double sampleRate{44100.0};        ///< Target audio sample rate in Hz.
    uint32_t numChannels{2};           ///< Number of audio channels (e.g., 2 for stereo).
                                       ///< Note: Currently assumes interleaved stereo float in provider.

    // FireWire Isochronous Parameters
    IOFWSpeed initialSpeed{kFWSpeed400MBit}; ///< Initial speed for channel allocation/negotiation.
    uint32_t initialChannel{0xFFFFFFFF};   ///< Initial channel (0xFFFFFFFF = any available).
    bool doIRMAllocations{true};       ///< Whether to use Isochronous Resource Manager for bandwidth/channel.
    uint32_t irmPacketPayloadSize{72}; ///< Maximum PAYLOAD size (CIPHdr + AudioData) in bytes for IRM bandwidth calculation.
                                       ///< Example: 8 bytes CIP Header + 64 bytes Audio Data = 72 bytes.
                                       ///< The Isochronous Header (4 bytes) is NOT included here.

    // Timing & Sync (Potentially add more later)
    uint32_t numStartupCycleMatchBits{0}; ///< For cycle-matching start (0 usually sufficient for transmitter).
};

// --- Messages & Callbacks ---

/**
 * @brief Enumeration of message types sent from the Transmitter to the client.
 */
enum class TransmitterMessage : uint32_t {
    StreamStarted = 0x2000,   ///< Isochronous stream transmission has successfully started.
    StreamStopped,            ///< Isochronous stream transmission has successfully stopped.
    BufferUnderrun,           ///< Packet provider ran out of client data; silence or NO_DATA sent. (param1=segment, param2=packet)
    OverrunError,             ///< DCL program overrun occurred (hardware couldn't keep up).
    OverrunRecoveryAttempt,   ///< Attempting automatic recovery from overrun.
    OverrunRecoveryFailed,    ///< Automatic recovery from overrun failed; stream stopped.
    AllocatePort,             ///< Remote port allocation occurred (param1=speed, param2=channel). (Info)
    ReleasePort,              ///< Remote port was released. (Info)
    TimestampAdjust,          ///< Internal timestamp adjustment occurred (param1=expected cycle, param2=actual cycle). (Debug/Info)
    Error                     ///< Generic or unrecoverable error occurred.
};

/**
 * @brief Callback function type for messages from the Transmitter.
 *
 * @param message The message code (from TransmitterMessage enum).
 * @param param1 First parameter (message-specific).
 * @param param2 Second parameter (message-specific).
 * @param refCon User-provided reference context pointer.
 */
using MessageCallback = void(*)(uint32_t message, uint32_t param1, uint32_t param2, void* refCon);

// --- Data Structures ---

/**
 * @brief Basic structure representing the 8-byte CIP Header.
 *        Ensures correct byte order access (assumes system is Little Endian).
 */
#pragma pack(push, 1) // Ensure tight packing
struct CIPHeader {
    // Quadlet 0
    uint8_t sid_byte;  // Source ID (Node ID) - 6 bits used
    uint8_t dbs;  // Data Block Size (in quadlets)
    uint8_t fn_qpc_sph_rsv; // FN (2), QPC (3), SPH (1), RSV (2) - Often 0 for AMDTP
    uint8_t dbc;  // Data Block Counter
    // Quadlet 1
    uint8_t fmt_eoh1; // FMT (6 bits), EOH1=1
    uint8_t fdf;      // Format Dependent Field (includes SFC)
    uint16_t syt;     // Synchronization Timestamp (Big Endian in memory!)

    // Helper to get/set fields assuming BE memory layout for packet buffer
    // Example: Set DBS
    // void setDBS(uint8_t val) { dbs = val; }
    // Example: Set DBC
    // void setDBC(uint8_t val) { dbc = val; }
    // Example: Set SYT (takes host order, writes big endian)
    // void setSYT(uint16_t host_syt) { syt = OSSwapHostToBigInt16(host_syt); }
    // Example: Get FDF
    // uint8_t getFDF() const { return fdf; }
};
#pragma pack(pop)
static_assert(sizeof(CIPHeader) == 8, "CIPHeader size must be 8 bytes");

/**
 * @brief Structure containing isoch header data for packet transmission
 */
#pragma pack(push, 1) // Ensure tight packing
struct IsochHeaderData {
    // IEEE-1394 Isochronous Packet Header (as used by FireWire)
    uint16_t data_length;  // Total data length (filled by hardware at transmit time)
    uint8_t tag_channel;   // Tag (upper 2 bits) and channel (lower 6 bits)
    uint8_t tcode_sy;      // Transaction code (upper 4 bits) and sync code (lower 4 bits)
};
#pragma pack(pop)
static_assert(sizeof(IsochHeaderData) == 4, "IsochHeaderData size must be 4 bytes");

/**
 * @brief Structure holding information about the packet currently being prepared for transmission.
 *        Passed from the AmdtpTransmitter to the CIPHeaderGenerator and IsochPacketProvider.
 */
struct TransmitPacketInfo {
    uint32_t segmentIndex;        ///< Index of the buffer group (segment) this packet belongs to.
    uint32_t packetIndexInGroup;  ///< Index of this packet within its group (0 to packetsPerGroup-1).
    uint32_t absolutePacketIndex; ///< Index of this packet since stream start (wraps).
    uint64_t hostTimestampNano;   ///< Estimated host time (nanoseconds) when this packet is expected to be sent.
    uint32_t firewireTimestamp;   ///< FireWire cycle time (seconds:cycles:offset) associated with this packet's DCL.

    // Add other relevant info if needed, e.g.:
    // uint64_t absoluteSampleFrameIndex; // Estimated sample frame index for the start of this packet
};

// --- Provider Interface Related ---
// This defines what the AmdtpTransmitter needs from the component that provides the audio data

/**
 * @brief Structure to hold prepared audio data and status from the provider.
 */
struct PreparedPacketData {
    const uint8_t* dataPtr = nullptr; ///< Pointer to the formatted audio data (e.g., AM824 interleaved).
                                      ///< NOTE: This might point into the provider's internal buffer or the target DCL buffer.
    size_t dataLength = 0;            ///< Length of the valid audio data in bytes.
    bool dataAvailable = false;       ///< True if data is available (not an underrun)
    bool generatedSilence = false;    ///< True if the provider had an underrun and generated silence instead.
};

// --- Constants ---
// Constants for header sizes
constexpr size_t kTransmitCIPHeaderSize = 8;        ///< Size of CIP header in bytes
constexpr size_t kTransmitIsochHeaderSize = 4;      ///< Size of IEEE1394 isoch header in bytes

} // namespace Isoch
} // namespace FWA


=== include/Isoch/IsoStreamHandler.hpp ===
#pragma once

#include <atomic>
#include <mutex>
#include <thread>
#include <chrono>
#include <memory>
#include <expected> // Include expected
#include "Isoch/interfaces/ITransmitPacketProvider.hpp" // Include interface

#include "FWA/CommandInterface.h"
#include "FWA/AudioDevice.h"
#include "FWA/Error.h"
#include <spdlog/spdlog.h>
#include "Isoch/core/AmdtpReceiver.hpp"
#include "Isoch/core/ReceiverFactory.hpp"
#include "Isoch/AudioDeviceStream.hpp"
#include <IOKit/firewire/IOFireWireLib.h>
#include "Isoch/utils/RingBuffer.hpp" // Include RingBuffer header

#ifdef __OBJC__
#import "FWA/XPC/XPCReceiverClient.hpp"
#else
class XPCReceiverClient; // Forward declaration when compiling as pure C++
#endif

namespace FWA {

/**
 * @brief Handles isochronous audio streaming for FireWire devices
 *
 * This class manages AMDTP (Audio & Music Data Transmission Protocol) streams
 * for FireWire audio devices, including packet processing, callbacks,
 * and properly configuring streams with RAII principles.
 */
class IsoStreamHandler {
public:
    /**
     * @brief Construct a new IsoStreamHandler
     *
     * @param device Shared pointer to the audio device to manage streams for
     * @param logger Logger for diagnostics
     * @param commandInterface Shared pointer to the command interface
     * @param interface FireWire device interface to use for stream creation
     */
    explicit IsoStreamHandler(std::shared_ptr<AudioDevice> device,
                              std::shared_ptr<spdlog::logger> logger,
                              std::shared_ptr<CommandInterface> commandInterface,
                              IOFireWireLibDeviceRef interface);

    /**
     * @brief Destroy the IsoStreamHandler and cleanup resources
     */
    ~IsoStreamHandler();

    /**
     * @brief Start all configured audio streams
     *
     * @return std::expected<void, IOKitError> Success or error
     */
    std::expected<void, IOKitError> start();

    /**
     * @brief Stop all active audio streams
     */
    void stop();

    /**
     * @brief Push audio data into the transmit stream.
     *
     * This method is intended to be called by the component responsible for
     * providing audio data (e.g., an XPC bridge).
     *
     * @param buffer Pointer to the audio data (e.g., interleaved float samples).
     * @param bufferSizeInBytes Size of the data in bytes.
     * @return True if the data was successfully pushed into the transmitter's buffer,
     *         false otherwise (e.g., stream not started, buffer full).
     */
    bool pushTransmitData(const void* buffer, size_t bufferSizeInBytes);

private:
    // Callback handlers with proper refcon
    static void handleDataPush(const uint8_t* pPayload, size_t payloadLength, void* refCon);
    static void handleMessage(uint32_t msg, uint32_t param1, uint32_t param2, void* refCon);
    static void handleNoData(uint32_t lastCycle, void* refCon);
    static void handleStructuredData(const Isoch::ReceivedCycleData& data, void* refCon);

    // Instance methods that static callbacks forward to
    void handleDataPushImpl(const uint8_t* pPayload, size_t payloadLength);
    void handleMessageImpl(uint32_t msg, uint32_t param1, uint32_t param2);
    void handleNoDataImpl(uint32_t lastCycle);
    void handleStructuredDataImpl(const Isoch::ReceivedCycleData& data);

    // Background processing
    void processData();
    void makeThreadRealtime(std::thread& th);

    // Ring Buffer Consumer Thread
    std::thread m_consumerThread;
    std::atomic<bool> m_consumerRunning{false};
    void consumerLoop(); // The function the consumer thread will run

    // Helper to get the ring buffer pointer safely
    raul::RingBuffer* getInputStreamRingBuffer();

    // Statistics tracking
    std::chrono::steady_clock::time_point m_lastTimestamp;
    std::chrono::steady_clock::time_point m_lastTransmitterTimestamp;
    uint32_t m_packetCounter = 0;
    uint32_t m_packetCounterNoData = 0;
    uint32_t m_transmitterPacketCounter = 0;
    UInt16 m_prevSYT = 0;
    UInt32 m_nodataPacketsSkipped = 0;

    // Core components
    std::shared_ptr<spdlog::logger> m_logger;
    std::shared_ptr<AudioDevice> m_audioDevice;
    std::mutex m_streamMutex;
    std::shared_ptr<CommandInterface> m_commandInterface;

    // Processing thread
    std::thread m_processingThread;
    std::atomic<bool> m_processingRunning{false};

    Isoch::ITransmitPacketProvider* getTransmitPacketProvider();

    // Streams (Input and Output)
    std::shared_ptr<AudioDeviceStream> m_inputStream;
    std::shared_ptr<AudioDeviceStream> m_outputStream; // Member for output stream

    // Direct stream implementations for low-level access
    std::shared_ptr<Isoch::AmdtpReceiver> m_directReceiver;

    // Device info
    UInt16 m_nodeId = 0;
    IOFWSpeed m_speed = kFWSpeed100MBit; // default to minimum speed

    // Interface
    IOFireWireLibDeviceRef m_interface = nullptr;

#ifdef __OBJC__
    XPCReceiverClient* m_xpcClient = nil; // XPC client for audio processing
#endif
};

} // namespace FWA


=== include/Isoch/utils/RingBuffer.hpp ===
// Copyright 2007-2012 David Robillard <d@drobilla.net>
// SPDX-License-Identifier: GPL-3.0-or-later
#ifndef RAUL_RINGBUFFER_HPP
#define RAUL_RINGBUFFER_HPP

#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <memory>
#include <spdlog/spdlog.h>

// Include ARM NEON headers
#ifdef __ARM_NEON
#include <arm_neon.h>
#endif

namespace raul {

/**
   A lock-free RingBuffer.
   Thread-safe with a single reader and single writer, and real-time safe
   on both ends.
   @ingroup raul
*/
class RingBuffer
{
public:
    /**
       Create a new RingBuffer.
       @param size Size in bytes (note this may be rounded up).
    */
    explicit RingBuffer(uint32_t size, std::shared_ptr<spdlog::logger> logger = nullptr)
        : _size(next_power_of_two(size))
        , _size_mask(_size - 1)
        , _buf(new char[_size])
        , _logger(logger)
    {
        if (_logger) {
            _logger->debug("[RingBuffer] Initialized with size: {} bytes", _size);
            _logger->debug("[RingBuffer] Size in samples: {}", _size / sizeof(int32_t));
        }
        assert(read_space() == 0);
        assert(write_space() == _size - 1);
    }

    RingBuffer(const RingBuffer&) = delete;
    RingBuffer& operator=(const RingBuffer&) = delete;
    RingBuffer(RingBuffer&&) = delete;
    RingBuffer& operator=(RingBuffer&&) = delete;
    ~RingBuffer() = default;

    /**
       Reset (empty) the RingBuffer.
       This method is NOT thread-safe, it may only be called when there are no
       readers or writers.
    */
    void reset()
    {
        _write_head = 0;
        _read_head = 0;
    }

    /// Return the number of bytes of space available for reading
    [[nodiscard]] uint32_t read_space() const
    {
        return read_space_internal(_read_head, _write_head);
    }

    /// Return the number of bytes of space available for writing
    [[nodiscard]] uint32_t write_space() const
    {
        return write_space_internal(_read_head, _write_head);
    }

    /// Return the capacity (i.e. total write space when empty)
    [[nodiscard]] uint32_t capacity() const { return _size - 1; }

    /// Read from the RingBuffer without advancing the read head
    uint32_t peek(uint32_t size, void* dst)
    {
        return peek_internal(_read_head, _write_head, size, dst);
    }

    /// Read from the RingBuffer and advance the read head
    uint32_t read(uint32_t size, void* dst)
    {
        const uint32_t r = _read_head;
        const uint32_t w = _write_head;
        if (peek_internal(r, w, size, dst)) {
            std::atomic_thread_fence(std::memory_order_acquire);
            _read_head = (r + size) & _size_mask;
            return size;
        }
        return 0;
    }

    /// Skip data in the RingBuffer (advance read head without reading)
    uint32_t skip(uint32_t size)
    {
        const uint32_t r = _read_head;
        const uint32_t w = _write_head;
        if (read_space_internal(r, w) < size) {
            return 0;
        }
        std::atomic_thread_fence(std::memory_order_acquire);
        _read_head = (r + size) & _size_mask;
        return size;
    }

    /// Write data to the RingBuffer
    uint32_t write(uint32_t size, const void* src)
    {
        const uint32_t r = _read_head;
        const uint32_t w = _write_head;
        if (write_space_internal(r, w) < size) {
            return 0;
        }
        
        if (w + size <= _size) {
            // Contiguous write
            neon_memcpy(&_buf[w], src, size);
            std::atomic_thread_fence(std::memory_order_release);
            _write_head = (w + size) & _size_mask;
        } else {
            // Split write across boundary
            const uint32_t this_size = _size - w;
            assert(this_size < size);
            assert(w + this_size <= _size);
            
            // Use optimized copy for both parts
            neon_memcpy(&_buf[w], src, this_size);
            neon_memcpy(&_buf[0], 
                       static_cast<const uint8_t*>(src) + this_size, 
                       size - this_size);
                       
            std::atomic_thread_fence(std::memory_order_release);
            _write_head = size - this_size;
        }
        
        // Prefetch next potential write location
        prefetch_next_write();
        
        return size;
    }

private:
    static uint32_t next_power_of_two(uint32_t size)
    {
        // http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
        size--;
        size |= size >> 1U;
        size |= size >> 2U;
        size |= size >> 4U;
        size |= size >> 8U;
        size |= size >> 16U;
        size++;
        return size;
    }

    [[nodiscard]] uint32_t write_space_internal(uint32_t r, uint32_t w) const
    {
        if (r == w) {
            return _size - 1;
        }
        if (r < w) {
            return ((r - w + _size) & _size_mask) - 1;
        }
        return (r - w) - 1;
    }

    [[nodiscard]] uint32_t read_space_internal(uint32_t r, uint32_t w) const
    {
        if (r < w) {
            return w - r;
        }
        return (w - r + _size) & _size_mask;
    }

    uint32_t peek_internal(uint32_t r, uint32_t w, uint32_t size, void* dst) const
    {
        if (read_space_internal(r, w) < size) {
            return 0;
        }
        
        if (r + size <= _size) {
            // Contiguous read - use optimized copy
            neon_memcpy(dst, &_buf[r], size);
        } else {
            // Split read across boundary
            const uint32_t first_size = _size - r;
            
            // Use optimized copy for both parts
            neon_memcpy(dst, &_buf[r], first_size);
            neon_memcpy(static_cast<uint8_t*>(dst) + first_size, 
                       &_buf[0], 
                       size - first_size);
        }
        
        return size;
    }
    
    // Prefetch the next likely write location
    void prefetch_next_write() const {
#ifdef __ARM_NEON
        const uint32_t next_write = (_write_head + 64) & _size_mask;
        __builtin_prefetch(&_buf[next_write], 1, 0);
#endif
    }
    
    // Prefetch the next likely read location
    void prefetch_next_read() const {
#ifdef __ARM_NEON
        const uint32_t next_read = (_read_head + 64) & _size_mask;
        __builtin_prefetch(&_buf[next_read], 0, 0);
#endif
    }

    // NEON-optimized memcpy
    static void neon_memcpy(void* dst, const void* src, size_t size) {
#ifdef __ARM_NEON
        uint8_t* d = static_cast<uint8_t*>(dst);
        const uint8_t* s = static_cast<const uint8_t*>(src);
        
        // For small copies, use standard memcpy
        if (size < 64) {
            std::memcpy(d, s, size);
            return;
        }
        
        // Process in chunks of 16 bytes (128 bits)
        size_t i = 0;
        size_t simd_end = size - (size % 16);
        
        for (; i < simd_end; i += 16) {
            uint8x16_t data = vld1q_u8(s + i);
            vst1q_u8(d + i, data);
        }
        
        // Handle remaining bytes
        for (; i < size; ++i) {
            d[i] = s[i];
        }
#else
        // Fall back to standard memcpy if NEON not available
        std::memcpy(dst, src, size);
#endif
    }

    std::atomic<uint32_t> _write_head{0}; ///< Write index into _buf
    std::atomic<uint32_t> _read_head{0};  ///< Read index into _buf
    uint32_t _size;                       ///< Size (capacity) in bytes
    uint32_t _size_mask;                  ///< Mask for fast modulo
    std::unique_ptr<char[]> _buf;         ///< Contents
    std::shared_ptr<spdlog::logger> _logger;
};

} // namespace raul

#endif // RAUL_RINGBUFFER_HPP


=== include/Isoch/utils/RunLoopHelper.hpp ===
#pragma once
#include <CoreFoundation/CoreFoundation.h>

// Function to log run loop creation with class name
void logRunLoopInfo(const char* className, const char* functionName, CFRunLoopRef runLoop);

// Function to log callback thread execution
void logCallbackThreadInfo(const char* className, const char* callbackName, void* refcon);



=== include/Isoch/AudioDeviceStream.hpp ===
#pragma once

#include <cstdint>
#include <string>
#include <memory>
#include <expected>
#include <functional>
#include <atomic>
#include <variant>
#include <thread>
#include <IOKit/firewire/IOFireWireLib.h>
#include <spdlog/spdlog.h>

#include "FWA/Error.h"
#include "FWA/AudioDevice.h"
#include "Isoch/core/AmdtpReceiver.hpp"
#include "Isoch/core/AmdtpTransmitter.hpp" // Include the transmitter
#include "Isoch/core/ReceiverFactory.hpp"
#include "Isoch/core/ReceiverTypes.hpp"
#include "Isoch/utils/RingBuffer.hpp" // Include RingBuffer header
#include "Isoch/interfaces/ITransmitPacketProvider.hpp" // Include interface

namespace FWA {

/**
 * @brief Enumeration of stream types supported by AudioDeviceStream
 */
enum class StreamType {
    AmdtpReceiver,           ///< AMDTP receiver stream for audio input
    AmdtpTransmitter,        ///< AMDTP transmitter stream for audio output
    UniversalReceiver,       ///< Legacy universal receiver type
    UniversalTransmitter     ///< Legacy universal transmitter type
};

/**
 * @brief AudioDeviceStream encapsulates an audio stream connected to a FireWire device
 *
 * This class provides a modern C++23 implementation for managing audio streams
 * over FireWire, using AMDTP (Audio & Music Data Transmission Protocol). It replaces
 * the legacy AVCDeviceStream structure with a robust, type-safe, and efficient design.
 */
class AudioDeviceStream : public std::enable_shared_from_this<AudioDeviceStream> {
public:
    /**
     * @brief Create an AudioDeviceStream as a factory method
     *
     * @param audioDevice Shared pointer to the parent AudioDevice
     * @param streamType Type of stream to create
     * @param devicePlugNumber The device plug number to connect to
     * @param logger Logger for diagnostics
     * @param dataPushCallback Callback for received data packets (for receiver streams)
     * @param dataPushRefCon Reference context for data push callback
     * @param messageCallback Callback for stream events
     * @param messageRefCon Reference context for message callback
     * @param cyclesPerSegment Number of cycles per segment for stream buffer
     * @param numSegments Number of segments for stream buffer
     * @param bufferSize Size of buffer in bytes
     * @param speed Initial speed setting
     * @param interface FireWire device interface
     * @return std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> Shared pointer to created stream or error
     */
    static std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> create(
                                                                                std::shared_ptr<AudioDevice> audioDevice,
                                                                                StreamType streamType,
                                                                                uint8_t devicePlugNumber,
                                                                                std::shared_ptr<spdlog::logger> logger,
                                                                                Isoch::PacketCallback dataPushCallback = nullptr,
                                                                                void* dataPushRefCon = nullptr,
                                                                                Isoch::MessageCallback messageCallback = nullptr,
                                                                                void* messageRefCon = nullptr,
                                                                                unsigned int cyclesPerSegment = 8,
                                                                                unsigned int numSegments = 4,
                                                                                unsigned int bufferSize = 512,
                                                                                IOFWSpeed speed = kFWSpeed100MBit,
                                                                                IOFireWireLibDeviceRef interface = nullptr);
    
    /**
     * @brief Create a receiver stream for a device output plug
     *
     * @param audioDevice Parent audio device
     * @param devicePlugNumber Device output plug number
     * @param dataPushCallback Callback for received data
     * @param dataPushRefCon Context for data callback
     * @param messageCallback Callback for stream events
     * @param messageRefCon Context for message callback
     * @param logger Logger for diagnostics
     * @param cyclesPerSegment Number of FireWire cycles per segment
     * @param numSegments Number of segments in the cycle buffer
     * @param cycleBufferSize Size of cycle buffer in bytes
     * @param interface FireWire device interface
     * @return std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> Created stream or error
     */
    static std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> createReceiverForDevicePlug(
                                                                                                     std::shared_ptr<AudioDevice> audioDevice,
                                                                                                     uint8_t devicePlugNumber,
                                                                                                     Isoch::PacketCallback dataPushCallback,
                                                                                                     void* dataPushRefCon,
                                                                                                     Isoch::MessageCallback messageCallback,
                                                                                                     void* messageRefCon,
                                                                                                     std::shared_ptr<spdlog::logger> logger,
                                                                                                     unsigned int cyclesPerSegment = 8,
                                                                                                     unsigned int numSegments = 4,
                                                                                                     unsigned int cycleBufferSize = 512,
                                                                                                     IOFireWireLibDeviceRef interface = nullptr);
    
    /**
     * @brief Create a transmitter stream for a device input plug
     *
     * @param audioDevice Parent audio device
     * @param devicePlugNumber Device input plug number
     * @param dataPullCallback Callback to provide data for transmission
     * @param dataPullRefCon Context for data callback
     * @param messageCallback Callback for stream events
     * @param messageRefCon Context for message callback
     * @param logger Logger for diagnostics
     * @param cyclesPerSegment Number of FireWire cycles per segment
     * @param numSegments Number of segments in the cycle buffer
     * @param transmitBufferSize Size of transmission buffer in bytes
     * @param interface FireWire device interface
     * @return std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> Created stream or error
     */
    static std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> createTransmitterForDevicePlug(
                                                                                                        std::shared_ptr<AudioDevice> audioDevice,
                                                                                                        uint8_t devicePlugNumber,
                                                                                                        Isoch::PacketCallback dataPullCallback,
                                                                                                        void* dataPullRefCon,
                                                                                                        Isoch::MessageCallback messageCallback,
                                                                                                        void* messageRefCon,
                                                                                                        std::shared_ptr<spdlog::logger> logger,
                                                                                                        unsigned int cyclesPerSegment = 8,
                                                                                                        unsigned int numSegments = 4,
                                                                                                        unsigned int transmitBufferSize = 512,
                                                                                                        IOFireWireLibDeviceRef interface = nullptr);
    
    /**
     * @brief Destructor handles proper cleanup of resources
     */
    ~AudioDeviceStream();
    
    // Prevent copying
    AudioDeviceStream(const AudioDeviceStream&) = delete;
    AudioDeviceStream& operator=(const AudioDeviceStream&) = delete;
    
    // Allow moving
    AudioDeviceStream(AudioDeviceStream&&) noexcept = delete;
    AudioDeviceStream& operator=(AudioDeviceStream&&) noexcept = delete;

    Isoch::ITransmitPacketProvider* getTransmitPacketProvider() const;
    
    /**
     * @brief Start the audio stream
     * @return Success or error status
     */
    std::expected<void, IOKitError> start();
    
    /**
     * @brief Stop the audio stream
     * @return Success or error status
     */
    std::expected<void, IOKitError> stop();
    
    /**
     * @brief Set the isochronous channel for the stream
     * @param channel Channel number
     * @return Success or error status
     */
    std::expected<void, IOKitError> setIsochChannel(uint32_t channel);
    
    /**
     * @brief Set the isochronous speed for the stream
     * @param speed Speed setting
     * @return Success or error status
     */
    std::expected<void, IOKitError> setIsochSpeed(IOFWSpeed speed);
    
    /**
     * @brief Get the current isochronous channel
     * @return Current channel number
     */
    uint32_t getIsochChannel() const { return m_isochChannel; }
    
    /**
     * @brief Get the current isochronous speed
     * @return Current speed setting
     */
    IOFWSpeed getIsochSpeed() const { return m_isochSpeed; }
    
    /**
     * @brief Set message callback for stream events
     * @param callback Function to call for stream events
     * @param refCon Context pointer for callback
     */
    void setMessageCallback(Isoch::MessageCallback callback, void* refCon = nullptr);
    
    /**
     * @brief Set packet callback for received data
     * @param callback Function to call for received packets
     * @param refCon Context pointer for callback
     */
    void setPacketCallback(Isoch::PacketCallback callback, void* refCon = nullptr);
    
    /**
     * @brief Set packet pull callback for transmitter data
     * @param callback Function to call to get data for transmission
     * @param refCon Context pointer for callback
     */
    void setPacketPullCallback(Isoch::PacketCallback callback, void* refCon = nullptr);
    
    /**
     * @brief Get the type of this stream
     * @return The stream type
     */
    StreamType getStreamType() const { return m_streamType; }
    
    /**
     * @brief Get the device plug number
     * @return The device plug number
     */
    uint8_t getDevicePlugNumber() const { return m_devicePlugNumber; }
    
    /**
     * @brief Check if the stream is active
     * @return True if the stream is active
     */
    bool isActive() const { return m_isActive; }
    
    /**
     * @brief Check if the plug is connected
     * @return True if the plug is connected
     */
    bool isPlugConnected() const { return m_isPlugConnected; }
    
    /**
     * @brief Get the associated RunLoop for this stream
     * @return CFRunLoopRef for this stream's callbacks
     */
    CFRunLoopRef getRunLoop() const { return m_runLoop; }

    /**
     * @brief Get the underlying Ring Buffer for receiver streams.
     * @return Pointer to the raul::RingBuffer, or nullptr if not a receiver or not initialized.
     */
    raul::RingBuffer* getReceiverRingBuffer() const; // Declaration added
    
    /**
     * @brief Push audio data to the transmitter for sending
     * @param buffer Pointer to the audio data buffer
     * @param bufferSizeInBytes Size of the audio data buffer in bytes
     * @return True if the data was successfully pushed, false otherwise
     */
    bool pushTransmitData(const void* buffer, size_t bufferSizeInBytes);
    
private:
    // Private constructor, use create() factory method instead
    AudioDeviceStream(
                      std::shared_ptr<AudioDevice> audioDevice,
                      StreamType streamType,
                      uint8_t devicePlugNumber,
                      std::shared_ptr<spdlog::logger> logger,
                      Isoch::PacketCallback dataPushCallback,
                      void* dataPushRefCon,
                      Isoch::MessageCallback messageCallback,
                      void* messageRefCon,
                      unsigned int cyclesPerSegment,
                      unsigned int numSegments,
                      unsigned int bufferSize,
                      IOFWSpeed speed = kFWSpeed100MBit,
                      IOFireWireLibDeviceRef interface = nullptr);
    
    // Core components
    std::shared_ptr<AudioDevice> m_audioDevice;
    std::shared_ptr<spdlog::logger> m_logger;
    IOFireWireLibDeviceRef m_interface;
    
    // Stream configuration
    StreamType m_streamType;
    uint8_t m_devicePlugNumber;
    unsigned int m_cyclesPerSegment;
    unsigned int m_numSegments;
    unsigned int m_bufferSize;
    
    // Isoch settings
    uint32_t m_isochChannel = 0xFFFFFFFF; // Any available channel
    IOFWSpeed m_isochSpeed = kFWSpeed100MBit;
    
    // State tracking
    std::atomic<bool> m_isActive{false};
    std::atomic<bool> m_isPlugConnected{false};
    
    // RunLoop management
    CFRunLoopRef m_runLoop = nullptr;
    std::thread m_runLoopThread;
    std::atomic<bool> m_runLoopActive{false};
    
    // Callback support with RefCons
    Isoch::PacketCallback m_packetCallback = nullptr;
    void* m_packetCallbackRefCon = nullptr;
    
    Isoch::PacketCallback m_packetPullCallback = nullptr;
    void* m_packetPullCallbackRefCon = nullptr;
    
    Isoch::MessageCallback m_messageCallback = nullptr;
    void* m_messageCallbackRefCon = nullptr;
    
    // Stream implementation - using std::variant for type-safe polymorphism
    using StreamVariant = std::variant<
        std::shared_ptr<Isoch::AmdtpReceiver>,
        std::shared_ptr<Isoch::AmdtpTransmitter> // Add AmdtpTransmitter to the variant
    >;
    
    StreamVariant m_streamImpl;
    
    // Methods for handling plug connections
    std::expected<void, IOKitError> connectPlug();
    std::expected<void, IOKitError> disconnectPlug();
    
    // Helper method to initialize and start the RunLoop thread
    std::expected<void, IOKitError> initializeRunLoop();
    
    // RunLoop thread function
    void runLoopThreadFunc();
    
    // Helper method to make the RunLoop thread time-constrained (real-time)
    void makeRunLoopThreadRealTime();
    
    // Internal callback methods with proper refcon handling
    static void handlePacketReceived(const uint8_t* data, size_t length, void* refCon);
    static void handleMessageReceived(uint32_t message, uint32_t param1, uint32_t param2, void* refCon);
    
    // New callback methods for processed data
    static void handleProcessedDataStatic(const std::vector<Isoch::ProcessedSample>& samples, 
                                         const Isoch::PacketTimingInfo& timing, 
                                         void* refCon);
    void handleProcessedDataImpl(const std::vector<Isoch::ProcessedSample>& samples,
                               const Isoch::PacketTimingInfo& timing);
    
    // Helper method to set up receiver callbacks with proper refcon handling
    void setupReceiverCallbacks(std::shared_ptr<Isoch::AmdtpReceiver> receiver);
    
    // Helper method to convert IOKit return codes to our error type
    static std::expected<void, IOKitError> checkIOReturn(IOReturn result);
};

} // namespace FWA


=== include/Isoch/interfaces/TransmitterInterfaces.hpp ===
#pragma once
#include <memory>
#include <functional>
#include <expected>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include "FWA/Error.h"
#include "Isoch/core/Types.hpp"

namespace FWA {
namespace Isoch {

// Forward declarations
class AmdtpTransmitter;
struct TransmitterConfig;

// Interface for packet management
class ITransmitPacketManager {
public:
    virtual ~ITransmitPacketManager() = default;
    virtual std::expected<void, IOKitError> processPacket(
        uint32_t segment,
        uint32_t cycle,
        uint8_t* data,
        size_t length) = 0;
    virtual std::expected<void, IOKitError> handleOverrun() = 0;
    virtual void setPacketCallback(std::function<void(uint8_t* data, size_t size)> callback) = 0;
};

// Interface for buffer management
class ITransmitBufferManager {
public:
    virtual ~ITransmitBufferManager() = default;
    virtual std::expected<void, IOKitError> setupBuffers(
        uint32_t totalCycles,
        uint32_t cycleBufferSize) = 0;
    virtual std::expected<uint8_t*, IOKitError> getCycleBuffer(
        uint32_t segment,
        uint32_t cycle) = 0;
    virtual std::expected<uint8_t*, IOKitError> getOverrunBuffer() = 0;
    virtual size_t getTotalBufferSize() const noexcept = 0;
};

// Interface for DCL management
class ITransmitDCLManager {
public:
    virtual ~ITransmitDCLManager() = default;
    virtual std::expected<void, IOKitError> createProgram(
        uint32_t cyclesPerSegment,
        uint32_t numSegments,
        uint32_t cycleBufferSize) = 0;
    virtual std::expected<void, IOKitError> handleSegmentComplete(uint32_t segment) = 0;
    virtual DCLCommandPtr getProgram() const = 0;
};

// Component factory interface
class ITransmitterComponentFactory {
public:
    virtual ~ITransmitterComponentFactory() = default;
    
    virtual std::shared_ptr<ITransmitBufferManager> createBufferManager(
        const TransmitterConfig& config) = 0;
        
    virtual std::shared_ptr<ITransmitPacketManager> createPacketManager(
        const TransmitterConfig& config,
        std::weak_ptr<AmdtpTransmitter> transmitter) = 0;
        
    virtual std::shared_ptr<ITransmitDCLManager> createDCLManager(
        const TransmitterConfig& config,
        std::weak_ptr<AmdtpTransmitter> transmitter) = 0;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/interfaces/ITransmitBufferManager.hpp ===
#pragma once

#include <memory>
#include <expected>
#include "Isoch/core/TransmitterTypes.hpp"
#include "FWA/Error.h"
#include <IOKit/firewire/IOFireWireLibIsoch.h> // For IOVirtualRange

namespace FWA {
namespace Isoch {

class ITransmitBufferManager {
public:
    virtual ~ITransmitBufferManager() = default;

    virtual std::expected<void, IOKitError> setupBuffers(const TransmitterConfig& config) = 0;
    virtual void cleanup() noexcept = 0;

    // Getters for pre-allocated header/timestamp areas
    virtual std::expected<uint8_t*, IOKitError> getPacketIsochHeaderPtr(uint32_t groupIndex, uint32_t packetIndexInGroup) const = 0;
    virtual std::expected<uint8_t*, IOKitError> getPacketCIPHeaderPtr(uint32_t groupIndex, uint32_t packetIndexInGroup) const = 0;
    virtual std::expected<uint32_t*, IOKitError> getGroupTimestampPtr(uint32_t groupIndex) const = 0;

    // Getters for the client audio data area
    virtual uint8_t* getClientAudioBufferPtr() const = 0;
    virtual size_t getClientAudioBufferSize() const = 0;
    virtual size_t getAudioPayloadSizePerPacket() const = 0; // Calculated size based on config

    // Get overall range for port creation
    virtual const IOVirtualRange& getBufferRange() const = 0;
    virtual size_t getTotalBufferSize() const = 0;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/interfaces/ITransmitDCLManager.hpp ===
#pragma once

#include <memory>
#include <expected>
#include "Isoch/core/TransmitterTypes.hpp"
#include "FWA/Error.h"
#include <IOKit/firewire/IOFireWireLibIsoch.h>

namespace FWA {
namespace Isoch {

// Forward declaration for ITransmitBufferManager
class ITransmitBufferManager;

// Callback function for DCL completion events (Transmitter specific)
using TransmitDCLCompleteCallback = void(*)(uint32_t completedGroupIndex, void* refCon);
using TransmitDCLOverrunCallback = void(*)(void* refCon);

class ITransmitDCLManager {
public:
    virtual ~ITransmitDCLManager() = default;

    virtual std::expected<DCLCommand*, IOKitError> createDCLProgram(
        const TransmitterConfig& config, // Pass config for packet structure info
        IOFireWireLibNuDCLPoolRef nuDCLPool,
        const ITransmitBufferManager& bufferManager) = 0;

    virtual std::expected<void, IOKitError> fixupDCLJumpTargets(
        IOFireWireLibLocalIsochPortRef localPort) = 0;

    virtual void setDCLCompleteCallback(TransmitDCLCompleteCallback callback, void* refCon) = 0;
    virtual void setDCLOverrunCallback(TransmitDCLOverrunCallback callback, void* refCon) = 0;

    // Method to update a specific DCL command before it's sent
    virtual std::expected<void, IOKitError> updateDCLPacket(
        uint32_t groupIndex,
        uint32_t packetIndexInGroup,
        const IOVirtualRange ranges[], // Array of ranges (CIP Header, Audio Data)
        uint32_t numRanges,           // Number of ranges to set (1 for NO_DATA, 2 for DATA)
        const IsochHeaderData* isochHeaderTemplate // Pointer to the prepared Isoch header
    ) = 0;

    // Method to notify the hardware about updated DCLs in a segment
    virtual std::expected<void, IOKitError> notifySegmentUpdate(
         IOFireWireLibLocalIsochPortRef localPort,
         uint32_t groupIndexToNotify) = 0;


    virtual DCLCommand* getProgramHandle() const = 0; // Get the handle needed by Local Port
    virtual void reset() = 0;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/interfaces/ITransmitPacketProvider.hpp ===
#pragma once

#include <memory>
#include <expected>
#include "Isoch/core/TransmitterTypes.hpp"
#include "FWA/Error.h"

namespace FWA {
namespace Isoch {

class ITransmitPacketProvider {
public:
    virtual ~ITransmitPacketProvider() = default;

    // Method called by client (e.g., XPC bridge) to push audio data INTO the provider
    virtual bool pushAudioData(const void* buffer, size_t bufferSizeInBytes) = 0;

    // Method called by AmdtpTransmitter to get data FOR a packet
    // It should read from its internal buffer (e.g., ring buffer) and write
    // formatted audio data directly into the provided targetBuffer.
    virtual PreparedPacketData fillPacketData(
        uint8_t* targetBuffer,          // Pointer to the DCL's client data area slot
        size_t targetBufferSize,        // Expected size based on config (e.g., 64 bytes)
        const TransmitPacketInfo& info  // Context about the packet being prepared
        ) = 0;

    // Optional: Check if provider has enough data buffered for smooth streaming
    virtual bool isReadyForStreaming() const = 0;

    // Optional: Reset internal buffer state
    virtual void reset() = 0;
};

} // namespace Isoch
} // namespace FWA


