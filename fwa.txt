=== src/FWA/Helpers.cpp ===
// src/Helpers.cpp
#include "FWA/Helpers.h"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <memory>

namespace FWA {

    // Helper function: Convert CFString to std::string
    std::string Helpers::cfStringToString(CFStringRef cfString) {
        if (cfString == nullptr) {
            return "";  // Handle null strings gracefully
        }
        std::unique_ptr<char[]> buffer(new char[CFStringGetLength(cfString) * 4 + 1]); // +1 for null terminator, *4 for utf-8
        if (CFStringGetCString(cfString, buffer.get(), CFStringGetLength(cfString) * 4 + 1, kCFStringEncodingUTF8)) {
            return std::string(buffer.get());
        } else {
            return ""; // Handle error. CFStringGetCString failed, return empty or error message.
        }
    }

    void Helpers::printCFDictionary(CFDictionaryRef dict, int indent) {
        if (!dict) {
            std::cout << "(null CFDictionary)" << std::endl;
            return;
        }

        CFIndex count = CFDictionaryGetCount(dict);
        std::cout << "CFDictionary with " << std::dec << count << " entries:" << std::endl;

        if (count == 0) {
            return; // Nothing more to do for an empty dictionary.
        }

        CFTypeRef* keys = new CFTypeRef[count];
        CFTypeRef* values = new CFTypeRef[count];
        CFDictionaryGetKeysAndValues(dict, keys, values);

        std::string indentStr(indent, ' ');

        for (CFIndex i = 0; i < count; ++i) {
            CFStringRef key = (CFStringRef)keys[i];
            CFTypeRef value = values[i];
            std::string keyStr = cfStringToString(key);
            CFTypeID typeID = CFGetTypeID(value);

            std::cout << indentStr;

            if (typeID == CFStringGetTypeID()) {
                std::string valueStr = cfStringToString((CFStringRef)value);
                std::cout << keyStr << ": " << valueStr << " (CFString)" << std::endl;
            } else if (typeID == CFNumberGetTypeID()) {
                CFNumberRef num = (CFNumberRef)value;
                if (CFNumberIsFloatType(num)) {
                    double doubleVal;
                    if (CFNumberGetValue(num, kCFNumberDoubleType, &doubleVal)) {
                        std::cout << keyStr << ": " << doubleVal << " (CFNumber - Double)" << std::endl;
                    } else {
                        std::cout << keyStr << ": (CFNumber - Could not get double value)" << std::endl;
                    }
                } else {
                    long long longVal;
                    if (CFNumberGetValue(num, kCFNumberSInt64Type, &longVal)) {
                        std::cout << keyStr << ": " << longVal << " (0x" << std::hex << longVal << ") (CFNumber - Integer)" << std::endl;
                    } else {
                        std::cout << keyStr << ": (CFNumber - Could not get integer value)" << std::endl;
                    }
                }
            } else if (typeID == CFDataGetTypeID()) {
                CFDataRef data = (CFDataRef)value;
                const UInt8* bytes = CFDataGetBytePtr(data);
                CFIndex dataLength = CFDataGetLength(data);
                std::ostringstream hexStream;
                hexStream << std::hex << std::setfill('0');
                for (CFIndex j = 0; j < dataLength; ++j) {
                    hexStream << std::setw(2) << static_cast<int>(bytes[j]) << " ";
                }
                std::cout << keyStr << ": " << hexStream.str() << "(CFData)" << std::endl;
            } else if (typeID == CFDictionaryGetTypeID()) {
                std::cout << keyStr << ": (nested CFDictionary)" << std::endl;
                printCFDictionary((CFDictionaryRef)value, indent + 4); // Recursive call for nested dictionary
            } else if (typeID == CFArrayGetTypeID()) {
                std::cout << keyStr << ": (CFArray)" << std::endl;
                CFArrayRef array = (CFArrayRef)value;
                CFIndex arrayCount = CFArrayGetCount(array);
                for (CFIndex j = 0; j < arrayCount; j++) {
                    CFTypeRef arrayValue = CFArrayGetValueAtIndex(array, j);
                    std::cout << indentStr << "  [" << j << "]: ";
                    if (CFGetTypeID(arrayValue) == CFDictionaryGetTypeID()) {
                        printCFDictionary((CFDictionaryRef)arrayValue, indent + 4); // Increase indent for nested array elements
                    }
                }
            } else {
                std::cout << keyStr << ": (Unknown CFType - ID " << typeID << ")" << std::endl;
            }
        }

        delete[] keys;
        delete[] values;
    }

    std::string Helpers::formatHexBytes(const std::vector<uint8_t>& bytes) {
        std::ostringstream oss;
        oss << std::hex << std::uppercase << std::setfill('0');
        for (const auto& byte : bytes) {
            oss << "0x" << std::setw(2) << static_cast<int>(byte) << " ";
        }
        return oss.str();
    }

} // namespace FWA


=== src/FWA/DeviceController.cpp ===
// src/FWA/DeviceController.cpp

#include "FWA/DeviceController.h"
#include "FWA/Error.h"
#include <spdlog/spdlog.h>
#include <iostream>
#include <algorithm>

namespace FWA {

DeviceController::DeviceController(std::unique_ptr<IFireWireDeviceDiscovery> discovery) :
    discovery_(std::move(discovery)) {
}

DeviceController::~DeviceController() {
    stop(); // Ensure proper cleanup when the DeviceController is destroyed.
}
// receives callback
std::expected<void, IOKitError> DeviceController::start(DeviceNotificationCallback callback) {
    spdlog::info("DeviceController::start() called");
    if (isRunning_) {
        return std::unexpected(static_cast<IOKitError>(kIOReturnExclusiveAccess));
    }

    // Store the provided callback.  NO LONGER create a lambda here.
    notificationCallback_ = callback;

    // Start device discovery.  This sets up IOKit notifications.
    // Pass the stored callback directly to startDiscovery.
    auto result = discovery_->startDiscovery(notificationCallback_);
    if (!result) {
        spdlog::error("Failed to start discovery: 0x{:x}", static_cast<int>(result.error()));
        return std::unexpected(result.error());
    }
    
    runLoopRef_ = CFRunLoopGetCurrent();
    
    isRunning_ = true; // Set isRunning_ *after* successful startDiscovery.
    return {}; // Return success. No need start any thread!

    // NO THREAD CREATION HERE.  Let IOKit handle notifications.
}

std::expected<void, IOKitError> DeviceController::stop() {
    if (!isRunning_) {
        return {}; // Already stopped/never started
    }

    isRunning_ = false; // Signal that we're stopping.

    auto result = discovery_->stopDiscovery();
    if (!result) {
        spdlog::error("Failed to stop discovery: 0x{:x}", static_cast<int>(result.error()));
        return std::unexpected(result.error());
    }

    {
        std::lock_guard<std::mutex> lock(devicesMutex_);
        devices_.clear();  // Clear the device list.
    }
     // Clear Callback
    notificationCallback_ = nullptr;
    return {};
}


void DeviceController::addDevice(std::shared_ptr<AudioDevice> device) {
    std::lock_guard<std::mutex> lock(devicesMutex_);
    auto it = std::find_if(devices_.begin(), devices_.end(),
                           [&](const auto& d) { return d->getGuid() == device->getGuid(); });
    if (it == devices_.end())
    {
        devices_.push_back(device);
        spdlog::info("Device added: {}", device->getGuid());
    } else {
        spdlog::info("Device already exists, updating: {}", device->getGuid());
          // *it = device; // We don't need to update existing device! We already setup Interest Notification!
    }
}

void DeviceController::removeDevice(std::uint64_t guid)
{
    std::lock_guard<std::mutex> lock(devicesMutex_);
	// No need to call close() here! It's handled by deviceInterestCallback.
    devices_.erase(std::remove_if(devices_.begin(), devices_.end(),
                                     [&](const auto& device) { return device->getGuid() == guid; }),
                       devices_.end());
    spdlog::info("Device removed: {}", guid);
}

std::expected<std::shared_ptr<AudioDevice>, IOKitError> DeviceController::getDeviceByGuid(std::uint64_t guid)
{
    std::lock_guard<std::mutex> lock(devicesMutex_);
    auto it = std::find_if(devices_.begin(), devices_.end(),
                           [&](const auto& device) { return device->getGuid() == guid; });

    if (it != devices_.end()) {
        return *it;
    } else {
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotFound));
    }
}
} // namespace FWA



=== src/FWA/CommandInterface.cpp ===
#include "FWA/CommandInterface.h"
#include "FWA/AudioDevice.h" 
#include "FWA/Error.h"
#include <spdlog/spdlog.h>
#include <sstream>
#include <iomanip>
#include <IOKit/IOMessage.h>

namespace FWA {

CommandInterface::CommandInterface(std::shared_ptr<AudioDevice> pAudioDevice)
    : pAudioDevice_(pAudioDevice)
    , avcUnit_(pAudioDevice->getAVCDevice())
    , avcInterface_(nullptr)
    , interestNotification_(0)
    , notificationCallback_(nullptr)
    , refCon_(nullptr)
{
}

CommandInterface::~CommandInterface()
{
    auto result = deactivate();
    if (!result) {
        spdlog::error("~CommandInterface, deactivate failed");
    }
}

CommandInterface::CommandInterface(CommandInterface&& other) noexcept
    : pAudioDevice_(std::move(other.pAudioDevice_))
    , avcUnit_(other.avcUnit_)
    , avcInterface_(other.avcInterface_)
    , interestNotification_(other.interestNotification_)
    , notificationCallback_(other.notificationCallback_)
    , refCon_(other.refCon_)
{
    other.pAudioDevice_ = nullptr;
    other.avcUnit_ = 0;
    other.avcInterface_ = nullptr;
    other.interestNotification_ = 0;
    other.notificationCallback_ = nullptr;
    other.refCon_ = nullptr;
}

CommandInterface& CommandInterface::operator=(CommandInterface&& other) noexcept
{
    if (this != &other) {
        deactivate();

        pAudioDevice_ = std::move(other.pAudioDevice_);
        avcUnit_ = other.avcUnit_;
        avcInterface_ = other.avcInterface_;
        interestNotification_ = other.interestNotification_;
        notificationCallback_ = other.notificationCallback_;
        refCon_ = other.refCon_;

        other.pAudioDevice_ = nullptr;
        other.avcUnit_ = 0;
        other.avcInterface_ = nullptr;
        other.interestNotification_ = 0;
        other.notificationCallback_ = nullptr;
        other.refCon_ = nullptr;
    }
    return *this;
}

std::expected<void, IOKitError> CommandInterface::activate() {
    if (avcInterface_ != nullptr) {
        return std::unexpected(static_cast<IOKitError>(kIOReturnStillOpen)); // Already active.
    }

    auto result = createAVCUnitInterface();
    if (!result) {
        return std::unexpected(result.error());
    }
    // Register the notification callback.
    return setNotificationCallback(notificationCallback_, refCon_);
}

std::expected<void, IOKitError> CommandInterface::deactivate()
{
    clearNotificationCallback();
    if (!avcInterface_) {
        return {}; // Already deactivated.
    }
    return releaseAVCUnitInterface();
}

std::expected<void, IOKitError> CommandInterface::createAVCUnitInterface()
{
    IOCFPlugInInterface **plugInInterface = nullptr;
    SInt32 score = 0;


    IOReturn result = IOCreatePlugInInterfaceForService(avcUnit_,
                                                        kIOFireWireAVCLibUnitTypeID,
                                                        kIOCFPlugInInterfaceID,
                                                        &plugInInterface,
                                                        &score);

    if (result != kIOReturnSuccess) {
        spdlog::error("Failed to create the CFPlugin interface: 0x{:x}", result);
        return std::unexpected(static_cast<IOKitError>(result));
    }

    HRESULT comResult = (*plugInInterface)->QueryInterface(plugInInterface,
                               CFUUIDGetUUIDBytes(kIOFireWireAVCLibUnitInterfaceID_v2),
                               (void**)&avcInterface_);

    (*plugInInterface)->Release(plugInInterface);

    if (comResult != S_OK || avcInterface_ == nullptr) {
        spdlog::error("Failed to get IOFireWireAVCLibUnitInterface: 0x{:x}", static_cast<int>(comResult));
        return std::unexpected(static_cast<IOKitError>(comResult));
    }

    return {};
}

std::expected<void, IOKitError> CommandInterface::releaseAVCUnitInterface()
{
    if (avcInterface_) {
        (*avcInterface_)->close(avcInterface_);
        (*avcInterface_)->Release(avcInterface_);
        avcInterface_ = nullptr;
    }
    return {};
}

std::expected<std::vector<uint8_t>, IOKitError> CommandInterface::sendCommand(
    const std::vector<uint8_t>& command)
{
    if (!avcInterface_) {
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotOpen));
    }

    std::stringstream ss;
    ss << "Sending command: ";
    for (const auto& byte : command) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    spdlog::info("{}", ss.str());

    UInt32 cmdLen = static_cast<UInt32>(command.size());
    UInt32 respCapacity = 512;
    std::vector<uint8_t> response(respCapacity, 0);

    IOReturn result = (*avcInterface_)->AVCCommand(avcInterface_,
                                                    command.data(),
                                                    cmdLen,
                                                    response.data(),
                                                    &respCapacity);

    if (result != kIOReturnSuccess) {
        spdlog::error("Error sending command: 0x{:x}", result);
        return std::unexpected(static_cast<IOKitError>(result));
    }

    response.resize(respCapacity);

    ss.str("");
    ss.clear();
    ss << "Response: ";
    for (const auto& byte : response) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte) << " ";
    }
    spdlog::info("{}", ss.str());
    return response;
}

std::expected<void, IOKitError> CommandInterface::setNotificationCallback(DeviceStatusCallback callback, void* refCon)
{
    if (notificationCallback_) {
        return std::unexpected(static_cast<IOKitError>(kIOReturnExclusiveAccess));
    }
    notificationCallback_ = callback;
    refCon_ = refCon;

    io_object_t interestNotification = 0;
    auto result = IOServiceAddInterestNotification(
                           pAudioDevice_->getNotificationPort(),
                           avcUnit_,
                           kIOGeneralInterest,
                           deviceInterestCallback,
                           this,
                           &interestNotification
                           );

    if (result != kIOReturnSuccess) {
        spdlog::error("Failed to add interest notification: {}", result);
        return std::unexpected(static_cast<IOKitError>(result));
    }
    interestNotification_ = interestNotification;
    return {};
}

void CommandInterface::clearNotificationCallback()
{
    if (interestNotification_) {
        IOObjectRelease(interestNotification_);
        interestNotification_ = 0;
    }
    notificationCallback_ = nullptr;
    refCon_ = nullptr;
}

void CommandInterface::deviceInterestCallback(void* refCon, io_service_t service,
                                              natural_t messageType, void* messageArgument)
{
    CommandInterface* self = static_cast<CommandInterface*>(refCon);
    if (!self) return;

    if (messageType == kIOMessageServiceIsTerminated) {
        spdlog::info("Device terminated!");
        if (self->notificationCallback_) {
            self->notificationCallback_(self->pAudioDevice_, messageType, messageArgument);
        }
    }
}

} // namespace FWA



=== src/FWA/IOKitFireWireDeviceDiscovery.cpp ===
#include "FWA/IOKitFireWireDeviceDiscovery.h"
#include "FWA/AudioDevice.h"
#include "FWA/Error.h"
#include <spdlog/spdlog.h>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOKitLib.h>
#include <IOKit/firewire/IOFireWireLib.h>
#include <IOKit/avc/IOFireWireAVCLib.h>
#include <IOKit/IOMessage.h> 
#include <iostream>
#include <mach/mach.h>
#include <algorithm>
#include "FWA/Helpers.h"


namespace FWA {

IOKitFireWireDeviceDiscovery::IOKitFireWireDeviceDiscovery(std::shared_ptr<DeviceController> deviceController) :
    masterPort_(MACH_PORT_NULL),
    notifyPort_(nullptr),
    runLoopSource_(nullptr),
    deviceIterator_(0),
    deviceController_(deviceController),
    callback_(nullptr)
{
}

IOKitFireWireDeviceDiscovery::~IOKitFireWireDeviceDiscovery() {
    stopDiscovery();
}

std::expected<void, IOKitError> IOKitFireWireDeviceDiscovery::startDiscovery(DeviceNotificationCallback callback) {
    if (discoveryThreadRunning_) {
        return std::unexpected(static_cast<IOKitError>(kIOReturnExclusiveAccess));
    }
    
    callback_ = callback;
    discoveryThreadRunning_ = true;
    
    discoveryThread_ = std::thread(&IOKitFireWireDeviceDiscovery::discoveryThreadFunction, this);
    
    return {};
}
void IOKitFireWireDeviceDiscovery::discoveryThreadFunction() {
    
    kern_return_t kr = IOMainPort(MACH_PORT_NULL, &masterPort_);
    if (kr != KERN_SUCCESS || masterPort_ == MACH_PORT_NULL) {
        spdlog::error("discoveryThreadFunction: Failed to get IOMasterPort: {}", kr);
        discoveryThreadRunning_ = false;
        return;
    }
    notifyPort_ = IONotificationPortCreate(masterPort_);
    if (!notifyPort_) {
        spdlog::error("discoveryThreadFunction: Failed to create IONotificationPort");
        discoveryThreadRunning_ = false;
        return;
    }
    
    runLoopSource_ = IONotificationPortGetRunLoopSource(notifyPort_);
    if (!runLoopSource_) {
        spdlog::error("discoveryThreadFunction: Failed to get run loop source");
        discoveryThreadRunning_ = false;
        return;
    }
    discoveryRunLoop_ = CFRunLoopGetCurrent();
    CFRunLoopAddSource(discoveryRunLoop_, runLoopSource_, kCFRunLoopDefaultMode);
    
    CFMutableDictionaryRef matchingDictAdded = IOServiceMatching("IOFireWireAVCUnit");
    if (!matchingDictAdded)
    {
        spdlog::error("discoveryThreadFunction: cannot create matching dict");
        discoveryThreadRunning_ = false;
        return;
    }
    kern_return_t result = IOServiceAddMatchingNotification(
                                                            notifyPort_,
                                                            kIOMatchedNotification,
                                                            matchingDictAdded,
                                                            deviceAdded,
                                                            this,
                                                            &deviceIterator_
                                                            );
    if (result != KERN_SUCCESS) {
        spdlog::error("discoveryThreadFunction: Failed to add matching notification (added): {}", result);
        CFRelease(matchingDictAdded); // Release ONLY on error
        discoveryThreadRunning_ = false;
        return;
    }
    // Immediately iterate to find any already-connected devices.
    deviceAdded(this, deviceIterator_);
    
    CFRunLoopRun();
    spdlog::info("discoveryThreadFunction: Exiting run loop.");
    discoveryThreadRunning_ = false;
    
}

std::expected<void, IOKitError> IOKitFireWireDeviceDiscovery::stopDiscovery() {
    if (!discoveryThreadRunning_) {
        return {};
    }
    
    discoveryThreadRunning_ = false;
    
    if (discoveryRunLoop_) {
        CFRunLoopStop(discoveryRunLoop_);
    }
    
    if (discoveryThread_.joinable()) {
        discoveryThread_.join();
    }
    
    if (runLoopSource_) {
        CFRunLoopSourceInvalidate(runLoopSource_);
        runLoopSource_ = nullptr;
    }
    if (notifyPort_) {
        IONotificationPortDestroy(notifyPort_);
        notifyPort_ = nullptr;
    }
    if (masterPort_ != MACH_PORT_NULL) {
        mach_port_deallocate(mach_task_self(), masterPort_);
        masterPort_ = MACH_PORT_NULL;
    }
    if (deviceIterator_) {
        IOObjectRelease(deviceIterator_);
        deviceIterator_ = 0;
    }
    
    // Clear devices under mutex protection
    {
        std::lock_guard<std::mutex> lock(devicesMutex_);
        devices_.clear();
    }
    
    callback_ = nullptr;
    return {};
}


std::expected<std::shared_ptr<AudioDevice>, IOKitError> IOKitFireWireDeviceDiscovery::getDeviceByGuid(std::uint64_t guid)
{
    std::lock_guard<std::mutex> lock(devicesMutex_); // Protect access
    auto it = std::find_if(devices_.begin(), devices_.end(),
                           [&](const auto& device) { return device->getGuid() == guid; });
    
    if (it != devices_.end()) {
        return *it;
    } else {
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotFound));
    }
}


void IOKitFireWireDeviceDiscovery::deviceAdded(void* refCon, io_iterator_t iterator)
{
    IOKitFireWireDeviceDiscovery* self = static_cast<IOKitFireWireDeviceDiscovery*>(refCon);
    if (!self) {
        spdlog::error("deviceAdded: refCon is null!"); // Should never happen, but check anyway.
        return;
    }
    
    spdlog::info("deviceAdded called");
    
    io_object_t device;
    while ((device = IOIteratorNext(iterator)) != 0) {
        spdlog::info("deviceAdded: Iterating device");
        
        // Try to get the GUID *before* creating the AudioDevice.
        auto guidResult = self->getDeviceGuid(device);
        if (!guidResult) {
            spdlog::error("deviceAdded: Failed to get GUID: 0x{:x}", static_cast<int>(guidResult.error()));
            IOObjectRelease(device);
            continue; // Go to the next device
        }
        
        UInt64 guid = guidResult.value();
        spdlog::info("deviceAdded: Got GUID: 0x{:x}", guid);
        
        // Check if device with that GUID already added
        {   // Scope for the lock_guard
            std::lock_guard<std::mutex> lock(self->devicesMutex_);
            if (self->findDeviceByGuid(guid) != nullptr) {
                spdlog::warn("deviceAdded: Device with GUID 0x{:x} already exists. Skipping.", guid);
                IOObjectRelease(device);
                continue; // Go to the next device
            }
        }
        
        spdlog::info("deviceAdded: Creating AudioDevice");
        
        // Now, and *only* now, create the AudioDevice.
        auto audioDeviceResult = self->createAudioDevice(device);
        if (audioDeviceResult) {
            spdlog::info("deviceAdded: AudioDevice created successfully");
            {
                std::lock_guard<std::mutex> lock(self->devicesMutex_);
                self->devices_.push_back(audioDeviceResult.value());
            }
            if (self->callback_) {
                spdlog::info("deviceAdded: Calling callback");
                self->callback_(audioDeviceResult.value(), true); // connected = true
            }
        } else {
            spdlog::error("deviceAdded: Failed to create AudioDevice: 0x{:x}", static_cast<int>(audioDeviceResult.error()));
        }
        
        IOObjectRelease(device);
    }
    spdlog::info("deviceAdded: Finished iterating devices"); 
}

std::expected<std::shared_ptr<AudioDevice>, IOKitError>
IOKitFireWireDeviceDiscovery::createAudioDevice(io_object_t device) {
    spdlog::info("createAudioDevice: Entered function");
    
    CFMutableDictionaryRef properties = nullptr;
    IOReturn result = IORegistryEntryCreateCFProperties(device, &properties, kCFAllocatorDefault, kNilOptions);
    if (result != kIOReturnSuccess || properties == nullptr) {
        spdlog::error("createAudioDevice: Failed to get device properties: {}", result);
        if (properties) CFRelease(properties);
        return std::unexpected(static_cast<IOKitError>(result));
    }
    spdlog::info("createAudioDevice: Got device properties");
    
    // display the dictionary
    //FWA::Helpers::printCFDictionary(properties); //Keep this, VERY useful
    
    // 1. Get the GUID.
    CFNumberRef guidNumber = (CFNumberRef)CFDictionaryGetValue(properties, CFSTR("GUID"));
    if (guidNumber == nullptr) {
        spdlog::error("createAudioDevice: Device missing GUID");
        CFRelease(properties);
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotFound));
    }
    spdlog::info("createAudioDevice: Got GUID CFNumberRef");
    
    UInt64 guid;
    if (!CFNumberGetValue(guidNumber, kCFNumberSInt64Type, &guid)) {
        spdlog::error("createAudioDevice: Failed to get GUID value");
        CFRelease(properties);
        return std::unexpected(static_cast<IOKitError>(kIOReturnBadArgument));
    }
    spdlog::info("createAudioDevice: Got GUID value");
    
    // 2. Get the device name.
    CFStringRef nameRef = (CFStringRef)CFDictionaryGetValue(properties, CFSTR("FireWire Product Name"));
    std::string deviceName = "Unknown Device"; // Default value.
    if (nameRef != nullptr) {
        char nameBuffer[256]; // Choose a reasonable buffer size.
        if (CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer), kCFStringEncodingUTF8)) {
            deviceName = nameBuffer;
        }
    }
    spdlog::info("createAudioDevice: Got device name");
    
    // 3. Get the vendor name.
    CFStringRef vendorRef = (CFStringRef)CFDictionaryGetValue(properties, CFSTR("FireWire Vendor Name"));
    std::string vendorName = "Unknown Vendor"; // Default
    if (vendorRef != nullptr) {
        char vendorBuffer[256];
        if (CFStringGetCString(vendorRef, vendorBuffer, sizeof(vendorBuffer), kCFStringEncodingUTF8)) {
            vendorName = vendorBuffer;
        }
    }
    spdlog::info("createAudioDevice: Got vendor name");
    
    CFRelease(properties); // *CRITICAL*: Release the properties dictionary.
    
    // Get the AVC Unit service (io_object_t).  This is what we'll use for
    // communication. We traverse from "device" (IOFireWireAVCUnit) to its Unit, using IORegistryEntryGetParentEntry
    io_service_t avcUnit = 0;
    
    spdlog::info("AVC Device before getting parent entry");
    // DEBUG:
    char className[256];
    IOObjectGetClass(device, className);
    spdlog::info("device class: {}", className);


    result = IORegistryEntryGetParentEntry(device, kIOServicePlane, &avcUnit);
    if (result != kIOReturnSuccess) {
        spdlog::error("createAudioDevice: Failed to get parent AVC unit entry: {}", result);
        return std::unexpected(static_cast<IOKitError>(result));
    }
    if (!avcUnit)
    {
        spdlog::error("createAudioDevice: Failed to get avcUnit");
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotFound));
    }

    // DEBUG:
    spdlog::info("AVC Device after getting parent entry");
    IOObjectGetClass(device, className);
    spdlog::info("device class: {}", className);

    
    // ---- Add interest notification for THIS device ----
    
    io_object_t interestNotification = 0; // This will hold the notification object.
    
    // Set up interest-based notification for removal
    result = IOServiceAddInterestNotification(
                                              notifyPort_,       // The notification port  <----- Use notifyPort_ here.
                                              device,                 // The service object representing AV/C Unit
                                              kIOGeneralInterest,      // The type of interest
                                              deviceInterestCallback, // The callback function
                                              this,                   // refCon: Pass 'this' pointer.
                                              &interestNotification    // Store the notification object for later removal
                                              );
    
    if (result != kIOReturnSuccess) {
        spdlog::error("createAudioDevice: Failed to add interest notification: {}", result);
        IOObjectRelease(avcUnit); // Release avcUnit if failed.
        return std::unexpected(static_cast<IOKitError>(result));
    }
    
    // Now is safe to create device, with all io objects it needs.
    // Create the AudioDevice, passing in the required parameters.
    std::shared_ptr<AudioDevice> audioDevice = std::make_shared<AudioDevice>(guid, deviceName, vendorName,
                                                                             device, deviceController_.get());
    
    // Release the local reference to avcUnit, AudioDevice now owns it
    IOObjectRelease(device);
    
    // --- Initialize the AudioDevice ---
    auto initResult = audioDevice->init();
    if (!initResult) {
        spdlog::error("Failed to initialize AudioDevice: 0x{:x}", static_cast<int>(initResult.error()));
        // DO NOT release the device object here; the AudioDevice destructor handles it.
        return std::unexpected(initResult.error());
    }
    
    return audioDevice; // Return smart pointer
}

void IOKitFireWireDeviceDiscovery::setTestCallback(DeviceNotificationCallback callback) {
    spdlog::info("setTestCallback called");
    callback_ = callback;
}

std::shared_ptr<AudioDevice> IOKitFireWireDeviceDiscovery::findDeviceByGuid(UInt64 guid) {
    spdlog::info("findDeviceByGuid called with GUID: 0x{:x}", guid);
    auto it = std::find_if(devices_.begin(), devices_.end(),
                           [guid](const std::shared_ptr<AudioDevice>& device) {
        return device->getGuid() == guid;
    });
    
    if (it != devices_.end()) {
        spdlog::info("findDeviceByGuid: Device found");
        return *it;
    } else {
        spdlog::info("findDeviceByGuid: Device not found");
        return nullptr;
    }
}

std::expected<std::vector<std::shared_ptr<AudioDevice>>, IOKitError> IOKitFireWireDeviceDiscovery::getConnectedDevices()
{
    std::lock_guard<std::mutex> lock(devicesMutex_); // Should be locked!
    return devices_;
}

// Helper function to get GUID
std::expected<UInt64, IOKitError> IOKitFireWireDeviceDiscovery::getDeviceGuid(io_object_t device)
{
    CFMutableDictionaryRef props = nullptr;
    IOReturn result = IORegistryEntryCreateCFProperties(device, &props, kCFAllocatorDefault, kNilOptions);
    if (result != kIOReturnSuccess || props == nullptr) {
        if (props) CFRelease(props);
        return std::unexpected(static_cast<IOKitError>(result));
    }
    
    CFNumberRef guidNumber = (CFNumberRef)CFDictionaryGetValue(props, CFSTR("GUID"));
    UInt64 guid = 0;
    if (guidNumber == nullptr || !CFNumberGetValue(guidNumber, kCFNumberSInt64Type, &guid)) {
        CFRelease(props);
        return std::unexpected(static_cast<IOKitError>(kIOReturnNotFound));
    }
    CFRelease(props);
    return guid;
}

// --- The interest callback ---
void IOKitFireWireDeviceDiscovery::deviceInterestCallback(void* refCon, io_service_t service, natural_t messageType, void* messageArgument) {
    IOKitFireWireDeviceDiscovery* self = static_cast<IOKitFireWireDeviceDiscovery*>(refCon);
    if (!self) return;
    
    spdlog::info("deviceInterestCallback called: messageType = 0x{:x}", messageType);
    
    if (messageType == kIOMessageServiceIsTerminated) {
        spdlog::info("Device terminated!");
        // 1. Find device in the list.
        
        // Get properties to find the GUID
        CFMutableDictionaryRef properties = nullptr;
        IOReturn result = IORegistryEntryCreateCFProperties(service, &properties, kCFAllocatorDefault, kNilOptions);
        if (result != kIOReturnSuccess || properties == nullptr) {
            spdlog::error("deviceInterestCallback: Failed to get device properties: {}", result);
            if (properties) CFRelease(properties);
            return;
        }
        CFNumberRef guidNumber = (CFNumberRef)CFDictionaryGetValue(properties, CFSTR("GUID"));
        UInt64 guid = 0;
        if (guidNumber == nullptr || !CFNumberGetValue(guidNumber, kCFNumberSInt64Type, &guid)) {
            spdlog::error("deviceInterestCallback: Device missing GUID or invalid GUID");
            CFRelease(properties);
            return;
        }
        CFRelease(properties);
        // 2. find device
        // Check if device with that GUID already added
        std::shared_ptr<AudioDevice> foundDevice;
        {   // Scope for the lock_guard
            std::lock_guard<std::mutex> lock(self->devicesMutex_);
            foundDevice = self->findDeviceByGuid(guid);
        }
        
        if (!foundDevice) {
            spdlog::info("deviceInterestCallback: device is not found.");
            return;
        }
        
        // 3. Call the callback with 'false' for disconnected.
        if (self->callback_) {
            self->callback_(foundDevice, false);
        }
        
        // 4. Remove device from the list
        {   // Scope for the lock_guard
            std::lock_guard<std::mutex> lock(self->devicesMutex_);
            self->devices_.erase(std::remove_if(self->devices_.begin(), self->devices_.end(),
                                                [&](const std::shared_ptr<AudioDevice>& dev) {
                return dev->getGuid() == guid;
            }), self->devices_.end());
        }
        spdlog::info("deviceInterestCallback: Device 0x{:x} removed.", guid);
    }
}
} // namespace FWA



=== src/FWA/DeviceParser.cpp ===
#include "FWA/DeviceParser.hpp"
#include "FWA/CommandInterface.h"
#include "FWA/AudioDevice.h"
#include <IOKit/avc/IOFireWireAVCConsts.h>
#include <spdlog/spdlog.h>
#include <sstream>
#include <iomanip>

namespace FWA {

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
// We'll use kAVCStatusInquiryCommand from IOFireWireAVCConsts.h.
// For the discovery command, we want the unit plug discovery:
//   [0]: kAVCStatusInquiryCommand
//   [1]: 0xFF (unit plug indicator)
//   [2]: 0x02 (discovery command)
//   [3]: 0x00 (reserved)
//   [4-7]: 0xFF (wildcard)
// Also, we use an initial extended stream format opcode (0xBF) with fallback (0x2F).
constexpr uint8_t kStartingStreamFormatOpcode = 0xBF;
constexpr uint8_t kAlternateStreamFormatOpcode  = 0x2F;

//--------------------------------------------------------------------------
// DeviceParser Constructor
//--------------------------------------------------------------------------

DeviceParser::DeviceParser(std::shared_ptr<AudioDevice> device)
    : device_(device), info_(device->info_)
{
    // Create subunit objects that will later be filled in.
    musicSubunit_ = std::make_shared<MusicSubunit>();
    audioSubunit_ = std::make_shared<AudioSubunit>();
}

//--------------------------------------------------------------------------
// DeviceParser::parse()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::parse() {
    spdlog::info("Parsing device capabilities for device: {}", device_->getDeviceName());

    // (A) First, discover the unit plugs and update AudioDevice's plug counts.
    if (auto discResult = discoverUnitPlugs(); !discResult) {
        spdlog::error("Failed to discover unit plugs.");
        return discResult;
    }

    // (B) If the device reports Isochronous Input plugs, perform further discovery.
    if (device_->numIsoInPlugs > 0) {
        if (auto isoResult = parseIsoInPlugs(); !isoResult) {
            spdlog::error("Failed to parse Isochronous Input plugs.");
            return isoResult;
        }
    }

    // If the device reports Isochronous Output plugs
    if (device_->numIsoOutPlugs > 0) {
        if (auto isoResult = parseIsoOutPlugs(); !isoResult) {
            spdlog::error("Failed to parse Isochronous Output plugs.");
            return isoResult;
        }
    }


    // (C) Continue with further discovery (e.g., Music Subunit and Audio Subunit)
    if (auto musicResult = parseMusicSubunit(); !musicResult) {
        spdlog::error("Failed to parse Music Subunit");
        return std::unexpected(musicResult.error());
    }

    if (auto audioResult = parseAudioSubunit(); !audioResult) {
        spdlog::error("Failed to parse Audio Subunit");
        return std::unexpected(audioResult.error());
    }

    return {};
}

//--------------------------------------------------------------------------
// DeviceParser::discoverUnitPlugs()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::discoverUnitPlugs() {
    spdlog::info("Discovering unit plugs...");

    // Build the discovery command (8 bytes):
    //   [0] : kAVCStatusInquiryCommand
    //   [1] : 0xFF (unit plug indicator)
    //   [2] : 0x02 (discovery command)
    //   [3] : 0x00 (reserved)
    //   [4-7]: 0xFF (wildcard)
    std::vector<uint8_t> cmd = {
        kAVCStatusInquiryCommand,
        0xFF,
        0x02,
        0x00,
        0xFF, 0xFF, 0xFF, 0xFF
    };

    auto respResult = device_->getCommandInterface()->sendCommand(cmd);
    if (!respResult) {
        spdlog::error("Failed to send unit plug discovery command.");
        return std::unexpected(respResult.error());
    }
    const auto& response = respResult.value();
    if (response.size() < 8 || response[0] != kAVCImplementedStatus) {
        spdlog::error("Discovery command returned unexpected status or insufficient bytes.");
        return std::unexpected(IOKitError(kIOReturnError));
    }

    // Update AudioDevice's private members.
    device_->numIsoInPlugs  = response[4];
    device_->numIsoOutPlugs = response[5];
    device_->numExtInPlugs  = response[6];
    device_->numExtOutPlugs = response[7];

    spdlog::info("Discovered unit plugs: IsoIn = {}, IsoOut = {}, ExtIn = {}, ExtOut = {}",
                 device_->numIsoInPlugs, device_->numIsoOutPlugs,
                 device_->numExtInPlugs, device_->numExtOutPlugs);

    return {};
}

//--------------------------------------------------------------------------
// DeviceParser::parseIsoInPlugs()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::parseIsoInPlugs() {
    spdlog::info("Parsing Isochronous Input Plugs...");
    // For each isochronous input plug (as reported in device_->numIsoInPlugs),
    // send a command to retrieve its current stream format.
    for (uint8_t i = 0; i < device_->numIsoInPlugs; ++i) {
        // Create an AudioPlug with direction Input and usage Isochronous.
        auto plug = std::make_shared<AudioPlug>(0xFF, i, PlugDirection::Input, PlugUsage::Isochronous);

        // Build the command to retrieve current stream format for an input plug.
        // Here we mimic the structure used for unit plugs, but adjust the flag for input.
        std::vector<uint8_t> cmdStream = {
            kAVCStatusInquiryCommand,
            0xFF,                         // Unit plug indicator.
            kStartingStreamFormatOpcode,  // Start with initial opcode.
            0xC0,
            0x00,                         // For input plug, flag 0x00.
            0x00,                         // Unit plug indicator.
            0x00,                         // Plug category (e.g. PCR for plugNum < 0x80).
            i,                            // Plug number.
            0xFF, 0xFF                    // Wildcard.
        };

        auto streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
        if (streamRespResult) {
            // If the response indicates "not implemented" (kAVCNotImplementedStatus), try the alternate opcode.
            if (!streamRespResult.value().empty() &&
                streamRespResult.value()[0] == kAVCNotImplementedStatus)
            {
                spdlog::info("Opcode 0xBF not supported for IsoIn plug {} (response = 0x{:02x}); trying alternate opcode 0x2F",
                             i, streamRespResult.value()[0]);
                cmdStream[2] = kAlternateStreamFormatOpcode;
                streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
            }
            auto formatResult = parseStreamFormat(streamRespResult.value());
            if (formatResult) {
                plug->setCurrentStreamFormat(formatResult.value());
            } else {
                spdlog::warn("Failed to parse stream format for IsoIn plug {}", i);
            }
        } else {
            spdlog::warn("Failed to get stream format for IsoIn plug {}", i);
        }

        

        if (device_->info_.musicSubunit) {
            device_->info_.musicSubunit->addIsoInputPlug(plug);
            spdlog::info("Added IsoIn plug {} to music subunit: {}", i,
                         plug->getCurrentStreamFormat() ? plug->getCurrentStreamFormat()->toString() : "None");
        }
    }
    return {};
}

//--------------------------------------------------------------------------
// DeviceParser::parseIsoOutPlugs()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::parseIsoOutPlugs() {
    spdlog::info("Parsing Isochronous Output Plugs...");
    // For each isochronous output plug (as reported in device_->numIsoOutPlugs),
    // send a command to retrieve its current stream format.
    for (uint8_t i = 0; i < device_->numIsoOutPlugs; ++i) {
        // Create an AudioPlug with direction Output and usage Isochronous.
        auto plug = std::make_shared<AudioPlug>(0xFF, i, PlugDirection::Output, PlugUsage::Isochronous);

        // Build the command to retrieve current stream format for an output plug.
        // Here we mimic the structure used for unit plugs, but adjust the flag for output.
        std::vector<uint8_t> cmdStream = {
            kAVCStatusInquiryCommand,
            0xFF,                         // Unit plug indicator.
            kStartingStreamFormatOpcode,  // Start with initial opcode.
            0xC0,
            0x01,                         // For output plug, flag 0x01.
            0x00,                         // Unit plug indicator.
            0x00,                         // Plug category (e.g. PCR for plugNum < 0x80).
            i,                            // Plug number.
            0xFF, 0xFF                    // Wildcard.
        };

        auto streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
        if (streamRespResult) {
            // If the response indicates "not implemented" (kAVCNotImplementedStatus), try the alternate opcode.
            if (!streamRespResult.value().empty() &&
                streamRespResult.value()[0] == kAVCNotImplementedStatus)
            {
                spdlog::info("Opcode 0xBF not supported for IsoOut plug {} (response = 0x{:02x}); trying alternate opcode 0x2F",
                             i, streamRespResult.value()[0]);
                cmdStream[2] = kAlternateStreamFormatOpcode;
                streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
            }
            auto formatResult = parseStreamFormat(streamRespResult.value());
            if (formatResult) {
                plug->setCurrentStreamFormat(formatResult.value());
            } else {
                spdlog::warn("Failed to parse stream format for IsoOut plug {}", i);
            }
        } else {
            spdlog::warn("Failed to get stream format for IsoOut plug {}", i);
        }
        if (device_->info_.musicSubunit) {
            device_->info_.musicSubunit->addIsoOutputPlug(plug);
            spdlog::info("Added IsoOut plug {} to music subunit: {}", i,
                         plug->getCurrentStreamFormat() ? plug->getCurrentStreamFormat()->toString() : "None");
        }
    }
    return {};
}


//--------------------------------------------------------------------------
// DeviceParser::parseMusicSubunit()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::parseMusicSubunit() {
    spdlog::info("Parsing Music Subunit Information...");

    // (For demonstration, we use a command to query music subunit plugs.)
    std::vector<uint8_t> command = {
        kAVCStatusInquiryCommand,
        kMusicSubunitSubUnitID,       // Music subunit ID: 0x60.
        0x02,                         // Discovery command identifier.
        0x00,
        0xFF, 0xFF, 0xFF, 0xFF
    };

    auto responseResult = device_->getCommandInterface()->sendCommand(command);
    if (!responseResult) {
        spdlog::error("Failed to retrieve Music Subunit information.");
        return std::unexpected(responseResult.error());
    }
    const auto& response = responseResult.value();
    if (response.size() < 6) {
        spdlog::error("Invalid Music Subunit response size: {} bytes", response.size());
        return std::unexpected(IOKitError(kIOReturnError));
    }

    // Assume response[4] is number of destination plugs, response[5] is number of source plugs.
    uint8_t numDest = response[4];
    uint8_t numSource = response[5];
    spdlog::info("Music Subunit Destination Plugs: {}", numDest);
    spdlog::info("Music Subunit Source Plugs: {}", numSource);
    musicSubunit_->setMusicDestPlugCount(numDest);
    musicSubunit_->setMusicSourcePlugCount(numSource);

    // For each destination plug in the Music Subunit, send a command to retrieve its stream format.
    for (uint8_t i = 0; i < numDest; ++i) {
        auto plug = std::make_shared<AudioPlug>(0xFF, i, PlugDirection::Output, PlugUsage::MusicSubunit);
        std::vector<uint8_t> cmdStream = {
            kAVCStatusInquiryCommand,
            0xFF,                         // For unit plugs, use 0xFF.
            kStartingStreamFormatOpcode,  // Start with initial opcode.
            0xC0,
            0x01,                         // For destination plug, flag = 0x01.
            0x00,
            0x00,
            i,
            0xFF, 0xFF
        };
        auto streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
        if (streamRespResult) {
            if (!streamRespResult.value().empty() &&
                streamRespResult.value()[0] == kAVCNotImplementedStatus)
            {
                spdlog::info("Opcode 0xBF not supported for Music plug {} (response=0x{:02x}); switching opcode",
                             i, streamRespResult.value()[0]);
                cmdStream[2] = kAlternateStreamFormatOpcode;
                streamRespResult = device_->getCommandInterface()->sendCommand(cmdStream);
            }
            auto formatResult = parseStreamFormat(streamRespResult.value());
            if (formatResult) {
                plug->setCurrentStreamFormat(formatResult.value());
            } else {
                spdlog::warn("Failed to parse stream format for Music plug {}", i);
            }
        } else {
            spdlog::warn("Failed to get stream format for Music plug {}", i);
        }
        musicSubunit_->addMusicDestPlug(plug);
    }
    return {};
}

//--------------------------------------------------------------------------
// DeviceParser::parseAudioSubunit()
//--------------------------------------------------------------------------
std::expected<void, IOKitError> DeviceParser::parseAudioSubunit() {
    spdlog::info("Parsing Audio Subunit Information...");
    // For demonstration, simply create one audio destination plug.
    audioSubunit_->setAudioDestPlugCount(1);
    audioSubunit_->setAudioSourcePlugCount(1);

    auto plug = std::make_shared<AudioPlug>(0x08, 0, PlugDirection::Output, PlugUsage::AudioSubunit);
    audioSubunit_->addAudioDestPlug(plug);
    return {};
}

//--------------------------------------------------------------------------
// DeviceParser::parseStreamFormat()
//--------------------------------------------------------------------------
std::expected<AudioStreamFormat, IOKitError> DeviceParser::parseStreamFormat(const std::vector<uint8_t>& response) {
    // Assume the first 10 bytes are a header; the format block starts at offset 10.
    if (response.size() < 10) {
        spdlog::error("Response too short: {} bytes", response.size());
        return std::unexpected(IOKitError(kIOReturnUnderrun));
    }
    size_t headerSize = 10;
    size_t fmtLength = response.size() - headerSize;
    if (fmtLength < 7) {
        spdlog::error("Stream format block too short: {} bytes", fmtLength);
        return std::unexpected(IOKitError(kIOReturnUnderrun));
    }
    const uint8_t* fmt = response.data() + headerSize;

    // Determine format type using bytes 0 and 1.
    FormatType fmtType = FormatType::Unknown;
    if (fmt[0] == 0x90 && fmt[1] == 0x40)
        fmtType = FormatType::CompoundAM824;
    else if (fmt[0] == 0x90 && fmt[1] == 0x00)
        fmtType = FormatType::AM824;

    // Map sample rate from fmt[2] (adjust mapping as needed).
    SampleRate sampleRate = SampleRate::Unknown;
    switch (fmt[2]) {
        case 0x00: sampleRate = SampleRate::SR_22050; break;
        case 0x01: sampleRate = SampleRate::SR_24000; break;
        case 0x02: sampleRate = SampleRate::SR_32000; break;
        case 0x03: sampleRate = SampleRate::SR_44100; break;
        case 0x04: sampleRate = SampleRate::SR_48000; break;
        case 0x05: sampleRate = SampleRate::SR_96000; break;
        case 0x06: sampleRate = SampleRate::SR_176400; break;
        case 0x07: sampleRate = SampleRate::SR_192000; break;
        case 0x0A: sampleRate = SampleRate::SR_88200; break;
        default:   sampleRate = SampleRate::Unknown; break;
    }

    // Sync flag from fmt[3]: if bit 0x04 is set, then sync source.
    bool sync = (fmt[3] & 0x04) != 0;

    // Number of format info fields is in fmt[4].
    uint8_t numFields = fmt[4];
    std::vector<ChannelFormat> channels;
    size_t requiredLength = 5 + (numFields * 2);
    if (fmtLength < requiredLength) {
        spdlog::error("Insufficient format info fields: required {} bytes, got {}", requiredLength, fmtLength);
        return std::unexpected(IOKitError(kIOReturnUnderrun));
    }
    size_t offset = 5;
    for (uint8_t i = 0; i < numFields; ++i) {
        ChannelFormat cf;
        cf.channelCount = fmt[offset];
        cf.formatCode = fmt[offset + 1];
        channels.push_back(cf);
        offset += 2;
    }

    AudioStreamFormat format(fmtType, sampleRate, sync, channels);
    spdlog::info("Parsed stream format:\n{}", format.toString());
    return format;
}

} // namespace FWA



=== src/FWA/AudioDevice.cpp ===
#include "FWA/AudioDevice.h"
#include "FWA/CommandInterface.h"
#include "FWA/DeviceParser.hpp"
#include "FWA/DeviceController.h"
#include <spdlog/spdlog.h>
#include <IOKit/IOMessage.h>

namespace FWA {

AudioDevice::AudioDevice(std::uint64_t guid,
                         const std::string& deviceName,
                         const std::string& vendorName,
                         io_service_t avcUnit,
                         DeviceController *deviceController)
    : guid_(guid),
      deviceName_(deviceName),
      vendorName_(vendorName),
      avcUnit_(avcUnit),
      deviceController_(deviceController)
{
    spdlog::info("AudioDevice::AudioDevice - Creating device with GUID: 0x{:x}", guid);

    if (avcUnit_) {
        IOObjectRetain(avcUnit_);
    }
    // Do NOT call shared_from_this() here!
}

AudioDevice::~AudioDevice()
{
    if (avcUnit_) {
        IOObjectRelease(avcUnit_);
        avcUnit_ = 0;
    }
    if (fwUnit_) {
        IOObjectRelease(fwUnit_);
        fwUnit_ = 0;
    }
    if (fwDevice_) {
        IOObjectRelease(fwDevice_);
        fwDevice_ = 0;
    }
    if (busController_) {
        IOObjectRelease(busController_);
        busController_ = 0;
    }
    if (interestNotification_) {
        IOObjectRelease(interestNotification_);
        interestNotification_ = 0;
    }
    if (notificationPort_) {
        IONotificationPortDestroy(notificationPort_);
        notificationPort_ = nullptr;
    }
}

std::expected<void, IOKitError> AudioDevice::init()
{

    // 1. Retrieve the FireWire objects.
    IOReturn result = IORegistryEntryGetParentEntry(avcUnit_, kIOServicePlane, &fwUnit_);
    if (result != kIOReturnSuccess) {
        spdlog::error("AudioDevice::init: Failed to get fwUnit: 0x{:x}", result);
        return std::unexpected(static_cast<IOKitError>(result));
    }

    result = IORegistryEntryGetParentEntry(fwUnit_, kIOServicePlane, &fwDevice_);
    if (result != kIOReturnSuccess) {
        spdlog::error("AudioDevice::init: Failed to get fwDevice: 0x{:x}", result);
        IOObjectRelease(fwUnit_);
        return std::unexpected(static_cast<IOKitError>(result));
    }
    result = IORegistryEntryGetParentEntry(fwDevice_, kIOServicePlane, &busController_);
    if (result != kIOReturnSuccess) {
        spdlog::error("AudioDevice::init: Failed to get busController: 0x{:x}", result);
        IOObjectRelease(fwUnit_);
        IOObjectRelease(fwDevice_);
        return std::unexpected(static_cast<IOKitError>(result));
    }

    // 2. Create the notification port.
    notificationPort_ = IONotificationPortCreate(kIOMainPortDefault);
    if (!notificationPort_) {
        spdlog::error("AudioDevice::init: Failed to create notification port");
        return std::unexpected(IOKitError::Error);
    }
    
    // create interfaces
    result = createFWDeviceInterface();
    
    if (result != kIOReturnSuccess) {
        spdlog::error("AudioDevice::init: Failed to create FW device interface: 0x{:x}", result);
    }

    // CFRunLoopAddSource(CFRunLoopGetCurrent(),
    //                    IONotificationPortGetRunLoopSource(notificationPort_),
    //                    kCFRunLoopDefaultMode);

  
    // Do not discover capabilities for now
    
    // 3. Now safely create the CommandInterface using shared_from_this().
    
    commandInterface_ = std::make_shared<CommandInterface>(shared_from_this());
//    
//    commandInterface_->activate();

    // 4. Discover device capabilities using DeviceParser.
//    spdlog::info("Starting device capability discovery...");
//    auto parser = std::make_shared<DeviceParser>(shared_from_this());
//    auto parseResult = parser->parse();
//    if (!parseResult) {
//        spdlog::error("Device capability parsing failed.");
//        return std::unexpected(parseResult.error());
//    }
//    spdlog::info("Device capability parsing completed successfully.");

    // readVendorAndModelInfo();

    return {};
}

IOReturn AudioDevice::createFWDeviceInterface() {
    // Local Vars
    IOCFPlugInInterface **theCFPlugInInterface;
    SInt32 theScore;
    IOReturn result = kIOReturnSuccess;

    result = IOCreatePlugInInterfaceForService(
                                               fwDevice_,
                                            kIOFireWireLibTypeID,
                                            kIOCFPlugInInterfaceID,        //interfaceType,
                                            &theCFPlugInInterface,
                                            &theScore);
    if (!result)
    {
        HRESULT comErr;
        comErr = (*theCFPlugInInterface)->QueryInterface(
                                                   theCFPlugInInterface,
                                                   CFUUIDGetUUIDBytes( kIOFireWireNubInterfaceID ),
                                                   (void**) &deviceInterface);
        if (comErr == S_OK)
        {
            result = (*deviceInterface)->AddCallbackDispatcherToRunLoop(deviceInterface, deviceController_->getRunLoopRef());
        }
        else
            result = comErr;

        (*theCFPlugInInterface)->Release(theCFPlugInInterface);    // Leave just one reference.

        // Open the interface
        if (!result)
        {
            // If the avc interface is already open, use it's session ref to open the device interface
            if (avcInterface_)
                result = (*deviceInterface)->OpenWithSessionRef(deviceInterface,
                                                    (*avcInterface_)->getSessionRef(avcInterface_));
            else
                result = (*deviceInterface)->Open(deviceInterface);
            if (result)
            {
                (*deviceInterface)->Release(deviceInterface) ;
                deviceInterface = 0;
            }
        }
    }

    return result;
    
}

IOReturn AudioDevice::readVendorAndModelInfo() {
    CFMutableDictionaryRef properties = nullptr;
    IOReturn result = IORegistryEntryCreateCFProperties(fwUnit_, &properties, kCFAllocatorDefault, 0);
    if (result == kIOReturnSuccess && properties) {
        CFNumberRef unitVendorID = (CFNumberRef)CFDictionaryGetValue(properties, CFSTR("Vendor_ID"));
        if (unitVendorID) {
            UInt32 vendorID = 0;
            CFNumberGetValue(unitVendorID, kCFNumberLongType, &vendorID);
            spdlog::info(" *** Vendor ID: 0x{:08x}", vendorID);
        }
        CFNumberRef unitModelID = (CFNumberRef)CFDictionaryGetValue(properties, CFSTR("Model_ID"));
        if (unitModelID) {
            UInt32 modelID = 0;
            CFNumberGetValue(unitModelID, kCFNumberLongType, &modelID);
            spdlog::info(" *** Model ID: 0x{:08x}", modelID);
        }
        CFStringRef unitVendorStrDesc = (CFStringRef)CFDictionaryGetValue(properties, CFSTR("FireWire Vendor Name"));
        if (unitVendorStrDesc) {
            char vbuf[256];
            if (CFStringGetCString(unitVendorStrDesc, vbuf, sizeof(vbuf), kCFStringEncodingMacRoman))
                vendorName_ = vbuf;
        }
        CFRelease(properties);
    }
    return result;
}

} // namespace FWA



=== include/FWA/AudioPlug.hpp ===
#pragma once

#include "Enums.hpp"
#include "AudioStreamFormat.hpp"
#include <cstdint>
#include <string>
#include <vector>
#include <memory>
#include <optional>

namespace FWA {

/**
 * @brief Represents an audio plug (input or output) on a FireWire audio device
 * 
 * This class encapsulates the properties and capabilities of an audio plug,
 * including its connection status, stream format, and supported formats.
 */
class AudioPlug {
public:
    /**
     * @brief Construct a new Audio Plug object
     * @param subUnit Subunit ID that owns this plug
     * @param plugNum Plug number within the subunit
     * @param direction Direction of the plug (input/output)
     * @param usage Usage type of the plug
     */
    AudioPlug(uint8_t subUnit, uint8_t plugNum, PlugDirection direction, PlugUsage usage)
      : subUnit_(subUnit), plugNum_(plugNum), direction_(direction), usage_(usage) {}
    
    ~AudioPlug() = default;
    
    /**
     * @brief Get the subunit ID
     * @return uint8_t The subunit ID
     */
    uint8_t getSubUnit() const { return subUnit_; }

    /**
     * @brief Get the plug number
     * @return uint8_t The plug number
     */
    uint8_t getPlugNum() const { return plugNum_; }

    /**
     * @brief Get the plug direction
     * @return PlugDirection The direction (input/output)
     */
    PlugDirection getDirection() const { return direction_; }

    /**
     * @brief Get the plug usage type
     * @return PlugUsage The usage type
     */
    PlugUsage getUsage() const { return usage_; }
    
    /**
     * @brief Get the plug number (alias for getPlugNum)
     * @return uint8_t The plug number
     */
    uint8_t getPlugNumber() const { return plugNum_; }
    
    /**
     * @brief Get a human-readable string representing the plug usage
     * @return std::string Usage description
     */
    std::string getPlugUsageString() const {
         switch (usage_) {
             case PlugUsage::Isochronous:   return "Isochronous";
             case PlugUsage::External:       return "External";
             case PlugUsage::MusicSubunit:   return "Music Subunit";
             case PlugUsage::AudioSubunit:   return "Audio Subunit";
             default:                      return "Unknown";
         }
    }
    
    /**
     * @brief Structure containing connection information for destination plugs
     */
    struct ConnectionInfo {
        uint8_t sourceSubUnit;    ///< Source subunit ID
        uint8_t sourcePlugNum;    ///< Source plug number
        uint8_t sourcePlugStatus; ///< Status of the source plug
    };
    
    /**
     * @brief Get the current connection information
     * @return const std::optional<ConnectionInfo>& Optional connection info
     */
    const std::optional<ConnectionInfo>& getConnectionInfo() const { return connectionInfo_; }

    /**
     * @brief Set the connection information
     * @param info Connection information to set
     */
    void setConnectionInfo(ConnectionInfo info) { connectionInfo_ = info; }
    
    /**
     * @brief Get the current stream format
     * @return const std::optional<AudioStreamFormat>& Optional current format
     */
    const std::optional<AudioStreamFormat>& getCurrentStreamFormat() const { return currentFormat_; }

    /**
     * @brief Set the current stream format
     * @param format Format to set as current
     */
    void setCurrentStreamFormat(const AudioStreamFormat& format) { currentFormat_ = format; }
    
    /**
     * @brief Get the list of supported stream formats
     * @return const std::vector<AudioStreamFormat>& List of supported formats
     */
    const std::vector<AudioStreamFormat>& getSupportedStreamFormats() const { return supportedFormats_; }

    /**
     * @brief Add a supported stream format
     * @param format Format to add to supported formats list
     */
    void addSupportedStreamFormat(const AudioStreamFormat& format) { supportedFormats_.push_back(format); }
    
    /**
     * @brief Get the plug name if available
     * @return const std::optional<std::string>& Optional plug name
     */
    const std::optional<std::string>& getPlugName() const { return plugName_; }

    /**
     * @brief Set the plug name
     * @param name Name to set for the plug
     */
    void setPlugName(const std::string& name) { plugName_ = name; }
    
private:
    uint8_t subUnit_;               ///< Subunit ID
    uint8_t plugNum_;              ///< Plug number
    PlugDirection direction_;       ///< Direction of the plug
    PlugUsage usage_;              ///< Usage type of the plug
    
    std::optional<ConnectionInfo> connectionInfo_;        ///< Current connection info
    std::optional<AudioStreamFormat> currentFormat_;     ///< Current stream format
    std::vector<AudioStreamFormat> supportedFormats_;    ///< Supported stream formats
    std::optional<std::string> plugName_;               ///< Optional plug name
};

} // namespace FWA



=== include/FWA/DeviceInfo.hpp ===
#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <memory>
#include "FWA/AudioDevice.h"
#include "FWA/AudioPlug.hpp"
#include "FWA/AudioStreamFormat.hpp"
#include "FWA/Subunit.hpp"
#include "FWA/AVCInfoBlock.hpp"

namespace FWA {

/**
 * @brief Container class for device capabilities and configuration information
 * 
 * This class holds the discovered capabilities, subunits, and configuration
 * information for a FireWire audio device.
 */
class DeviceInfo {
    public:
        DeviceInfo() = default;
        ~DeviceInfo() = default;
    
        std::shared_ptr<MusicSubunit> musicSubunit = std::make_shared<MusicSubunit>();  ///< Music subunit capabilities
        std::shared_ptr<AudioSubunit> audioSubunit = std::make_shared<AudioSubunit>();  ///< Audio subunit capabilities
    
        std::vector<std::shared_ptr<AVCInfoBlock>> infoBlocks;  ///< Parsed AV/C info blocks
};

} // namespace FWA



=== include/FWA/AVCInfoBlock.hpp ===
#pragma once
#include <cstdint>
#include <vector>
#include <memory>
#include <string>
#include <optional>

namespace FWA {

/**
 * @brief Represents an AV/C Information Block from a FireWire device
 *
 * This class encapsulates AV/C info block data and provides methods for
 * parsing and displaying the information in a human-readable format.
 */
class AVCInfoBlock {
public:
    /**
     * @brief Construct a new AVC Info Block
     * @param type Type identifier of the info block
     * @param rawData Raw data bytes from the device
     */
    AVCInfoBlock(uint16_t type, std::vector<uint8_t> rawData)
      : type_(type), rawData_(std::move(rawData)) {}

    ~AVCInfoBlock() = default;
    
    /**
     * @brief Get the type identifier
     * @return uint16_t Type of the info block
     */
    uint16_t getType() const { return type_; }

    /**
     * @brief Get the raw data bytes
     * @return const std::vector<uint8_t>& Raw data from the device
     */
    const std::vector<uint8_t>& getRawData() const { return rawData_; }

    /**
     * @brief Get the compound length
     * @return uint16_t Length of compound data
     */
    uint16_t getCompoundLength() const { return compoundLength_; }

    /**
     * @brief Get the primary fields length
     * @return uint16_t Length of primary fields
     */
    uint16_t getPrimaryFieldsLength() const { return primaryFieldsLength_; }
    
    /**
     * @brief Get the nested info blocks
     * @return const std::vector<std::shared_ptr<AVCInfoBlock>>& Vector of nested blocks
     */
    const std::vector<std::shared_ptr<AVCInfoBlock>>& getNestedBlocks() const { return nestedBlocks_; }
    
    /**
     * @brief Parse the info block data
     * 
     * This method processes the raw data and extracts structured information,
     * including nested info blocks if present.
     */
    void parse();
    
    /**
     * @brief Convert the info block to a human-readable string
     * @param indent Indentation level for formatting (default 0)
     * @return std::string Formatted string representation
     */
    std::string toString(uint32_t indent = 0) const;
    
private:
    uint16_t type_{0};                 ///< Type identifier of the info block
    uint16_t compoundLength_{0};       ///< Length of compound data
    uint16_t primaryFieldsLength_{0};  ///< Length of primary fields
    std::vector<uint8_t> rawData_;     ///< Raw data from device
    std::vector<std::shared_ptr<AVCInfoBlock>> nestedBlocks_;  ///< Nested info blocks
    
    /**
     * @brief Parse primary fields from raw data
     */
    void parsePrimaryFields();
};

} // namespace FWA



=== include/FWA/Enums.hpp ===
#pragma once
#include <cstdint>

namespace FWA {

/**
 * @brief Direction of audio plug (input or output)
 */
enum class PlugDirection : uint8_t {
    Input,    ///< Input direction (receiving audio)
    Output    ///< Output direction (sending audio)
};

/**
 * @brief Type of plug usage in the audio device
 */
enum class PlugUsage : uint8_t {
    Isochronous,    ///< Used for isochronous streaming
    External,       ///< External connection
    MusicSubunit,   ///< Connected to music subunit
    AudioSubunit,   ///< Connected to audio subunit
    Unknown         ///< Unknown usage type
};

/**
 * @brief Audio format type
 */
enum class FormatType : uint8_t {
    CompoundAM824,  ///< Compound AM824 format
    AM824,          ///< Standard AM824 format
    Unknown         ///< Unknown format type
};

/**
 * @brief Sample rates supported by the device
 */
enum class SampleRate : uint8_t {
    SR_22050 = 0x00,     ///< 22.05 kHz
    SR_24000 = 0x01,     ///< 24 kHz
    SR_32000 = 0x02,     ///< 32 kHz
    SR_44100 = 0x03,     ///< 44.1 kHz
    SR_48000 = 0x04,     ///< 48 kHz
    SR_96000 = 0x05,     ///< 96 kHz
    SR_176400 = 0x06,    ///< 176.4 kHz
    SR_192000 = 0x07,    ///< 192 kHz
    SR_88200 = 0x0A,     ///< 88.2 kHz
    DontCare = 0x0F,     ///< Sample rate doesn't matter
    Unknown = 0xFF       ///< Unknown sample rate
};

/**
 * @brief Sample rates specifically for music subunit
 */
enum class MusicSubunitSampleRate : uint8_t {
    SR_32000 = 0x00,     ///< 32 kHz
    SR_44100 = 0x01,     ///< 44.1 kHz
    SR_48000 = 0x02,     ///< 48 kHz
    SR_88200 = 0x03,     ///< 88.2 kHz
    SR_96000 = 0x04,     ///< 96 kHz
    SR_176400 = 0x05,    ///< 176.4 kHz
    SR_192000 = 0x06,    ///< 192 kHz
    Unknown = 0xFF       ///< Unknown sample rate
};

} // namespace FWA



=== include/FWA/DeviceParser.hpp ===
#pragma once

#include <cstdint>
#include <expected>
#include <memory>
#include <vector>
#include "FWA/Error.h"
#include "FWA/AudioDevice.h"
#include "FWA/AudioStreamFormat.hpp"
#include "FWA/AudioPlug.hpp"
#include "FWA/Subunit.hpp"
#include "FWA/DeviceInfo.hpp"

namespace FWA {

/**
 * @brief Parser for discovering and configuring FireWire audio device capabilities
 *
 * DeviceParser is responsible for querying the device via its CommandInterface,
 * discovering plug counts, and then performing further discovery based on the
 * discovered plugs.
 */
class DeviceParser {
public:
    /**
     * @brief Construct a new Device Parser
     * @param device Shared pointer to the AudioDevice to parse
     */
    explicit DeviceParser(std::shared_ptr<AudioDevice> device);
    ~DeviceParser() = default;

    /**
     * @brief Main parse routine to discover device capabilities
     * @return Success or error status
     */
    std::expected<void, IOKitError> parse();

    /**
     * @brief Get the discovered music subunit
     * @return std::shared_ptr<MusicSubunit> Pointer to music subunit or nullptr if not found
     */
    std::shared_ptr<MusicSubunit> getMusicSubunit() const { return musicSubunit_; }

    /**
     * @brief Get the discovered audio subunit
     * @return std::shared_ptr<AudioSubunit> Pointer to audio subunit or nullptr if not found
     */
    std::shared_ptr<AudioSubunit> getAudioSubunit() const { return audioSubunit_; }

private:
    DeviceInfo& info_;
    std::shared_ptr<AudioDevice> device_;
    std::shared_ptr<MusicSubunit> musicSubunit_;
    std::shared_ptr<AudioSubunit> audioSubunit_;

    /**
     * @brief Discover and enumerate unit plugs
     * @return Success or error status
     */
    std::expected<void, IOKitError> discoverUnitPlugs();

    /**
     * @brief Parse isochronous input plugs
     * @return Success or error status
     */
    std::expected<void, IOKitError> parseIsoInPlugs();

    /**
     * @brief Parse isochronous output plugs
     * @return Success or error status
     */
    std::expected<void, IOKitError> parseIsoOutPlugs();

    /**
     * @brief Parse music subunit capabilities
     * @return Success or error status
     */
    std::expected<void, IOKitError> parseMusicSubunit();

    /**
     * @brief Parse audio subunit capabilities
     * @return Success or error status
     */
    std::expected<void, IOKitError> parseAudioSubunit();

    /**
     * @brief Parse a stream format block from device response
     * @param response Raw response data containing stream format information
     * @return Parsed AudioStreamFormat or error status
     */
    std::expected<AudioStreamFormat, IOKitError> parseStreamFormat(const std::vector<uint8_t>& response);
    
    static constexpr uint8_t kMusicSubunitSubUnitID = 0x60;  ///< Standard Music subunit ID
};

} // namespace FWA



=== include/FWA/AudioDeviceStream.hpp ===
#pragma once

#include <cstdint>
#include <string>
#include <memory>
#include <expected>
#include <functional>
#include <atomic>
#include <variant>
#include <IOKit/firewire/IOFireWireLib.h>
#include <spdlog/spdlog.h>

#include "FWA/Error.h"
#include "FWA/AudioDevice.h"
#include "FWA/Isoch/AmdtpTransmitter.hpp"
#include "FWA/Isoch/AmdtpHelpers.hpp"

namespace FWA {

/**
 * @brief Enumeration of stream types supported by AudioDeviceStream
 */
enum class StreamType {
    AmdtpReceiver,           ///< AMDTP receiver stream for audio input
    AmdtpTransmitter,        ///< AMDTP transmitter stream for audio output
    UniversalReceiver,       ///< Legacy universal receiver type
    UniversalTransmitter     ///< Legacy universal transmitter type
};

/**
 * @brief AudioDeviceStream encapsulates an audio stream connected to a FireWire device
 * 
 * This class provides a modern C++23 implementation for managing audio streams
 * over FireWire, using AMDTP (Audio & Music Data Transmission Protocol). It replaces
 * the legacy AVCDeviceStream structure with a robust, type-safe, and efficient design.
 */
class AudioDeviceStream {
public:
    /**
     * @brief Create an AudioDeviceStream as a factory method
     * 
     * @param audioDevice Shared pointer to the parent AudioDevice
     * @param streamType Type of stream to create
     * @param devicePlugNumber The device plug number to connect to
     * @param logger Logger for diagnostics
     * @param cyclesPerSegment Number of cycles per segment for stream buffer
     * @param numSegments Number of segments for stream buffer
     * @param bufferSize Size of buffer in bytes
     * @return std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> Shared pointer to created stream or error
     */
    static std::expected<std::shared_ptr<AudioDeviceStream>, IOKitError> create(
        std::shared_ptr<AudioDevice> audioDevice,
        StreamType streamType,
        uint8_t devicePlugNumber,
        std::shared_ptr<spdlog::logger> logger,
        unsigned int cyclesPerSegment = 8,
        unsigned int numSegments = 4,
        unsigned int bufferSize = 512);
    
    /**
     * @brief Destructor handles proper cleanup of resources
     */
    ~AudioDeviceStream();

    // Prevent copying
    AudioDeviceStream(const AudioDeviceStream&) = delete;
    AudioDeviceStream& operator=(const AudioDeviceStream&) = delete;
    
    // Allow moving
    AudioDeviceStream(AudioDeviceStream&&) noexcept = default;
    AudioDeviceStream& operator=(AudioDeviceStream&&) noexcept = default;

    /**
     * @brief Start the audio stream
     * @return Success or error status
     */
    std::expected<void, IOKitError> start();
    
    /**
     * @brief Stop the audio stream
     * @return Success or error status
     */
    std::expected<void, IOKitError> stop();
    
    /**
     * @brief Set the isochronous channel for the stream
     * @param channel Channel number
     * @return Success or error status
     */
    std::expected<void, IOKitError> setIsochChannel(uint32_t channel);
    
    /**
     * @brief Set the isochronous speed for the stream
     * @param speed Speed setting
     * @return Success or error status
     */
    std::expected<void, IOKitError> setIsochSpeed(IOFWSpeed speed);
    
    /**
     * @brief Get the current isochronous channel
     * @return Current channel number
     */
    uint32_t getIsochChannel() const { return isochChannel_; }
    
    /**
     * @brief Get the current isochronous speed
     * @return Current speed setting
     */
    IOFWSpeed getIsochSpeed() const { return isochSpeed_; }
    
    /**
     * @brief Set message callback for stream events
     * @param callback Function to call for stream events
     */
    void setMessageCallback(Isoch::MessageCallback callback);
    
    /**
     * @brief Set packet callback for received data
     * @param callback Function to call for received packets
     */
    void setPacketCallback(Isoch::PacketCallback callback);
    
    /**
     * @brief Get the type of this stream
     * @return The stream type
     */
    StreamType getStreamType() const { return streamType_; }
    
    /**
     * @brief Get the device plug number
     * @return The device plug number
     */
    uint8_t getDevicePlugNumber() const { return devicePlugNumber_; }
    
    /**
     * @brief Check if the stream is active
     * @return True if the stream is active
     */
    bool isActive() const { return isActive_; }
    
    /**
     * @brief Check if the plug is connected
     * @return True if the plug is connected
     */
    bool isPlugConnected() const { return isPlugConnected_; }

private:
    // Private constructor, use create() factory method instead
    AudioDeviceStream(
        std::shared_ptr<AudioDevice> audioDevice,
        StreamType streamType,
        uint8_t devicePlugNumber,
        std::shared_ptr<spdlog::logger> logger,
        unsigned int cyclesPerSegment,
        unsigned int numSegments,
        unsigned int bufferSize);

    // Core components
    std::shared_ptr<AudioDevice> audioDevice_;
    std::shared_ptr<spdlog::logger> logger_;
    
    // Stream configuration
    StreamType streamType_;
    uint8_t devicePlugNumber_;
    unsigned int cyclesPerSegment_;
    unsigned int numSegments_;
    unsigned int bufferSize_;
    
    // Isoch settings
    uint32_t isochChannel_ = 0xFFFFFFFF; // Any available channel
    IOFWSpeed isochSpeed_ = kFWSpeed100MBit;
    
    // State tracking
    std::atomic<bool> isActive_{false};
    std::atomic<bool> isPlugConnected_{false};
    
    // Stream implementation - using std::variant for type-safe polymorphism
    using StreamVariant = std::variant<
        std::shared_ptr<Isoch::AmdtpReceiver>,
        std::shared_ptr<Isoch::AmdtpTransmitter>
        // Add other stream types here when implementing them
    >;
    
    StreamVariant streamImpl_;
    
    // Methods for handling plug connections
    std::expected<void, IOKitError> connectPlug();
    std::expected<void, IOKitError> disconnectPlug();
    
    // Helpers for handling specific stream types
    template<typename T, typename... Args>
    static std::expected<std::shared_ptr<T>, IOKitError> createStreamImpl(Args&&... args);
    
    // Helper method to convert IOKit return codes to our error type
    static std::expected<void, IOKitError> checkIOReturn(IOReturn result);
};

} // namespace FWA


=== include/FWA/AudioStreamFormat.hpp ===
#pragma once
#include "Enums.hpp"
#include <string>
#include <vector>
#include <cstdint>
#include <sstream>

namespace FWA {

/**
 * @brief Represents per-channel (or per-field) information in an audio stream
 */
struct ChannelFormat {
    uint8_t channelCount;  ///< Number of channels for this format field
    uint8_t formatCode;    ///< Format code (e.g., MBLA, IEC60958-3)
};

/**
 * @brief Represents the format and capabilities of an audio stream
 * 
 * This class encapsulates the format type, sample rate, synchronization source status,
 * and channel format information for an audio stream.
 */
class AudioStreamFormat {
public:
    AudioStreamFormat() = default;

    /**
     * @brief Construct a new Audio Stream Format object
     * @param type Format type of the stream
     * @param sampleRate Sample rate of the stream
     * @param syncSource Whether this stream is a sync source
     * @param channels Vector of channel format information
     */
    AudioStreamFormat(FormatType type, SampleRate sampleRate, bool syncSource, std::vector<ChannelFormat> channels)
      : formatType_(type), sampleRate_(sampleRate), syncSource_(syncSource), channels_(std::move(channels)) {}

    /**
     * @brief Get the format type
     * @return FormatType The stream's format type
     */
    FormatType getFormatType() const { return formatType_; }

    /**
     * @brief Get the sample rate
     * @return SampleRate The stream's sample rate
     */
    SampleRate getSampleRate() const { return sampleRate_; }

    /**
     * @brief Check if this stream is a sync source
     * @return bool True if this stream is a sync source
     */
    bool isSyncSource() const { return syncSource_; }

    /**
     * @brief Get the channel formats
     * @return const std::vector<ChannelFormat>& Vector of channel format information
     */
    const std::vector<ChannelFormat>& getChannelFormats() const { return channels_; }

    /**
     * @brief Set the format type
     * @param type New format type to set
     */
    void setFormatType(FormatType type) { formatType_ = type; }

    /**
     * @brief Set the sample rate
     * @param rate New sample rate to set
     */
    void setSampleRate(SampleRate rate) { sampleRate_ = rate; }

    /**
     * @brief Set the sync source status
     * @param sync New sync source status
     */
    void setSyncSource(bool sync) { syncSource_ = sync; }

    /**
     * @brief Set the channel formats
     * @param channels New vector of channel format information
     */
    void setChannelFormats(const std::vector<ChannelFormat>& channels) { channels_ = channels; }

    /**
     * @brief Get a human-readable string representation of the stream format
     * @return std::string Description of the stream format
     */
    std::string toString() const {
        std::ostringstream oss;
        oss << "Format Type: ";
        switch(formatType_) {
            case FormatType::CompoundAM824: oss << "Compound AM824"; break;
            case FormatType::AM824: oss << "AM824"; break;
            default: oss << "Unknown"; break;
        }
        oss << ", Sample Rate: ";
        switch(sampleRate_) {
            case SampleRate::SR_22050: oss << "22.05KHz"; break;
            case SampleRate::SR_24000: oss << "24KHz"; break;
            case SampleRate::SR_32000: oss << "32KHz"; break;
            case SampleRate::SR_44100: oss << "44.1KHz"; break;
            case SampleRate::SR_48000: oss << "48KHz"; break;
            case SampleRate::SR_96000: oss << "96KHz"; break;
            case SampleRate::SR_176400: oss << "176.4KHz"; break;
            case SampleRate::SR_192000: oss << "192KHz"; break;
            case SampleRate::SR_88200: oss << "88.2KHz"; break;
            default: oss << "Unknown"; break;
        }
        oss << ", Sync Source: " << (syncSource_ ? "Yes" : "No") << "\n";
        oss << "Channel Formats: ";
        for (const auto& cf : channels_) {
            oss << cf.channelCount << " channels (Format Code: " << static_cast<int>(cf.formatCode) << ") ";
        }
        return oss.str();
    }

private:
    FormatType formatType_{FormatType::Unknown};      ///< Format type of the stream
    SampleRate sampleRate_{SampleRate::Unknown};      ///< Sample rate of the stream
    bool syncSource_{false};                          ///< Whether this stream is a sync source
    std::vector<ChannelFormat> channels_;             ///< Channel format information
};

} // namespace FWA



=== include/FWA/XPC/XPCReceiverClient.hpp ===
//
//  XPCReceiverClient.hpp
//  avc-apple2
//
//  Created by Alexander Shabelnikov on 14.02.2025.
//

#ifndef XPC_RECEIVER_CLIENT_HPP
#define XPC_RECEIVER_CLIENT_HPP

#import <Foundation/Foundation.h>
#import "DuetXPCClientProtocol.h"
#include "Isoch/interfaces/ITransmitPacketProvider.hpp"

@interface XPCReceiverClient : NSObject <DuetXPCClientProtocol>
- (instancetype)init;
@property (nonatomic, assign) FWA::Isoch::ITransmitPacketProvider *processor; 
@end

#endif /* XPC_RECEIVER_CLIENT_HPP */



=== include/FWA/Subunit.hpp ===
#pragma once
#include "AudioPlug.hpp"
#include <vector>
#include <memory>
#include <cstdint>
#include <optional>

namespace FWA {

/**
 * @brief Music subunit implementation
 * 
 * Represents a music subunit in a FireWire audio device, which typically
 * handles MIDI data and music-related functionality.
 */
class MusicSubunit {
public:
    MusicSubunit() = default;
    ~MusicSubunit() = default;
    
    /**
     * @brief Get ISO input plug count
     * @return uint32_t Number of ISO input plugs
     */
    uint32_t getIsoInputCount() const { return isoInputCount_; }
    
    /**
     * @brief Get ISO output plug count
     * @return uint32_t Number of ISO output plugs
     */
    uint32_t getIsoOutputCount() const { return isoOutputCount_; }
    
    /**
     * @brief Get external input plug count
     * @return uint32_t Number of external input plugs
     */
    uint32_t getExternalInputCount() const { return externalInputCount_; }
    
    /**
     * @brief Get external output plug count
     * @return uint32_t Number of external output plugs
     */
    uint32_t getExternalOutputCount() const { return externalOutputCount_; }
    
    /**
     * @brief Get music destination plug count
     * @return uint32_t Number of music destination plugs
     */
    uint32_t getMusicDestPlugCount() const { return musicDestPlugCount_; }
    
    /**
     * @brief Get music source plug count
     * @return uint32_t Number of music source plugs
     */
    uint32_t getMusicSourcePlugCount() const { return musicSourcePlugCount_; }
    
    /**
     * @brief Set ISO input plug count
     * @param count Number of ISO input plugs
     */
    void setIsoInputCount(uint32_t count) { isoInputCount_ = count; }
    
    /**
     * @brief Set ISO output plug count
     * @param count Number of ISO output plugs
     */
    void setIsoOutputCount(uint32_t count) { isoOutputCount_ = count; }
    
    /**
     * @brief Set external input plug count
     * @param count Number of external input plugs
     */
    void setExternalInputCount(uint32_t count) { externalInputCount_ = count; }
    
    /**
     * @brief Set external output plug count
     * @param count Number of external output plugs
     */
    void setExternalOutputCount(uint32_t count) { externalOutputCount_ = count; }
    
    /**
     * @brief Set music destination plug count
     * @param count Number of music destination plugs
     */
    void setMusicDestPlugCount(uint32_t count) { musicDestPlugCount_ = count; }
    
    /**
     * @brief Set music source plug count
     * @param count Number of music source plugs
     */
    void setMusicSourcePlugCount(uint32_t count) { musicSourcePlugCount_ = count; }
    
    /**
     * @brief Add an ISO input plug
     * @param plug Shared pointer to the ISO input plug
     */
    void addIsoInputPlug(std::shared_ptr<AudioPlug> plug) { isoInputPlugs_.push_back(plug); }
    
    /**
     * @brief Add an ISO output plug
     * @param plug Shared pointer to the ISO output plug
     */
    void addIsoOutputPlug(std::shared_ptr<AudioPlug> plug) { isoOutputPlugs_.push_back(plug); }
    
    /**
     * @brief Add an external input plug
     * @param plug Shared pointer to the external input plug
     */
    void addExternalInputPlug(std::shared_ptr<AudioPlug> plug) { externalInputPlugs_.push_back(plug); }
    
    /**
     * @brief Add an external output plug
     * @param plug Shared pointer to the external output plug
     */
    void addExternalOutputPlug(std::shared_ptr<AudioPlug> plug) { externalOutputPlugs_.push_back(plug); }
    
    /**
     * @brief Add a music destination plug
     * @param plug Shared pointer to the music destination plug
     */
    void addMusicDestPlug(std::shared_ptr<AudioPlug> plug) { musicDestPlugs_.push_back(plug); }
    
    /**
     * @brief Add a music source plug
     * @param plug Shared pointer to the music source plug
     */
    void addMusicSourcePlug(std::shared_ptr<AudioPlug> plug) { musicSourcePlugs_.push_back(plug); }
    
    /**
     * @brief Get the list of ISO input plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of ISO input plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getIsoInputPlugs() const { return isoInputPlugs_; }
    
    /**
     * @brief Get the list of ISO output plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of ISO output plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getIsoOutputPlugs() const { return isoOutputPlugs_; }
    
    /**
     * @brief Get the list of external input plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of external input plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getExternalInputPlugs() const { return externalInputPlugs_; }
    
    /**
     * @brief Get the list of external output plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of external output plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getExternalOutputPlugs() const { return externalOutputPlugs_; }
    
    /**
     * @brief Get the list of music destination plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of music destination plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getMusicDestPlugs() const { return musicDestPlugs_; }
    
    /**
     * @brief Get the list of music source plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of music source plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getMusicSourcePlugs() const { return musicSourcePlugs_; }
    
    /**
     * @brief Set the status descriptor data
     * @param data Vector of status descriptor data
     */
    void setStatusDescriptorData(const std::vector<uint8_t>& data) { statusDescriptorData_ = data; }
    
    /**
     * @brief Get the status descriptor data
     * @return const std::optional<std::vector<uint8_t>>& Status descriptor data
     */
    const std::optional<std::vector<uint8_t>>& getStatusDescriptorData() const { return statusDescriptorData_; }
    
private:
    uint32_t isoInputCount_{0};     ///< Number of ISO input plugs
    uint32_t isoOutputCount_{0};    ///< Number of ISO output plugs
    uint32_t externalInputCount_{0};///< Number of external input plugs
    uint32_t externalOutputCount_{0};///< Number of external output plugs
    uint32_t musicDestPlugCount_{0};///< Number of music destination plugs
    uint32_t musicSourcePlugCount_{0};///< Number of music source plugs
    
    std::vector<std::shared_ptr<AudioPlug>> isoInputPlugs_;    ///< List of ISO input plugs
    std::vector<std::shared_ptr<AudioPlug>> isoOutputPlugs_;   ///< List of ISO output plugs
    std::vector<std::shared_ptr<AudioPlug>> externalInputPlugs_;///< List of external input plugs
    std::vector<std::shared_ptr<AudioPlug>> externalOutputPlugs_;///< List of external output plugs
    std::vector<std::shared_ptr<AudioPlug>> musicDestPlugs_;   ///< List of music destination plugs
    std::vector<std::shared_ptr<AudioPlug>> musicSourcePlugs_; ///< List of music source plugs
    
    std::optional<std::vector<uint8_t>> statusDescriptorData_; ///< Status descriptor data
};

/**
 * @brief Audio subunit implementation
 * 
 * Represents an audio subunit in a FireWire audio device, which handles
 * audio data processing and routing.
 */
class AudioSubunit {
public:
    AudioSubunit() = default;
    ~AudioSubunit() = default;
    
    /**
     * @brief Get audio destination plug count
     * @return uint32_t Number of audio destination plugs
     */
    uint32_t getAudioDestPlugCount() const { return audioDestPlugCount_; }
    
    /**
     * @brief Get audio source plug count
     * @return uint32_t Number of audio source plugs
     */
    uint32_t getAudioSourcePlugCount() const { return audioSourcePlugCount_; }
    
    /**
     * @brief Set audio destination plug count
     * @param count Number of audio destination plugs
     */
    void setAudioDestPlugCount(uint32_t count) { audioDestPlugCount_ = count; }
    
    /**
     * @brief Set audio source plug count
     * @param count Number of audio source plugs
     */
    void setAudioSourcePlugCount(uint32_t count) { audioSourcePlugCount_ = count; }
    
    /**
     * @brief Add an audio destination plug
     * @param plug Shared pointer to the audio destination plug
     */
    void addAudioDestPlug(std::shared_ptr<AudioPlug> plug) { audioDestPlugs_.push_back(plug); }
    
    /**
     * @brief Add an audio source plug
     * @param plug Shared pointer to the audio source plug
     */
    void addAudioSourcePlug(std::shared_ptr<AudioPlug> plug) { audioSourcePlugs_.push_back(plug); }
    
    /**
     * @brief Get the list of audio destination plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of audio destination plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getAudioDestPlugs() const { return audioDestPlugs_; }
    
    /**
     * @brief Get the list of audio source plugs
     * @return const std::vector<std::shared_ptr<AudioPlug>>& List of audio source plugs
     */
    const std::vector<std::shared_ptr<AudioPlug>>& getAudioSourcePlugs() const { return audioSourcePlugs_; }
    
private:
    uint32_t audioDestPlugCount_{0};    ///< Number of audio destination plugs
    uint32_t audioSourcePlugCount_{0};  ///< Number of audio source plugs
    
    std::vector<std::shared_ptr<AudioPlug>> audioDestPlugs_;   ///< List of audio destination plugs
    std::vector<std::shared_ptr<AudioPlug>> audioSourcePlugs_; ///< List of audio source plugs
};

} // namespace FWA



